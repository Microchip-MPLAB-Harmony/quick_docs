{"0": {
    "doc": "License",
    "title": "License",
    "content": "IMPORTANT: READ CAREFULLY . MICROCHIP IS WILLING TO LICENSE THIS INTEGRATED SOFTWARE FRAMEWORK SOFTWARE AND ACCOMPANYING DOCUMENTATION OFFERED TO YOU ONLY ON THE CONDITION THAT YOU ACCEPT ALL OF THE FOLLOWING TERMS. TO ACCEPT THE TERMS OF THIS LICENSE, CLICK “I ACCEPT” AND PROCEED WITH THE DOWNLOAD OR INSTALL. IF YOU DO NOT ACCEPT THESE LICENSE TERMS, CLICK “I DO NOT ACCEPT,” AND DO NOT DOWNLOAD OR INSTALL THIS SOFTWARE. NON-EXCLUSIVE SOFTWARE LICENSE AGREEMENT FOR MICROCHIP MPLAB HARMONY INTEGRATED SOFTWARE FRAMEWORK . This Nonexclusive Software License Agreement (“Agreement”) is between you, your heirs, agents, successors and assigns (“Licensee”) and Microchip Technology Incorporated, a Delaware corporation, with a principal place of business at 2355 W. Chandler Blvd., Chandler, AZ 85224-6199, and its subsidiary, Microchip Technology (Barbados) II Incorporated (collectively, “Microchip”) for Microchip’s MPLAB Harmony Integrated Software Framework (“Software”) and accompanying documentation (“Documentation”). The Software and Documentation are licensed under this Agreement and not sold. U.S. copyright laws and international copyright treaties, and other intellectual property laws and treaties protect the Software and Documentation. Microchip reserves all rights not expressly granted to Licensee in this Agreement. | License and Sublicense Grant. (a) Definitions. As used this Agreement, the following terms shall have the meanings defined below: . (i) \"Licensee Products\" means Licensee products that use or incorporate Microchip Products. (ii) \"Microchip Product\" means Microchip 16-bit and 32-bit microcontrollers, digital signal controllers or other Microchip semiconductor products with PIC16 and PIC18 prefix and specifically excepting the CX870 and CY920, which are not covered under this Agreement, that use or implement the Software. (iii) \"Object Code\" means the Software computer programming code provided by Microchip that is in binary form (including related documentation, if any) and error corrections, improvements and updates to such code provided by Microchip in its sole discretion, if any. (iv) \"Source Code\" means the Software computer programming code provided by Microchip that may be printed out or displayed in human readable form (including related programmer comments and documentation, if any), and error corrections, improvements, updates, modifications and derivatives of such code developed by Microchip, Licensee or Third Party. (v) \"Third Party\" means Licensee's agents, representatives, consultants, clients, customers, or contract manufacturers. (vi) \"Third Party Products\" means Third Party products that use or incorporate Microchip Products. (b) Software License Grant. Subject to the terms of this Agreement, Microchip grants strictly to Licensee a personal, worldwide, non-exclusive, non-transferable limited license to use, modify (except as limited by Section 1(f) below), copy and distribute the Software only when the Software is embedded on a Microchip Product that is integrated into Licensee Product or Third Party Product pursuant to Section 2(d) below. Any portion of the Software (including derivatives or modifications thereof) may not be: . (i) embedded on a non-Microchip microcontroller or digital signal controller; (ii) distributed (in Source Code or Object Code), except as described in Section 2(d) below. (c) Documentation License Grant. Subject to all of the terms and conditions of this Agreement, Microchip grants strictly to Licensee a perpetual, worldwide, non-exclusive license to use the Documentation in support of Licensee’s use of the Software. (d) Sublicense Grants. Subject to terms of this Agreement, Licensee may grant a limited sublicense to a Third Party to use the Software as described below only if such Third Party expressly agrees to be bound by terms of confidentiality and limited use that are no broader in scope and duration than the confidentiality and limited use terms of this Agreement: . (i) Third Party may modify Source Code for Licensee, except as limited by Section 1(f) below. (ii) Third Party may program Software into Microchip Products for Licensee. (iii) Third Party may use Software to develop and/or manufacture Licensee Product. (iv) Third Party may use Software to develop and/or manufacture Third Party Products where either: (x) the sublicensed Software contains Source Code modified or otherwise optimized by Licensee for Third Party use; or (y) the sublicensed Software is programmed into Microchip Products by Licensee on behalf of such Third Party. (v) Third Party may use the Documentation in support of Third Party's authorized use of the Software in conformance with this Section 2(d). (e) Audit. Authorized representatives of Microchip shall have the right to reasonably inspect Licensee’s premises and to audit Licensee’s records and inventory of Licensee Products, whether located on Licensee’s premises or elsewhere at any time, announced or unannounced, and in its sole and absolute discretion, in order to ensure Licensee’s adherence to the terms of this Agreement. (f) License and Sublicense Limitation. This Section 1 does not grant Licensee or any Third Party the right to modify any dotstack™ Bluetooth® stack, profile, or iAP protocol included in the Software. | Third Party Requirements. Licensee acknowledges that it is Licensee’s responsibility to comply with any third party license terms or requirements applicable to the use of such third party software, specifications, systems, or tools, including but not limited to SEGGER Microcontroller GmbH &amp; Co. KG’s rights in the emWin software and certain libraries included herein. Microchip is not responsible and will not be held responsible in any manner for Licensee’s failure to comply with such applicable terms or requirements. | Open Source Components. Notwithstanding the license grants contained herein, Licensee acknowledges that certain components of the Software may be covered by so-called “open source” software licenses (“Open Source Components”). Open Source Components means any software licenses approved as open source licenses by the Open Source Initiative or any substantially similar licenses, including any license that, as a condition of distribution, requires Microchip to provide Licensee with certain notices and/or information related to such Open Source Components, or requires that the distributor make the software available in source code format. Microchip will use commercially reasonable efforts to identify such Open Source Components in a text file or “About Box” or in a file or files referenced thereby (and will include any associated license agreement, notices, and other related information therein), or the Open Source Components will contain or be accompanied by its own license agreement. To the extent required by the licenses covering Open Source Components, the terms of such licenses will apply in lieu of the terms of this Agreement, and Microchip hereby represents and warrants that the licenses granted to such Open Source Components will be no less broad than the license granted in Section 1(b). To the extent the terms of the licenses applicable to Open Source Components prohibit any of the restrictions in this Agreement with respect to such Open Source Components, such restrictions will not apply to such Open Source Components. | Licensee’s Obligations. (a) Licensee will ensure Third Party compliance with the terms of this Agreement. (b) Licensee will not: (i) engage in unauthorized use, modification, disclosure or distribution of Software or Documentation, or its derivatives; (ii) use all or any portion of the Software, Documentation, or its derivatives except in conjunction with Microchip Products; or (iii) reverse engineer (by disassembly, decompilation or otherwise) Software or any portion thereof; or (iv) copy or reproduce all or any portion of Software, except as specifically allowed by this Agreement or expressly permitted by applicable law notwithstanding the foregoing limitations. (c) Licensee must include Microchip’s copyright, trademark and other proprietary notices in all copies of the Software, Documentation, and its derivatives. Licensee may not remove or alter any Microchip copyright or other proprietary rights notice posted in any portion of the Software or Documentation. (d) Licensee will defend, indemnify and hold Microchip and its subsidiaries harmless from and against any and all claims, costs, damages, expenses (including reasonable attorney’s fees), liabilities, and losses, including without limitation product liability claims, directly or indirectly arising from or related to: (i) the use, modification, disclosure or distribution of the Software, Documentation or any intellectual property rights related thereto; (ii) the use, sale, and distribution of Licensee Products or Third Party Products, and (iii) breach of this Agreement. THE FOREGOING STATES THE SOLE AND EXCLUSIVE LIABILITY OF THE PARTIES FOR INTELLECTUAL PROPERTY RIGHTS INFRINGEMENT. | Confidentiality. (a) Licensee agrees that the Software (including but not limited to the Source Code, Object Code and library files) and its derivatives, Documentation and underlying inventions, algorithms, know-how and ideas relating to the Software and the Documentation are proprietary information belonging to Microchip and its licensors (“Proprietary Information”). Except as expressly and unambiguously allowed herein, Licensee will hold in confidence and not use or disclose any Proprietary Information and shall similarly bind its employees and Third Party(ies) in writing. Proprietary Information shall not include information that: (i) is in or enters the public domain without breach of this Agreement and through no fault of the receiving party; (ii) the receiving party was legally in possession of prior to receiving it; (iii) the receiving party can demonstrate was developed by it independently and without use of or reference to the disclosing party’s Proprietary Information; or (iv) the receiving party receives from a third party without restriction on disclosure. If Licensee is required to disclose Proprietary Information by law, court order, or government agency, such disclosure shall not be deemed a breach of this Agreement provided that Licensee gives Microchip prompt notice of such requirement in order to allow Microchip to object or limit such disclosure, Licensee cooperates with Microchip to protect Proprietary Information, and Licensee complies with any protective order in place and discloses only the information required by process of law. (b) Licensee agrees that the provisions of this Agreement regarding unauthorized use and nondisclosure of the Software, Documentation and related Proprietary Rights are necessary to protect the legitimate business interests of Microchip and its licensors and that monetary damages alone cannot adequately compensate Microchip or its licensors if such provisions are violated. Licensee, therefore, agrees that if Microchip alleges that Licensee or Third Party has breached or violated such provision then Microchip will have the right to petition for injunctive relief, without the requirement for the posting of a bond, in addition to all other remedies at law or in equity. | Ownership of Proprietary Rights. (a) Microchip and its licensors retain all right, title and interest in and to the Software and Documentation (“Proprietary Rights”) including, but not limited to: (i) patent, copyright, trade secret and other intellectual property rights in the Software, Documentation, and underlying technology; (ii) the Software as implemented in any device or system, all hardware and software implementations of the Software technology (expressly excluding Licensee and Third Party code developed and used in conformance with this Agreement solely to interface with the Software and Licensee Products and/or Third Party Products); and (iii) all modifications and derivative works thereof (by whomever produced). Further, modifications and derivative works shall be considered works made for hire with ownership vesting in Microchip on creation. To the extent such modifications and derivatives do not qualify as a “work for hire,” Licensee hereby irrevocably transfers, assigns and conveys the exclusive copyright thereof to Microchip, free and clear of any and all liens, claims or other encumbrances, to the fullest extent permitted by law. Licensee and Third Party use of such modifications and derivatives is limited to the license rights described in Section 1 above. (b) Licensee shall have no right to sell, assign or otherwise transfer all or any portion of the Software, Documentation or any related intellectual property rights except as expressly set forth in this Agreement. | Termination of Agreement. Without prejudice to any other rights, this Agreement terminates immediately, without notice by Microchip, upon a failure by License or Third Party to comply with any provision of this Agreement. Further, Microchip may also terminate this Agreement upon reasonable belief that Licensee or Third Party have failed to comply with this Agreement. Upon termination, Licensee and Third Party will immediately stop using the Software, Documentation, and derivatives thereof, and immediately destroy all such copies, remove Software from any of Licensee’s tangible media and from systems on which the Software exists, and stop using, disclosing, copying, or reproducing Software (even as may be permitted by this Agreement). Termination of this Agreement will not affect the right of any end user or consumer to use Licensee Products or Third Party Products provided that such products were purchased prior to the termination of this Agreement. | Dangerous Applications. The Software is not fault-tolerant and is not designed, manufactured, or intended for use in hazardous environments requiring failsafe performance (“Dangerous Applications”). Dangerous Applications include the operation of nuclear facilities, aircraft navigation, aircraft communication systems, air traffic control, direct life support machines, weapons systems, or any environment or system in which the failure of the Software could lead directly or indirectly to death, personal injury, or severe physical or environmental damage. Microchip specifically disclaims (a) any express or implied warranty of fitness for use of the Software in Dangerous Applications; and (b) any and all liability for loss, damages and claims resulting from the use of the Software in Dangerous Applications. | Warranties and Disclaimers. THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. MICROCHIP AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR THE ACCURACY, RELIABILITY OR APPLICATION OF THE SOFTWARE OR DOCUMENTATION. MICROCHIP AND ITS LICENSORS DO NOT WARRANT THAT THE SOFTWARE WILL MEET REQUIREMENTS OF LICENSEE OR THIRD PARTY, BE UNINTERRUPTED OR ERROR-FREE. MICROCHIP AND ITS LICENSORS HAVE NO OBLIGATION TO CORRECT ANY DEFECTS IN THE SOFTWARE. LICENSEE AND THIRD PARTY ASSUME THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE AND DOCUMENTATION PROVIDED UNDER THIS AGREEMENT. | Limited Liability. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL OR EQUITABLE THEORY FOR ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS. The aggregate and cumulative liability of Microchip and its licensors for damages hereunder will in no event exceed $1000 or the amount Licensee paid Microchip for the Software and Documentation, whichever is greater. Licensee acknowledges that the foregoing limitations are reasonable and an essential part of this Agreement. | General. (a) Governing Law, Venue and Waiver of Trial by Jury. THIS AGREEMENT SHALL BE GOVERNED BY AND CONSTRUED UNDER THE LAWS OF THE STATE OF ARIZONA AND THE UNITED STATES WITHOUT REGARD TO CONFLICTS OF LAWS PROVISIONS. Licensee agrees that any disputes arising out of or related to this Agreement, Software or Documentation shall be brought in the courts of State of Arizona. The parties agree to waive their rights to a jury trial in actions relating to this Agreement. (b) Attorneys’ Fees. If either Microchip or Licensee employs attorneys to enforce any rights arising out of or relating to this Agreement, the prevailing party shall be entitled to recover its reasonable attorneys’ fees, costs and other expenses. (c) Entire Agreement. This Agreement shall constitute the entire agreement between the parties with respect to the subject matter hereof. It shall not be modified except by a written agreement signed by an authorized representative of Microchip. (d) Severability. If any provision of this Agreement shall be held by a court of competent jurisdiction to be illegal, invalid or unenforceable, that provision shall be limited or eliminated to the minimum extent necessary so that this Agreement shall otherwise remain in full force and effect and enforceable. (e) Waiver. No waiver of any breach of any provision of this Agreement shall constitute a waiver of any prior, concurrent or subsequent breach of the same or any other provisions hereof, and no waiver shall be effective unless made in writing and signed by an authorized representative of the waiving party. (f) Export Regulation. Licensee agrees to comply with all export laws and restrictions and regulations of the Department of Commerce or other United States or foreign agency or authority. (g) Survival. The indemnities, obligations of confidentiality, and limitations on liability described herein, and any right of action for breach of this Agreement prior to termination shall survive any termination of this Agreement. (h) Assignment. Neither this Agreement nor any rights, licenses or obligations hereunder, may be assigned by Licensee without the prior written approval of Microchip except pursuant to a merger, sale of all assets of Licensee or other corporate reorganization, provided that assignee agrees in writing to be bound by the Agreement. (i) Restricted Rights. Use, duplication or disclosure by the United States Government is subject to restrictions set forth in subparagraphs (a) through (d) of the Commercial Computer-Restricted Rights clause of FAR 52.227-19 when applicable, or in subparagraph (c)(1)(ii) of the Rights in Technical Data and Computer Software clause at DFARS 252.227-7013, and in similar clauses in the NASA FAR Supplement. Contractor/manufacturer is Microchip Technology Inc., 2355 W. Chandler Blvd., Chandler, AZ 85225-6199. | . If Licensee has any questions about this Agreement, please write to Microchip Technology Inc., 2355 W. Chandler Blvd., Chandler, AZ 85224-6199 USA, ATTN: Marketing. Microchip MPLAB Harmony Integrated Software Framework. Copyright © 2015 Microchip Technology Inc. All rights reserved. License Rev. 11/2015 . Copyright © 2015 Qualcomm Atheros, Inc. All Rights Reserved. Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ",
    "url": "http://localhost:4000/quick_docs/mplab_harmony_license.html",
    "relUrl": "/mplab_harmony_license.html"
  },"1": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Create “Hello World” application on PIC MCUs",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#create-hello-world-application-on-pic-mcus",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#create-hello-world-application-on-pic-mcus"
  },"2": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Introduction",
    "content": "MPLAB Harmony v3 is a software development framework consisting of compatible and interoperable modules that include peripheral libraries (PLIBs), drivers, system services, middleware and third-party libraries. The MPLAB Harmony Configurator (MHC) is a GUI-based tool that provides an easy way to enable and configure various MPLAB Harmony modules. The MHC is a plug-in to the MPLAB X Integrated Development Environment (IDE). This page describes how to create an application on a 32-bit PIC32 microcontroller (MCU) using MHC with MPLAB Harmony v3 modules. This application sends a “Hello World!” string to a console running on a computer. For this demonstration, the following MPLAB Harmony v3 modules are used and configured using the MHC: . | Clock PLIB using the Clock Manager to configure the microcontroller clock. | GPIO PLIB using the Pin Manager to configure the microcontroller I/Os. | UART PLIB to configure USART peripheral as serial port. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#introduction",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#introduction"
  },"3": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Required Software",
    "content": "The instructions in this tutorial assume that you have already installed following software. | MPLAB X Integrated Development Environment | MPLAB XC32/32++ C Compiler | MPLAB Harmony Configurator | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#required-software",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#required-software"
  },"4": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Required Hardware",
    "content": "The instructions in this tutorial use Curiosity PIC32MZ EF 2.0 Development Board. Similar kits will work similarly, but the setup and steps may not be exactly as described. Setup: The following figure shows the hardware setup details: . | Connect Curiosity PIC32MZ EF 2.0 Development Board micro USB port to PC using a micro USB cable | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#required-hardware",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#required-hardware"
  },"5": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Procedure",
    "content": "Step 1: Creating an MPLAB Harmony v3-based Project: . | Launch MPLAB X IDE. | In MPLAB X IDE, select File &gt; New Project (or click the New Project icon). | In the New Project window, select Microchip Embedded in the Categories pane and select 32-bit MPLAB Harmony 3 Project in the Projects pane. Note: If the option 32-Bit MPLAB Harmony v3 Project is not available, install the MPLAB Harmony v3 Configurator plug-in from Tools &gt; Plugins &gt; Available Plugins before continuing with this demonstration. | Click Next. | Under Framework Selection, in the Manage Framework section, enter the Framework Path (Path to the folder in which the MPLAB Harmony v3 packages are downloaded). For this demonstration, the MPLAB Harmony v3 packages are downloaded in the following location: D:\\microchip\\github\\h3. Note: For this demonstration application, the following MPLAB Harmony v3 packages are required: mhc, dev_packs, and csp. The MPLAB Harmony 3 Content Manager tool simplifies the downloading of the MPLAB Harmony v3 packages. If these packages are not downloaded, then the user can use the MPLAB Harmony 3 Content Manager tool to download them onto their computer. | Click Next. | Under Project Settings, in the Name and Location section, enter the following details: . | Location: Indicates the path to the root folder of the new project. All project files will be placed in this folder. The project location can be any valid path, for example: D:\\microchip\\github\\h3\\tech_brief. | Folder: Indicates the name of the MPLAB X IDE folder. Enter hello_world to create a hello_world.X folder. | Name: Enter name of the project as hello_world_pic32mz_ef_curiosity2. This name will be displayed in the MPLAB X IDE. | Path: The path information will be updated as and when users make changes to other fields. Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | . | Click Next. | Under the Configuration Settings section, enter the details as given below: . | Name: Enter the configuration name as pic32mz_ef_curiosity2. | Target Device: Choose PIC32MZ2048EFM144. Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | . | Click Finish to launch the MHC. Note: After clicking the Finish button, if MHC does not launch, users can launch it by selecting Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator from the MPLAB X IDE. | Before launching the MHC, the Configuration Database Setup window will be displayed, where the Device Family Pack (DFP) and Cortex Microcontroller Software Interface Standard (CMSIS) path can be changed, if required. For this demonstration, the default settings are used. | Click Launch. | The MHC plug-in will open in a new window. The image below highlights different section available in the MHC. Note: For this demonstration, Stand-alone mode is used for the MHC Window Manager by changing the settings in the MPLAB X IDE, by selecting &gt; Tools &gt; Options &gt; Plugins &gt; MPLAB Harmony Configurator 3 &gt; Window Manager. If the Native Netbeans mode of the MHC is required, users can set it as default mode by configuring it. | . Step 2: Adding and configuring the MPLAB Harmony components: . | From Tools, select Clock Configuration to launch the Clock Easy View. The Clock Easy View window will be displayed inside the MHC Window. | In the Clock Easy View window, scroll to the right and verify that the SYSCLK is set to 200 MHz. | To add and configure the UART Peripheral Library follow these steps: . | Under Available Components, expand Peripherals and then expand the options available for UART. | Double-click on UART6 to add it to the project graph | . | . 4.Select the UART6 Peripheral Library in the Project Graph, and in the Configuration Options window. Configure it as follows: . | Verify that the default baud rate is set to 115,200 . | Configure the UART pins in the Pin Settings window. In the MHC, select Tools &gt; Pin Configuration to open the Pin Settings window. | The MHC Pin Settings window will open and display these options: Pin Diagram, Pin Table, and Pin Settings. Note: According to schematic of the Curiosity PIC32MZ EF 2.0 Development Board, the PICkit™ On Board 4 (PKOB4) can be used as Virtual Com Port to have serial communication between PIC32MZ EF device and connected computer console. For that, RF2 (Pin #79) of the PIC32MZ EF must be configured as U6TX. | Click the Pin Settings tab and configure the RF2 pin as U6TX. | The same pin (RF2) can be configured by clicking the Pin Table tab. Note: The demonstration will use the UART PLIB for printing messages on the serial terminal. Therefore, in the UART6 configuration, only the transmit pin is configured and the receive pin is not configured. | . | . Step 3: Generating the Code . | In MHC click on the Save MHC State icon to save the MHC state before generating the code. | Save the configuration in its default location, when prompted. | Click on the generate code icon to generate the code. | The Modified Configuration window is prompted, click Save to save the configuration. | In the Generate Project window, click Generate to generate the code. | The above step triggers these actions in MHC: . | Generate the code as per the configurations done. | Place the generated code and required MPLAB Harmony framework files in the MPLAB Harmony project directory, in this case: D:\\microchip\\github\\h3\\tech_brief\\firmware\\src. | Add all generated codes and MPLAB Harmony framework files into the MPLAB Harmony project, as shown in the following figure. Note: The MPLAB Harmony project will be shown in another window as this project is in Standalone mode. | . | The generated code descriptions are as follows: . | definitions.h: Includes all the header files required for the project. | initialization.c: Initializes all the MPLAB Harmony modules used in the application. | interrupts.c: Contains the mapping of all the interrupt vectors on the selected device. | main.c: A function call to initialize the system present in this file. The user needs to develop their application in this file. | peripheral: All peripheral source codes are added in this folder. | . | . Note: The MHC provides an option to change the generated file name, and if this option is not used, by default, the file name main.c is generated. Step 4: Developing and Running an Application . To develop and run an application, follow these steps: . | Developing an application: For this demo application, add the highlighted codes (as shown in image below) in the main.c file. This will send the “Hello World!” string to the console running on the PC. The following code is provided for convenience: . uint8_t buffer[]= \"Hello World!\\r\\n\"; UART6_Write(&amp;buffer[0], sizeof(buffer)); . | Selecting Hardware Tool and Compiler: In the MPLAB X IDE Project Properties window perform these actions: | Under Categories section, select Conf: (pic32mz_ef_curiosity2), and in the Configuration section, select the hardware tool and compiler toolchain. | Click Apply, and then click OK. | Connecting Hardware: Connect a micro-USB cable between the DEBUG USB on the board and the PC. This enables the programming of the microcontroller and provide a serial connection with the console device (computer). | Setting up the Serial Console: Open a terminal application, such as Tera Term on the PC and perform the serial port setup. Below is the default setup details for Tera Term. | Programing and Running the Application: Build and program the Curiosity PIC32MZ EF 2.0 Development Board by using the MPLAB X IDE. | Select MPLAB PKoB 4 under Curiosity/Starter Kits (PKOB4) when prompted. | Observing the Output: Observe the “Hello World!” string on the console. If the desired output is not found on the console, press the Reset button on the Curiosity Development board to reset the device, and ensure that the UART message is communicated. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#procedure",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#procedure"
  },"6": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#note",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#note"
  },"7": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#reference-links",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#reference-links"
  },"8": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Create Hello World application on PIC MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html"
  },"9": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Create “Hello World” application on SAM MCUs",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#create-hello-world-application-on-sam-mcus",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#create-hello-world-application-on-sam-mcus"
  },"10": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Introduction",
    "content": "MPLAB Harmony v3 is a software development framework consisting of compatible and interoperable modules that include peripheral libraries (PLIBs), drivers, system services, middleware and third-party libraries. The MPLAB Harmony Configurator (MHC) is a GUI-based tool that provides an easy way to enable and configure various MPLAB Harmony modules. The MHC is a plug-in to the MPLAB X Integrated Development Environment (IDE). This page explains how to create a simple application on an Arm® Cortex®-based SAM Microcontroller (MCU) using the MHC with MPLAB Harmony v3 modules. This application sends a “Hello World!” string to a console running on a computer. For this demonstration, the following MPLAB Harmony v3 modules are used and configured using the MHC: . | Clock PLIB using the Clock Manager to configure the microcontroller clock. | PORT PLIB using the Pin Manager to configure the microcontroller I/Os. | Serial Communication (SERCOM) USART PLIB to configure USART peripheral as serial port. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#introduction",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#introduction"
  },"11": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Required Software",
    "content": "The instructions in this tutorial assume that you have already installed following software. | MPLAB X Integrated Development Environment | MPLAB XC32/32++ C Compiler | MPLAB Harmony Configurator | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#required-software",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#required-software"
  },"12": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Required Hardware",
    "content": "The instructions in this tutorial use SAMD21 Xplained Pro board and it has one Yellow Color user LED (PB30) connected GPIO. Similar kits will work similarly, but the setup and steps may not be exactly as described. Setup: The following figure shows the hardware setup details: . | Connect SAMD21 Xplained Pro Board micro USB port to PC using a micro USB cable | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#required-hardware",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#required-hardware"
  },"13": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Procedure",
    "content": "Step 1: To create an MPLAB Harmony v3-based project, follow these steps: . | Launch MPLAB X IDE. | In MPLAB X IDE, select File &gt; New Project (or click the New Project icon). | In the New Project window, select Microchip Embedded in the Categories pane and select 32-bit MPLAB Harmony 3 Project in the Projects pane. Note: If the option 32-Bit MPLAB Harmony v3 Project is not available, install the MPLAB Harmony v3 Configurator plug-in from Tools &gt; Plugins &gt; Available Plugins before continuing with this demonstration. | Click Next. | Under the Manage Framework section, enter the Framework Path (Path to the folder in which the MPLAB Harmony v3 packages are downloaded). For this demonstration, the MPLAB Harmony v3 packages are downloaded in the following location: D:\\microchip\\github\\h3. Note: For this demonstration application, the following MPLAB Harmony v3 packages are required: mhc, dev_packs, and csp. The MPLAB Harmony 3 Content Manager tool simplifies the downloading of the MPLAB Harmony v3 packages. If these packages are not downloaded, then the user can use the MPLAB Harmony 3 Content Manager tool to download them onto their computer. | Click Next. | Under the Name and Location section, enter the following details: . | Location: Indicates the path to the root folder of the new project. All project files will be placed in this folder. The project location can be any valid path, for example: D:\\microchip\\github\\h3\\tech_brief. | Folder: Indicates the name of the MPLAB X IDE folder. Enter hello_world to create a hello_world.X folder. | Name: Enter name of the project as hello_world_sam_d21_xpro. This name will be displayed in the MPLAB X IDE. | Path: The path information will be updated as and when users make changes to other fields. Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | . | Click Next. | Under the Configuration Settings section, enter the details as given below: . | Name: Enter the configuration name as sam_d21_xpro | Target Device: Choose ATSAMD21J18A. Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | . | Click Finish to launch the MHC. Note: After clicking the Finish button, if MHC does not launch, users can launch it by selecting Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator from the MPLAB X IDE. | Before launching the MHC, the Configuration Database Setup window will be displayed, where the Device Family Pack (DFP) and Cortex Microcontroller Software Interface Standard (CMSIS) path can be changed, if required. For this demonstration, the default settings are used. | Click Launch. | The MHC plug-in will open in a new window. The image below highlights different section available in the MHC. Note: For this demonstration, Stand-alone mode is used for the MHC Window Manager by changing the settings in the MPLAB X IDE, by selecting &gt; Tools &gt; Options &gt; Plugins &gt; MPLAB Harmony Configurator 3 &gt; Window Manager. If the Native Netbeans mode of the MHC is required, users can set it as default mode by configuring it. | . Step 2: To add and configure the MPLAB Harmony components using the MHC, follow these steps: . | From Tools, select Clock Configuration to launch the Clock Easy View. The Clock Easy View window will be displayed inside the MHC Window. | In the Clock Easy View window, scroll to the right and verify that the Main Clock is set to 48 MHz. | To add and configure the USART Peripheral Library follow these steps: . | Under Available Components, expand Peripherals and then expand the options available for SERCOM. | Double-click on the SERCOM3 to add it to the project | . | Select the SERCOM3 Peripheral Library in the Project Graph, and in the Configuration Options window, configure it as follows: . | SERCOM Operation mode is set for USART with Internal Clock (default setting). | Clear Receive Enable, as the string will only be transmitted in this example. | Set the Baud Rate to 9600. | For Transmit Pinout choose SERCOM PAD[0] (default setting). | By default, the Receive Pinout is SERCOM PAD[0]. If the Receive Pinout feature is disabled, it will not affect the operation. | . | Configure the USART pin in the Pin Settings: In the MHC, select Tools &gt; Pin Configuration to open the Pin Settings window. | The MHC Pin Settings window will open and display these options: Pin Diagram, Pin Table, and Pin Settings. Note: According to the schematic of the SAMD21 Xplained Pro board, the on-board Embedded Debugger (EDBG) can be used as Virtual Com Port to have serial communication between the SAMD21 device and a connected computer console. Therefore, the PA22 (Pin #43) of the SAMD21 must be configured as USART_TX (SERCOM3 PAD0). | Click the Pin Settings tab and configure the PA22 pin as SERCOM3_PAD0. | The same pin (PA22) can be configured by clicking the Pin Table tab. Note: . | The USART_TX function (Transmit Pinout) is by default configured to be on SERCOM3 PAD0, for additional information, refer to MHC SERCOM Configuration. | In the SERCOM3 USART configuration, the USART is enabled only for transmit functionality. Therefore, the USART receive pin is not configured. | . | . Step 3: To generate the code, follow these steps: . | In MHC click on the Save MHC State icon to save the MHC state before generating the code. | Save the configuration in its default location, when prompted. | Click on the generate code icon to generate the code. | The Modified Configuration window is prompted, click Save to save the configuration. | In the Generate Project window, click Generate to generate the code. | The above step triggers these actions in MHC: . | Generate the code as per the configurations done. | Place the generated code and required MPLAB Harmony framework files in the MPLAB Harmony project directory, in this case: D:\\microchip\\github\\h3\\tech_brief\\firmware\\src. | Add all generated codes and MPLAB Harmony framework files into the MPLAB Harmony project, as shown in the following figure. Note: The MPLAB Harmony project will be shown in another window as this project is in Standalone mode. | . | The generated code descriptions are as follows: . | definitions.h: Includes all the header files required for the project. | initialization.c: Initializes all the MPLAB Harmony modules used in the application. | interrupts.c: Contains the mapping of all the interrupt vectors on the selected device. | main.c: A function call to initialize the system present in this file. The user needs to develop their application in this file. | peripheral: All peripheral source codes are added in this folder. Note: The MHC provides an option to change the generated file name, and if this option is not used, by default, the file name main.c is generated. | . | . Note: The MHC provides an option to change the generated file name, and if this option is not used, by default, the file name main.c is generated. Step 4: To develop and run an application, follow these steps: . | Developing an application: For this demo application, add the highlighted codes (as shown in image below) in the main.c file. This will send the “Hello World!” string to the console running on the PC. The following code is provided for convenience: | . uint8_t buffer[]= \"Hello World!\\r\\n\"; SERCOM3_USART_Write(&amp;buffer[0], sizeof(buffer)); . | Selecting Hardware Tool and Compiler: In the MPLAB X IDE Project Properties window perform these actions: | Under Categories section, select Conf: (sam_d21_xpro), and in the Configuration section, select the hardware tool and compiler toolchain. | Click OK. | Connecting Hardware: Connect a micro-USB cable between the DEBUG USB on the board and the PC. This enables the programming of the microcontroller and provide a serial connection with the console device (computer). | Setting up the Serial Console: Open a terminal application, such as Tera Term on the PC and perform the serial port setup. Below is the default setup details for Tera Term. | Programing and Running the Application: Build and program the SAMD21 Xplained Pro kit by using the MPLAB X IDE. | Observing the Output: Observe the “Hello World!” string on the console. If the desired output is not found on the console, press the Reset button on the Xplained Pro board to reset the device, and ensure that the UART message is communicated. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#procedure",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#procedure"
  },"14": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#note",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#note"
  },"15": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#reference-links",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#reference-links"
  },"16": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Create Hello World application on SAM MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html"
  },"17": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Creating an IAR or KEIL project using MHC",
    "content": "When creating projects for IAR or KEIL IDEs, MHC is launched as an application (as opposed to a plugin in MPLAB® X, when creating MPLAB® X projects). We refer to this mode of operation of MHC as “standalone” mode throughout this document. Follow the steps detailed below to create an project for IAR or KEIL using MHC . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-an-iar-or-keil-project-using-mhc",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-an-iar-or-keil-project-using-mhc"
  },"18": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Launching MHC in standalone mode",
    "content": "Navigate to the local clone of this repository and run the script that is appropriate for your operating system. That is . | For Windows, run the script runmhc.bat | For Linux/MacOS, run the script runmhc.sh | . This will launch the MHC as an application (see below): . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#launching-mhc-in-standalone-mode",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#launching-mhc-in-standalone-mode"
  },"19": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Setting user preferences",
    "content": "User preferences can be set by navigating to File -&gt; Preferences. MHC allows user to configure two preferences . | Diff - Allows user to configure a diff tool. This is an important configuration, and is explained further down in project generation section. We can configure any third party diff tool. To set diff tool, navigate to its installation directory using the browse button and select the executable. {0} and {1} are place holders for the files that need to diffed during project file generation. In this example, we are using WinMerge as the diff tool. | Log - Allows user to set the log level. There are three levels of logging available (ALL, DEBUG, USER). MHC displays the logs in the console window (seen at the bottom of the main window). It also saves them in the mhc.log file under .mh3 folder in user’s home directory. This log level decides the kind of messages that will get logged. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#setting-user-preferences",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#setting-user-preferences"
  },"20": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Creating a new configuration",
    "content": "To create a new mhc configuration, choose File -&gt; New configuration. A new configuration creation dialog will popup, where we can enter the details of the configuration that we are about to create. | Framework Path - This is not configurable. Framework path defaults to the parent folder of the MHC repository. This folder is should contain relevant harmony 3 repositories required for project creation. Recommend using content manager for downloading and setting up Harmony 3 repositories. Make sure that the “Convert to relative path for configuration” check box is unchecked. | Project information - Under project information, user can choose the location of the project, name of the project and the name of the configuration. | Location - Location where the project and configuration will be created | Project name -Used by MHC when creating projects for target IDEs. If you want a KEIL or IAR project with specific name, it should be entered in this field | Configuration name - Used by MHC when creating configuration data | Path - Shows the location where the new configuration will be created. Paths used by MHC for creating the project and configuration follows these rules . | configuration information will be created under &lt;location&gt;/firmware/source/config/&lt;configuration_name&gt; folder. In this example it will be “D:\\Projects\\My_Harmony_3\\firmware\\src\\config\\default” folder | IDE projects will be created under &lt;location&gt;/firmware/&lt;configuration_name&gt;.&lt;IDE name&gt; folder. In this example, if we choose to create an IAR project, it will be created under “D:\\Projects\\My_Harmony_3\\firmware\\default.IAR” folder | . | . | Configuration Options - Allows us to choose the target device of this confifuration. Device Family drop down limits the options to a specific family when choosing the target device, while Device Filter allows searching for a device by entering few characters. In this instance, ATSAMC21N18A MCU is chosen for creating the configuration. | . Clicking finish button will popup a confirmation dialog. We can change the default Device Family Pack (DFP) and CMSIS Pack used for creating the configuration from this dialog. Click on the launch button to create a new configuration. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-a-new-configuration",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-a-new-configuration"
  },"21": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Making changes to the configuration",
    "content": "Refer to documentation on how to use the project graph for configuring Harmony 3 components using mplabx Harmony 3 configurator. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#making-changes-to-the-configuration",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#making-changes-to-the-configuration"
  },"22": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Generating code and project associated with a configuration",
    "content": ". | Select the target toolchain by clicking the system component in the project graph and choosing System -&gt; Project Configuration -&gt; Toolchain selections -&gt; Compilers in the configuration option window. Available options are XC32, IAR and KEIL. Some of these options might not be available for all targets. Choosing IAR or KEIL as the target compiler, will result in MHC creating IAR embedded workbench or Keil uVision IDE projects for the selected target. In this case, we have chosen KEIL as the toolchain. | Select Generate - &gt; Generate code option in menu bar to start project generation. In the generation window, we can choose the merge strategies. | Based on the choosen merge startegy, when MHC identifies that there is a diff in the files it generated (for eg: modification within the project IDE), it will launch the configured diff tool. We can bring in the changes that are relevant and ignore the rest. Once the diff tool is closed, the project generation sequence is continued until the entire configuration is generated. | If IAR or KEIL is chosen as the toolchain, MHC will also create a folder containing the relevant project files which can then be opened using the corresponding IDE. The path of this folder, follows the rules explained in the “configuration” section. In this example, it would be under \"D:\\Projects\\My_Harmony_3\\firmware\\default.KEIL\", since we choose keil as the the toolchain. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#generating-code-and-project-associated-with-a-configuration",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#generating-code-and-project-associated-with-a-configuration"
  },"23": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#note",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#note"
  },"24": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#reference-links",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#reference-links"
  },"25": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Create IAR or Keil project using MHC",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html"
  },"26": {
    "doc": "Create new TrustZone Project",
    "title": "Creating a New TrustZone Project",
    "content": "To create a new TrustZone project, in MPLAB® X IDE, Select File &gt; New Project or click . The New Project wizard will open. Perform following steps: . | Choose Project: . | In the Choose Project pane, select the Microchip Embedded category. | In the Projects pane, select 32-bit MPLAB® Harmony 3 Project, then click Next. | . Note: If the 32-Bit MPLAB® Harmony 3 Project type is not listed under the Microchip Embedded category, please download and install MPLAB® Harmony 3 Configurator before continuing with these steps. | Framework Selection: . | Provide the framework path where Harmony 3 repositorries have been downloaded, then click Next. | . | Project Settings: . | Location: Indicates the path to the root folder of the new project. All project files will be placed in this folder. | Folder: Indicates the name of the MPLAB® X IDE folder. | Name: Enter name of the project which you want to see in MPLAB® X IDE, click Next. | Path: The path information will be updated automatically as and when users make changes to other fields. | . Note: Click the “Show Visual Help” button to open a contextual help window for a detailed description of various fields in the Project Settings. | Configuration Settings: . | Name: Enter the configuration name. | Target Device: Choose target device | TrustZone Enabled: Select checkbox and click Finish to launch MPLAB® Harmony Configurator (MHC). After clicking the Finish button, MHC will create Secure and Non-secure MPLAB® X Projects. | . Note: . | After clicking the Finish button, if MHC does not launch, user can launch it by selecting Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator from the MPLAB® X IDE. | . | . The MHC plug-in will open either inside MPLAB® X window (native mode) or in a new window (standalone mode). This setting can be done in MPLAB® X &gt; Tools &gt; Options &gt; Plugins &gt; MPLAB® Harmony Configurator 3 &gt; Window Manager. TrustZone Project uses two projects viz., Secure and Non-Secure Project that work together on the same MCU and offering security isolation between the Trusted and the Non-trusted resources in the device. | Secure Project: . | Secure project contains harmony project file harmony.prj. And this project also contains a configuration file for both Secure and Non-secure project. | Secure project must be selected as Main Project to launch MHC. | Once the Harmony code is generated, Secure user application should be developed in secure “main.c”. And “veneer.c” and “veneer.h” files should be used for the Non-secure to Secure function calls and vice versa. | Secure project is a loadable project from the Non-secure project. When Secure Project builds it generates Secure Gateway (SG) library ([configuration name]_Secure_sg_veneer.lib) which will be used by the Non-secure project while building the Non-secure project. | . | Non-secure Project: . | Once the Harmony code is generated, Non-secure user application should be developed in Non-secure “main.c”. | When Non-secure Project builds, it first builds Secure Project and then Non-secure project and generates target binaries to be executed on the device. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#creating-a-new-trustzone-project",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#creating-a-new-trustzone-project"
  },"27": {
    "doc": "Create new TrustZone Project",
    "title": "Runing TrustZone Project",
    "content": "Following steps need to be done to run TrustZone project: . | In MPLAB® X Non-secure Project properties, appropriate compiler, hardware tools and DFP should be selected as shown in the figure below. | Select Non-secure Project as Main Project, Non-secure Project can be then build and programmed using MPLAB® X “Make and Program Device Main Project” option. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#runing-trustzone-project",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#runing-trustzone-project"
  },"28": {
    "doc": "Create new TrustZone Project",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#note",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#note"
  },"29": {
    "doc": "Create new TrustZone Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#reference-links",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#reference-links"
  },"30": {
    "doc": "Create new TrustZone Project",
    "title": "Create new TrustZone Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html"
  },"31": {
    "doc": "Harmony 3 Packages",
    "title": "Harmony 3 Packages",
    "content": "This page describes the packages that make up the MPLAB® Harmony software development framework. These packages are foundin the MPLAB Harmony GitHub repository and can be downloaded using the MPLAB Harmony 3 Content Manager. | Package Name | Descriptions | Example Function Names | . | mhc | Contains the implementation of the MPLAB Harmony Configurator (MHC) tool. | – | . | dev_packs | Describes all peripherals, memory, etc. of each supported 32-bit device. | – | . | csp | Chip Support Package (CSP) supports initialization of Microchip 32-bit SAM and PIC® microcontroller and microprocessor devices. The peripheral libraries (PLIB) allow the development of simple applications that directly control the SAM and PIC peripherals. | UARTx_Initialize, UARTx_Read, TMRx_Start, TMRx_Stop, TCx_TimerStart, TCx_TimerStop, PORT_PinSet, PORT_PinRead | . | csp_apps_pic32mk | Contains the Harmony 3 peripheral library application examples for PIC32MK family | – | . | csp_apps_pic32mx | Contains the Harmony 3 peripheral library application examples for PIC32MX family | – | . | csp_apps_pic32mz_da | Contains the Harmony 3 peripheral library application examples for PIC32MZ DA family | – | . | csp_apps_pic32mz_ef | Contains the Harmony 3 peripheral library application examples for PIC32MZ EF family | – | . | csp_apps_pic32mz_w1 | Contains the Harmony 3 peripheral library application examples for PIC32MZ W1 family | – | . | csp_apps_sam_9x60 | Contains the Harmony 3 peripheral library application examples for SAM 9X60 family | – | . | csp_apps_sam_a5d2 | Contains the Harmony 3 peripheral library application examples for SAM A5D2 family | – | . | csp_apps_sam_c20_c21 | Contains the Harmony 3 peripheral library application examples for SAM C20/C21 family | – | . | csp_apps_sam_d10 | Contains the Harmony 3 peripheral library application examples for SAM D10 family | – | . | csp_apps_sam_d11 | Contains the Harmony 3 peripheral library application examples for SAM D11 family | – | . | csp_apps_sam_d20 | Contains the Harmony 3 peripheral library application examples for SAM D20 family | – | . | csp_apps_sam_d21_da1 | Contains the Harmony 3 peripheral library application examples for SAM D21/DA1 family | – | . | csp_apps_sam_d5x_e5x | Contains the Harmony 3 peripheral library application examples for SAM D5X/E5X family | – | . | csp_apps_sam_e70_s70_v70_v71 | Contains the Harmony 3 peripheral library application examples for SAM E70/S70/V70/V71 family | – | . | csp_apps_sam_g55 | Contains the Harmony 3 peripheral library application examples for SAM G55 family | – | . | csp_apps_sam_ha1 | Contains the Harmony 3 peripheral library application examples for SAM HA1 family | – | . | csp_apps_sam_l10_l11 | Contains the Harmony 3 peripheral library application examples for SAM L10/L11 family | – | . | csp_apps_sam_l21 | Contains the Harmony 3 peripheral library application examples for SAM L21 family | – | . | csp_apps_sam_l22 | Contains the Harmony 3 peripheral library application examples for SAM L22 family | – | . | csp_apps_sam_rh71 | Contains the Harmony 3 peripheral library application examples for SAM RH71 family | – | . | bsp | Board Support Package (BSP) defines the name of the evaluation board and the name of switches and LEDs on the board. It also defines the attributes of the pins connected to the switches and LEDs (e.g.: data direction). | – | . | core | Provides drivers and system services that have advanced capabilities and a higher level of abstraction that gives better hardware independence. The drivers and services provide abstracted interfaces that do not change from device to device. Peripheral Library (PLIB) interfaces, while providing lower overhead and more direct control, give no such guarantee. Applications written using driver and service APIs do not usually need to be modified if the device configuration is changed or even if a new Microchip MCU or MPU device is selected. This package also implements the Operating System Abstraction Layer (OSAL). | DRV_USART_Initialize, DRV_USART_ReadBuffer, DRV_I2C_Initialize, DRV_I2C_ReadTransfer, SYS_TIME_TimerCreate, SYS_TIME_TimerCounterGet, OSAL_Malloc | . | crypto | The Cryptographic Library includes functions to perform encryption, decryption, hashing, authentication, and compression within the embedded application. Random number generation (RNG) functions are also provided. The library provides DES, 3DES, and AES for block cipher needs. Depending on the algorithm in use, CBC and CTR modes are supported. | CRYPT_RNG_Initialize, CRYPT_RNG_Get, CRYPT_ECC_KeySizeGet, CRYPT_SHA256_DataAdd | . | core_apps_pic32mk | Contains the Harmony 3 driver and system service application examples for PIC32MK family | – | . | core_apps_pic32mx | Contains the Harmony 3 driver and system service application examples for PIC32MX family | – | . | core_apps_pic32mz_da | Contains the Harmony 3 driver and system service application examples for PIC32MZ DA family | – | . | core_apps_pic32mz_ef | Contains the Harmony 3 driver and system service application examples for PIC32MZ EF family | – | . | core_apps_pic32mz_w1 | Contains the Harmony 3 driver and system service application examples for PIC32MZ W1 family | – | . | core_apps_sam_9x60 | Contains the Harmony 3 driver and system service application examples for SAM 9X60 family | – | . | core_apps_sam_a5d2 | Contains the Harmony 3 driver and system service application examples for SAM A5D2 family | – | . | core_apps_sam_c20_c21 | Contains the Harmony 3 driver and system service application examples for SAM C20/C21 family | – | . | core_apps_sam_d20 | Contains the Harmony 3 driver and system service application examples for SAM D20 family | – | . | core_apps_sam_d21_da1 | Contains the Harmony 3 driver and system service application examples for SAM D21/DA1 family | – | . | core_apps_sam_d5x_e5x | Contains the Harmony 3 driver and system service application examples for SAM D5X/E5X family | – | . | core_apps_sam_e70_s70_v70_v71 | Contains the Harmony 3 driver and system service application examples for SAM E70/S70/V70/V71 family | – | . | core_apps_sam_g55 | Contains the Harmony 3 driver and system service application examples for SAM G55 family | – | . | core_apps_sam_ha1 | Contains the Harmony 3 driver and system service application examples for SAM HA1 family | – | . | core_apps_sam_l10_l11 | Contains the Harmony 3 driver and system service application examples for SAM L10/L11 family | – | . | core_apps_sam_l21 | Contains the Harmony 3 driver and system service application examples for SAM L21 family | – | . | core_apps_sam_l22 | Contains the Harmony 3 driver and system service application examples for SAM L22 family | – | . | core_apps_sam_rh71 | Contains the Harmony 3 driver and system service application examples for SAM RH71 family | – | . | gfx | Contains the Aria Graphics library, the MPLAB Harmony Graphics Composer (MHGC) plug-in, the Display Manager plug-in. It also includes a simple quickstart application (Aria Quickstart) that provides a touch-enabled starting point for Aria Graphics development. | GFX_ActiveContext, GFX_Set, GFXU_StringFontIndexLookup | . | gfx_apps | Contains all other (non-quickstart) Aria and Legato Graphics Library demonstration projects | – | . | net | Contains the MPLAB Harmony 3 Network Package (Net). The Net repo provides a free fast to market TCP/IP stack for Microchip 32-bit SAM and PIC microprocessor devices. The repo contains multiple applications that demonstrate communication over TCP/IP using well-known protocols like TCP, UDP, HTTP, SMTP, etc. | TCPIP_STACK_Status, TCPIP_STACK_NetIsReady, TCPIP_TCP_ArrayPut | . | usb | The USB module components provide USB middleware and drivers. It also includes a variety of USB-related firmware projects that demonstrate the capabilities of the MPLAB Harmony USB stack. | USB_DEVICE_Attach, USB_DEVICE_EventHandlerSet, USB_HOST_CDC_AttachEventHandlerSet | . | audio | Contains a variety of audio-related firmware projects that demonstrate the capabilities of the MPLAB Harmony audio offerings, drivers for hardware codecs that can be connected to development boards (e.g. WM8904 Codec Daughterboard), and a Board Support Package (BSP) Audio Template that can be used to make configuring a new audio project a matter of just a few mouse clicks. | DRV_WM8904_Initialize, DRV_WM8904_BufferAddRead, DRV_WM8904_VolumeSet | . | bt | Bluetooth-related firmware projects that demonstrate the capabilities of the MPLAB Harmony Bluetooth offerings, drivers for Bluetooth modules that can be connected to development boards (e.g. BM64 Bluetooth Module Daughterboard), and a BSP Bluetooth Template that can be used to make configuring a new Bluetooth project a matter of just a few mouse clicks. | DRV_BM64_Open, DRV_BM64_BufferAddRead, DRV_BM64_VolumeSet | . | motor_control | This module contains motor control demonstrations implemented on Microchip’s 32-bit SAM microcontrollers. You can use these demonstrations as a reference for developing your own motor control applications. It also includes the X2C-Scope plug-in for the MPLAB® X IDE. X2C-Scope enables you to read, write, and plot global variables (for motor control) in real time. It communicates with the target using the UART. | – | . | x2c | Contains the MPLAB Harmony 3 X2C solutions which includes support for X2CScope and model based development using Scilab/Xcos + X2C Library. | – | . | micrium_ucos3 | This repository contains MPLAB Harmony configurations and applications for the Micrium OS-III. Micrium OS-III software is not included and must be downloaded separately. | – | . | azure-rtos-threadx | This repository contains MPLAB Harmony 3 Azure RTOS ThreadX configurations and application examples. | – | . | touch | The Touch Library is a royalty-free library for developing touch applications on 32-bit microcontrollers with a Peripheral Touch Controller peripheral. You can use it to integrate the touch-sensing capability into your applications. The library supports both self-capacitance and mutual-capacitance acquisition methods. | – | . | wireless | This repository contains the MPLAB® Harmony 3 Wireless solutions and example applications. It helps quickly incorporate connectivity to designs with wireless ICs, modules, software and development kits that make connecting. | – | . | aws_cloud | MPLAB® Harmony 3 Configurations and Applications to securely connect IoT devices to the AWS cloud using Amazon FreeRTOS. | – | . | bootloader | This repository contains the MPLAB® Harmony 3 Bootloader. This can be used to upgrade the firmware on a target device without the need for an external programmer or debugger. | bootloader_Trigger, bootloader_Start, run_Application | . | bootloader_apps_uart | Contains the Harmony 3 UART Bootloader Application Examples | – | . | bootloader_apps_i2c | Contains the Harmony 3 I2C Bootloader Application Examples | – | . | bootloader_apps_usb | Contains the Harmony 3 USB Bootloader Application Examples | – | . | bootloader_apps_ethernet | Contains the Harmony 3 Ethernet Bootloader Application Examples | – | . | bootloader_apps_sdcard | Contains the Harmony 3 SDCARD Bootloader Application Examples | – | . | aerospace | This repository contains the MPLAB® Harmony 3 Aerospace solutions and example applications. It helps quickly incorporate connectivity to designs with Aerospace ICs, modules, software and development kits that make connecting effortless. | – | . | cryptoauthlib_apps | This repository contains the MPLAB® Harmony 3 CryptoAuthLib Applications solutions and example applications | – | . | helix_mp3 | This repository contains the MPLAB® Harmony 3 Helix MP3 Decoder Library. The source code is brought into a project automatically when the “Enable MP3 Decoder” checkbox is checked in the MHC Configuration Options for the Audio Decoder Libraries component of the Audio repository. | – | . | ethercat | This repository contains the MPLAB® Harmony 3 EtherCAT solutions and example applications. | – | . | quick_docs | This repository contains the MPLAB® Harmony 3 Quick Documentation Package. | – | . | reference_apps | This repository contains the MPLAB® Harmony 3 Reference Applications. | – | . | classb_sam_e5x_d5x | This repository contains the MPLAB® Harmony 3 Class B Library. | – | . | ethercat | This repository contains the MPLAB® Harmony 3 EtherCAT solutions and example applications. | – | . | CMSIS-FreeRTOS | Cortex Microcontroller Software Interface Standard (CMSIS) FreeRTOS. By default, when Harmony 3 core or middleware libraries are used, the MPLAB Harmony Configurator (MHC) automatically includes FreeRTOS in order to provide more efficient use of the CPU. (RTOS use can still be disabled manually.) | – | . | zlib | A massively spiffy yet delicately unobtrusive compression library. | – | . | wolfssl | wolfSSL (formerly CyaSSL) is a small, fast, portable implementation of TLS/SSL for embedded devices to the cloud. wolfSSL supports up to TLS 1.3. | – | . | wolfssh | wolfSSH is a small, fast, portable SSH implementation, including support for SCP and SFTP. | – | . | wolfMQTT | This is an implementation of the MQTT Client written in C for embedded use, which supports SSL/TLS via the wolfSSL library. This library was built from the ground up to be multi-platform, space conscience and extensible. Integrates with wolfSSL to provide TLS support. | – | . | threadx | Azure RTOS ThreadX is an advanced real-time operating system (RTOS) designed specifically for deeply embedded applications. | – | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_packages/readme.html#harmony-3-packages",
    "relUrl": "/source/basic/harmony_3_packages/readme.html#harmony-3-packages"
  },"32": {
    "doc": "Harmony 3 Packages",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_packages/readme.html#reference-links",
    "relUrl": "/source/basic/harmony_3_packages/readme.html#reference-links"
  },"33": {
    "doc": "Harmony 3 Packages",
    "title": "Harmony 3 Packages",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_packages/readme.html",
    "relUrl": "/source/basic/harmony_3_packages/readme.html"
  },"34": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers",
    "content": "MPLAB Harmony v3 drivers provide a simple and abstracted ‘C’ language interface to the peripherals and other system resources. Some functions are similar across on all the device drivers, while other functions are unique to a specific driver or peripheral. Driver interface functions are generally independent of the details of how a given peripheral is implemented on any specific hardware, or how many instances of that peripheral exist in each system. Applications can control and easily interact with the peripherals by calling the driver interface. MPLAB Harmony v3 allows users to configure the drivers in any one of these operating modes: Synchronous (Blocking) or Asynchronous (Non-Blocking). | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs). | Allows queuing of multiple requests. Each instance of an Asynchronous driver has a dedicated queue. | Works seamlessly in bare-metal and RTOS environment. | Interrupt and thread-safe. | . | Synchronous Mode . | Blocking APIs | Support only RTOS environment | Interrupt and thread-safe | . | . This guide describes Synchronous and Asynchronous operating modes and how to use them. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html#differences-between-mplab-harmony-v3-synchronous-and-asynchronous-drivers",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html#differences-between-mplab-harmony-v3-synchronous-and-asynchronous-drivers"
  },"35": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html"
  },"36": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Web Links",
    "content": ". | The Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers and When to Use Them | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html#web-links",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html#web-links"
  },"37": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html#reference-links",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html#reference-links"
  },"38": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Differences Between Synchronous and Asynchronous Drivers",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html"
  },"39": {
    "doc": "MHC Clock Configuration",
    "title": "MHC Clock Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open Clock Configuration MHC plug-in, perform this action MHC → Tools then click Clock Configuration . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#mhc-clock-configuration",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#mhc-clock-configuration"
  },"40": {
    "doc": "MHC Clock Configuration",
    "title": "Clock Configuration",
    "content": "In the MHC, select the Clock Diagram Tab and verify that the clock is configured correctly for the selected target board. The Clock Diagram tab allows for easy setup of the master, system and peripheral clocks. See image below. Note: In the screenshot above, the MHC clock configuration for SAME70 MCU is shown as an example. The MHC clock configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#clock-configuration",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#clock-configuration"
  },"41": {
    "doc": "MHC Clock Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#note",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#note"
  },"42": {
    "doc": "MHC Clock Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#reference-links"
  },"43": {
    "doc": "MHC Clock Configuration",
    "title": "MHC Clock Configuration",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html"
  },"44": {
    "doc": "MHC Code Generation",
    "title": "MHC Code Generation",
    "content": "The following covers the basic MHC operations and code generation process, which helps users to setup and configure MHC according to their needs. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#mhc-code-generation",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#mhc-code-generation"
  },"45": {
    "doc": "MHC Code Generation",
    "title": "Selecting and Configuring Modules",
    "content": "After opening the MHC, the peripheral and library modules can be added to the project by following these steps: . | In the Available Components Area, select the peripheral or library module which needs to be configured by clicking on the module’s name. See 2. below image. | Configure the peripheral as required for the application in the Configuration Options Area. | Configure the pins in the Pin Manager depending on the application requirements. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#selecting-and-configuring-modules",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#selecting-and-configuring-modules"
  },"46": {
    "doc": "MHC Code Generation",
    "title": "Code Generation",
    "content": "To perform the following actions, press MHC Generate button in the Project Resources window. Saving and Loading the MHC Configuration . Saving and loading the MHC configuration is integrated into the MPLAB® X IDE Save and Load functions. The MHC configuration is saved whenever the Generate button is pressed. You can also save the MHC configuration by clicking on the MPLAB® X IDE Save tool or selecting Save from the File menu. The MHC configuration file is included in the MPLAB® X IDE project, under the Important Files folder. The configuration file uses the extension .xml. Double-clicking on the MHC configuration file will cause that MHC configuration to be loaded. Merge Window . If any of the files generated by the MHC has been edited outside of MHC and saved to the disk, then the Merge [MHC] window will appear in the Configuration Options. The Merge [MHC] window allows you to decide whether to keep the edits, or to replace them with the MHC newly generated code. When the newly generated MHC content has been accepted, MHC makes the changes to the file. To the MPLAB® X IDE, these changes are the same as if you typed in the new content. The normal MPLAB® X IDE edit undo can be used in the MHC Merge operation. A list of all the files that need to be merged appear one after another after resolving the merge conflicts. You must resolve merge conflicts to ensure that all the newly generated code is incorporated into the project. At the top of the Merge [MHC] window, in the center margin, there is an arrow, as shown in Figure 5-5. Clicking on the arrow will replace all your edits in the current file with the MHC updated code that the MHC has just generated. The numbers above the arrow indicate the current difference and the total number of differences. The individual lines of MHC Updated Code can be selected to replace the edited code. As shown in Figure 5-5, clicking on the arrows in the right margin of the left window will copy the MHC Updated Code to the generated driver file. Once the changes are accepted, the Merge mechanism will remove the highlighted file and highlight the next file on the list. To insure all updates are completed, a warning will be generated if the Merge mechanism is closed before all the changes are accepted. Note: Your edits will never be overwritten by the MHC generated code, except by explicit action in the Merge [MHC] window. When changes have been made both to a generated file and in the corresponding MHC UI within the Configuration Options, the Merge [MHC] window shown in Figure 5-5 will be displayed. The Merge [MHC] window allows you to resolve the conflicts between the newly generated file and the edits you have made to the file. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#code-generation",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#code-generation"
  },"47": {
    "doc": "MHC Code Generation",
    "title": "Generated Source and Header Files",
    "content": "The generated code will be included in the active MPLAB® X IDE Project as shown in the below image. The header files are shown on the top and source files are shown on the bottom. Note: In the image below, the icons are used to organize the project virtual organization of files, not an actual one. The following table provides the Header and Source files generated from the sample project: . | # | Source File | Descriptions | . | 1 | bsp.h | Provides Board Support Package | . | 2 | definitions.h | Provides all library headers and definitions needed for the application | . | 3 | Peripheral (libs) | Supports peripherals used by the project | . | 4 | exceptions.c | Implements all exception handlers | . | 5 | initialization.c | Initializes all libraries and applications | . | 6 | interrupts.c | Provides the interrupt vector table | . | 7 | libc_syscalls.c | Provides the Harmony specific system calls | . | 8 | startup.c | Startup code for the application | . | 9 | main.c | Applications Main source file | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#generated-source-and-header-files",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#generated-source-and-header-files"
  },"48": {
    "doc": "MHC Code Generation",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#note",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#note"
  },"49": {
    "doc": "MHC Code Generation",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#reference-links"
  },"50": {
    "doc": "MHC Code Generation",
    "title": "MHC Code Generation",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html",
    "relUrl": "/source/basic/mhc_code_generation/readme.html"
  },"51": {
    "doc": "MHC DMA Configuration",
    "title": "MHC DMA Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open DMA Configuration MHC plug-in, perform this action MHC → Tools then click DMA Configuration . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#mhc-dma-configuration",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#mhc-dma-configuration"
  },"52": {
    "doc": "MHC DMA Configuration",
    "title": "DMA Configuration",
    "content": "Users can add a channel and perform the channel settings, such as setting up source and destination address mode, interface identifier, data width, chunk size, and memory burst size. See image below. Note: In the screenshot above, the MHC DMA configuration for SAME70 MCU is shown as an example. The MHC DMA configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#dma-configuration",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#dma-configuration"
  },"53": {
    "doc": "MHC DMA Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#note",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#note"
  },"54": {
    "doc": "MHC DMA Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#reference-links"
  },"55": {
    "doc": "MHC DMA Configuration",
    "title": "MHC DMA Configuration",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html"
  },"56": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "MHC Memory protection Unit (MPU) Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open MPU Configuration MHC plug-in, perform this action MHC → Tools then click MPU Configuration . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#mhc-memory-protection-unit-mpu-configuration",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#mhc-memory-protection-unit-mpu-configuration"
  },"57": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "MPU Configuration",
    "content": "Users can configure MPU regions for memory spaces, such as ITCM, DTCM, Flash, SRAM, Peripherals, EBI, QSPI, USBHS and System. Users can also set the different attributes for these memory spaces. See image below: . Note: In the screenshot above, the MHC MPU configuration for SAME70 MCU is shown as an example. The MHC MPU configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#mpu-configuration",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#mpu-configuration"
  },"58": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#note",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#note"
  },"59": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#reference-links"
  },"60": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "MHC Memory Protection Unit Configuration",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html"
  },"61": {
    "doc": "MHC NVIC Configuration",
    "title": "MHC NVIC Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open NVIC Configuration MHC plug-in, perform this action MHC → Tools then click NVIC Configuration . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#mhc-nvic-configuration",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#mhc-nvic-configuration"
  },"62": {
    "doc": "MHC NVIC Configuration",
    "title": "NVIC Configuration",
    "content": "NVIC Manager allows users to enable or disable interrupts, change priority, and change names of interrupt handlers, see image below. Note: In the screenshot above, the MHC NVIC configuration for SAME70 MCU is shown as an example. The MHC NVIC configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#nvic-configuration",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#nvic-configuration"
  },"63": {
    "doc": "MHC NVIC Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#note",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#note"
  },"64": {
    "doc": "MHC NVIC Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#reference-links"
  },"65": {
    "doc": "MHC NVIC Configuration",
    "title": "MHC NVIC Configuration",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html"
  },"66": {
    "doc": "MHC Pin Configuration",
    "title": "MHC Pin Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open Pin Configuration MHC plug-in, perform this action MHC → Tools then click Pin Configuration . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#mhc-pin-configuration",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#mhc-pin-configuration"
  },"67": {
    "doc": "MHC Pin Configuration",
    "title": "Pin Configuration",
    "content": "The Pin Manager consists of Pin Settings, the Pin Diagram, and the Pin Table tabs, which enables users to configure (assign peripheral function, set pin direction, configure pull-up or pull-down and so on) and map the I/O pins. The following color combinations are associated with the pins in the graphical or table View: . | Gray: This pin is not usable in the selected configuration, and there is no enabled module which has any functionality on that pin. The grayed-out locks on a white background indicates the pins that are locked out by selected system functions. | Blue: This pin is available and can be allocated to a module. | Green (with a lock): This pin is allocated and selected for a module. The name displayed against the pin is either the name of the pin in the module’s context or a custom name entered. | . Pin Diagram . It is the pictorial representation of the available, assigned and not available pins of the Microcontroller. See image below. Pin Table . The pin table provides the Pin Manager Grid View. Using Pin Table users can perform these actions: . | The device package can be selected from the drop-down list. | The package can be selected from the upper left side of the Pin Manager Table View. The Package drop-down list shows the LQFP144 package is selected and the selected package details are displayed in the Package View. The pin numbers in the Table View provides the pin numbers for the selected package. The three leftmost columns in the Table View indicate the module’s name, functionality name, and the direction. | . Pin Settings . Pin settings enables the user to configure the pins. Users can provide custom name for pin, change the pin function, direction, latch and other properties, see image below. Note: In the screenshots above, the MHC pin configuration for SAME70 MCU is shown as an example. The MHC pin configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#pin-configuration",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#pin-configuration"
  },"68": {
    "doc": "MHC Pin Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#note",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#note"
  },"69": {
    "doc": "MHC Pin Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#reference-links"
  },"70": {
    "doc": "MHC Pin Configuration",
    "title": "MHC Pin Configuration",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html"
  },"71": {
    "doc": "MHC Project Graph",
    "title": "MHC Project Graph",
    "content": "The Project Graph displays all the instantiated component blocks. In Figure below BSP, USART and STDIO modules from Peripherals (CSP), I2C module from Harmony Core Driver, and FreeRTOS from Third-Party Software components are activated. MHC uses concept of Capability and Dependency for easy instantiation of modules. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#mhc-project-graph",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#mhc-project-graph"
  },"72": {
    "doc": "MHC Project Graph",
    "title": "Generic Capability and Dependency",
    "content": "A generic capability has a common name that identifies an interface that can be provided by a component but does not have an implementation of its own. One or more other components must implement the capability as shown in the following figure. | Point 1: Indicates the concept of Generic capabilities and dependency, i.e. FreeRTOS has exposed a generic capability on “RTOS” on which Harmony Core Service has created a generic dependency, up on satisfying these generic dependencies the color will turn to Green. Non-required dependencies are indicated as Yellow and indicate optional functionality that will not inhibit the operation of the component if absent. Required dependencies will display as Red, indicating that an error will likely occur during generation, compilation, or at runtime if the dependency is not satisfied. Similarly, Harmony Core Service has exposed a generic capability “Core Service” on which I2C driver has created a generic dependency. Generic dependencies connect automatically to generic capabilities and no connector line is required to bind the two. | Point 2: Indicates how I2C dependency is satisfied by binding with the capability TWIHS0. The left side block is a capability i.e. TWIHS0 and the right-side block is a dependency i.e. “Instance 0” I2C. | Point 3: Indicates how a new component can be generated at run-time by clicking button creates a new generator database component. A generator database component can create unique instances of itself as needed. This is for things like components like bit-bang drivers that are defined in software, and thus can be added several times to a project if desired. Similarly, by clicking button deletes a component instantly. | Point 4: Indicates the available capability of I2C driver. As mention above a non-required dependency is indicated as Yellow and indicates optional functionality that will not inhibit the operation of the component if absent. | Point 5: Options to create, disband, add selected, view selected and configure group or container respectively. This is explained in detail in Section 5.3.2 Project Group Creation. The following figure illustrates the unsatisfied direct dependency for I2C driver. User can see the list of satisfiers for a direct dependency by right-clicking on Red color diamond button. | . Click button to adjust the “Canvas Size” and button for “Toggle Minimap”. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#generic-capability-and-dependency",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#generic-capability-and-dependency"
  },"73": {
    "doc": "MHC Project Graph",
    "title": "Multi-Dependency and Multi-Capability",
    "content": "A component can have more than one dependency and capability respectively. The following figure illustrates the multi dependency and multi-capability feature of Harmony and shown with square block unlike a diamond block in single dependency. For example, in the below figure File System component is dependent on SD Card (SPI), SDHC and MEMORY components respectively whereas each of these exposes a DRV_MEDIA capability. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#multi-dependency-and-multi-capability",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#multi-dependency-and-multi-capability"
  },"74": {
    "doc": "MHC Project Graph",
    "title": "Container or Group Creation",
    "content": "The following are different group options. The Root is the default group. See the figure 5.9 below. | Create Group or click : Creates a group. If user selects any component and clicks , then a pop-up is shown asking to automatically add selected components to the new group. | Disband Group or click : Deletes a selected group. User can delete one group at a time. If user selects any component and clicks , then a pop-up is shown asking to delete selected group. | Add selected to Group/Container or click : Adds selected component in to a target container. On clicking a pop-up with drop down menu option is shown asking user to select the target container. | View selected Group/Container or click : Select a group and click or double click a group to view the components grouped together in a container. | Configure Group Node or click : Select a group then click to display the connections of the components if any. On clicking a pop-up window is displayed showing the tabular list of available nodes, select the nodes to display in the group. | Select Next Highest Group or click : Selects the next highest group available. Root is the default group. Select a group and click or double click a group to view the components grouped together in a container then to select next highest group click or to select a group under a drop down Multiple components added to group or container. This helps in simplifying the Project Graph view. The following figure illustrates the grouping of SPI Driver and SPI PLIB components. Similarly, user can create any number of group or container based on the requirement. Say for example separate container for TCP/IP and USB and so on. or based on the application need. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#container-or-group-creation",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#container-or-group-creation"
  },"75": {
    "doc": "MHC Project Graph",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#note",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#note"
  },"76": {
    "doc": "MHC Project Graph",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#reference-links"
  },"77": {
    "doc": "MHC Project Graph",
    "title": "MHC Project Graph",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html",
    "relUrl": "/source/basic/mhc_project_graph/readme.html"
  },"78": {
    "doc": "MHC Window manager and log level",
    "title": "Configuring MHC Plugin to select Window manager and log level",
    "content": "Select MHC Plugin configuration using Tools &gt; Options &gt; Plugins &gt; MPLAB® Harmony Configurator 3 . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#configuring-mhc-plugin-to-select-window-manager-and-log-level",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#configuring-mhc-plugin-to-select-window-manager-and-log-level"
  },"79": {
    "doc": "MHC Window manager and log level",
    "title": "Window manager selection",
    "content": "The MHC plug-in will open either in a new window (standalone mode) or inside MPLAB® X window (native mode). Select window manager mode . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#window-manager-selection",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#window-manager-selection"
  },"80": {
    "doc": "MHC Window manager and log level",
    "title": "Log Level selection",
    "content": "There are three levels of logging available (ALL, DEBUG, USER). MHC displays the logs in the console window (seen at the bottom of the main window). It also saves them in the mhc.log file under .mh3 folder in user’s home directory. This log level decides the kind of messages that will get logged. Select the log level . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#log-level-selection",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#log-level-selection"
  },"81": {
    "doc": "MHC Window manager and log level",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#note",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#note"
  },"82": {
    "doc": "MHC Window manager and log level",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#reference-links"
  },"83": {
    "doc": "MHC Window manager and log level",
    "title": "MHC Window manager and log level",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html"
  },"84": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "MPLAB Harmony 3 Configurator (MHC)",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#mplab-harmony-3-configurator-mhc",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#mplab-harmony-3-configurator-mhc"
  },"85": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Introduction",
    "content": "MPLAB Harmony 3 is a vital part of the MPLAB development tools ecosystem for working with Microchip 32-bit SAM® and PIC® micro controllers. It consists of a Graphical User Interface (GUI) called the MPLAB® Harmony Configurator (MHC) and an extensive set of interoperable firmware libraries that accelerate the process of developing embedded applications. The fundamental MHC GUI tools are the content manager and configurator tools. The content manager tool simplifies the process of downloading the firmware libraries, demonstration applications, and extensions to the MHC GUI. The configurator tool provides a convenient GUI for selecting libraries, initialization parameters, and optional features. It also makes it easy to connect everything together and generate C language code in a working configuration for your project. This section describes the following MHC specific topics to get started using MPLAB® Harmony to develop embedded applications designed with Microchip 32-bit micro controllers. | Installation . | Prerequisites for MHC use as an MPLAB® X IDE Plugin | Installing MPLAB® Harmony Configurator from the Microchip Plugins Update Center | Updating the MPLAB® Harmony Configurator | . | Using the MHC with the MPLAB® X IDE . | To Create a New Project | To Choose an Existing Project | Selecting MPLAB® Harmony 3 Packages | Content Manager | Project Settings | Configuration Settings | Launching MHC | . | Operating Areas . | Active Components, Project Graph and Configuration Options | Remove component | Available Components | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#introduction",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#introduction"
  },"86": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"87": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Installation",
    "content": "The MHC is available as a plugin extension to the MPLAB X IDE and as a standalone Java application for use with other tool suites (see here for details). Regardless which form you choose, there are some prerequisites that you must have installed first. Additionally, you will need to have a supported 32-bit MCU board on which to program, run, and debug your application. Prerequisites for MHC use as an MPLAB® X IDE Plugin . | Install the Microchip MPLAB X IDE. | Refer Installing MPLAB X IDE guide | . | Install the MPLAB XC32/32++ C Compiler compiler for support of all Microchip 32-bit MCUs. | Refer Installing MPLAB XC32 Compiler guide . Installing MPLAB® Harmony Configurator from the Microchip Plugins Update Center . | . | . The MHC is not automatically installed with MPLAB® X IDE. You will need to take additional steps to download and install it through Microchip Plugins Update Center: . Steps . | Open the MPLAB® X IDE. | In the top-level menu, select to Tools &gt; Plugins. | In the Plugins window, select the Available Plugins tab. | Select MPLAB® Harmony Configurator 3 from the list of available plugins and click the Install button. The Plugin Installer opens. | Click Next and review the License Agreement. | Click Install when you are ready for the Plugin Installer to begin downloading the MHC plugin. When the MHC plugin download is complete, MPLAB® X IDE will ask to be restarted. | Select Restart Now and click Finish. Upon restart, the plugin is installed. You can now open MHC on a new or already existing MPLAB® X IDE project. | . Updating the MPLAB® Harmony Configurator . Whenever a new version of MHC plugin is available, the MPLAB® X IDE will display a notification on the IDE window. Clicking on it will launch the plugin update wizard. In the wizard, click on the Install button to download and install the latest MHC plugin version. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#installation",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#installation"
  },"88": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"89": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Using the MHC with the MPLAB® X IDE",
    "content": "To generate code using the MHC in MPLAB® X IDE, you must first choose to create a new project or use an existing one. Then, you must follow these steps. To Create a New Project . To create MPLAB® X IDE project, follow these steps: . | Select File &gt; New Project or click New Project button to create a new project. The New Project wizard will open. | In the Choose Project pane, select the Microchip Embedded category. | In the Projects pane, select 32-bit MPLAB® Harmony 3 Project, then click Next. | Continue by following the Selecting MPLAB® Harmony 3 Packages steps, below. Note: If the 32-Bit MPLAB® Harmony 3 Project type is not listed under the Microchip Embedded category, please download and install MPLAB® Harmony 3 Configurator before continuing with these steps. | . To Choose an Existing Project . To choose an existing project, follow these steps: . | Click he Open Project window will be displayed. | Navigate to the desired project’s .X folder and click Open Project. The selected project will open in the IDE. Note: If multiple projects are open in MPLAB® X IDE, set one as the main (active) project by Right-clicking on it and selecting “Set as Main Project”. | . Selecting MPLAB® Harmony 3 Packages . The Content Manager tool simplifies downloading of MPLAB® Harmony 3 packages. Packages contain source code, templates, documentation, MHC extensions, and other collateral for MPLAB® Harmony modules. Each package is maintained in a GIT repository that can be downloaded (or cloned) to your development system in a framework folder of your choice. The Content Manager tool can be launched using one of the following methods: . | Method 1: While creating a new project from the New Project window, click the Launch Content Manager button. | Method 2: From the Tools &gt; Embedded &gt; MPLAB® Harmony 3 Content Manager menu option. | . Content Manager . Content Manager GUI helps in managing packages. It displays locally downloaded packages and remote packages available for download in a easy to use graphical interface. User can checkout remote packages or update locally downloaded packages once remote version is updated. It helps in managing package dependencies. Please click on below link for detailed information . GitHub → MPLAB Harmony 3 Content Manager Gitee → MPLAB Harmony 3 Content Manager . Project Settings . In the New Project window, perform these settings: . | Ensure that the Framework Path is correct. It it is not, navigate to the folder to which you previously downloaded the MPLAB® Harmony 3 packages. Note: You can leave Convert to Relative Path for Configuration selected. | Click Next to select the project Name and Location. | To choose the project location, navigate to the folder in which you wish to keep your MPLAB® Harmony 3 projects and create a top-level folder for this project. Note: Be sure to create a new top-level folder for this project as it will contain both the MPLAB® X IDE’s project folder (the “.X” folder) and the firmware folder into which the MHC will generate the selected source code. | In the Folder edit box, provide the name that will be used for the MPLAB® X IDE’s “.X” folder. Note: This must be a valid directory name for your operating system. | In the Name edit box, enter the project’s “Virtual” name. This is the name that will be shown from within the MPLAB® X IDE. Note: The Path box is not editable. It will update as you make changes to the other entries. | Click Next to proceed to configuration settings. | . Configuration Settings . Follow these steps to select the project’s configuration settings. | In the right pane, under Configuration Settings enter details for the configuration Name and choose the Target Device. Note: You can select the Device Family or enter a partial device name to filter the list if Target Devices in order to make it easier to locate the desired device. | After selecting the target device, Click Finish to launch the MHC. Note: The New Project Wizard will first open a Configuration Database Setup dialog window to allow you to review the packages that will be used by the current project. Click Launch to continue to the MHC Configurator tool. | . Launching MHC . Follow these steps to launch the MHC. | Open the MHC plugin tool. If the project has already been created, launch the MPLAB® Harmony 3 Configurator by selecting Tools → Embedded → MPLAB® Harmony 3 Configurator from the MPLAB® X IDE’s menu bar. The MPLAB® Harmony Launcher window will be displayed. | If necessary, reconfigure the MPLAB® X Harmony project and framework paths by clicking the Reconfigure Paths button. Otherwise, accept the default settings and then click Launch. The Configuration Database Setup window will be displayed, which shows the selected and configured Harmony packages. | Click Launch to open MHC plug-in. The MHC plugin’s main window for the project will be displayed. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#using-the-mhc-with-the-mplab-x-ide",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#using-the-mhc-with-the-mplab-x-ide"
  },"90": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"91": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Operating Areas:",
    "content": "The MHC Graphical User Interface consists of following six major operating areas. | Active Components: Displays activated/instantiated components. | Available Components: Displays the available components based on the project configuration. Displays Board Support Packages (BSPs), list of available Peripheral Libraries (PLIBs), Harmony Core which consists of Drivers and System Services, Middleware Software, Third-Party Software and Tools. | Project Graph: Shows the instantiated components. User can instantiate available components by double click on component. After successful component instantiation, you can see the instantiated components under Active Components panel. | MHC Plugins: Consists of AFEC, DMA, MPU, NVIC, Clock and Pin configuration plugins. To open any of these plugins go to MHC → Tools → select above mentioned available plugins. | Configuration Options: Displays the tree view of the selected component under Project Graph Area. User can do the component configuration from here. | Console: Displays the MHC operation results The following figure displays the MHC graphical user interface showing six operating areas. Note: The components shown under components are based on the Microcontroller selected while creating the project. All operating areas are dockable. Each can be dragged and dropped into another position, even out of the MPLAB® X IDE main window. However, closing the IDE however will close all MHC windows, including the ones moved outside the IDE. | . Active Components, Project Graph and Configuration Options . Active Component and Project Graph displays all the instantiated components. By default, the below essential components from the Chip Specific Package (CSP) repo will get auto instantiated. | System: The CSP System component is used for the device and project specific configurations. | CMSIS Pack: The Cortex Microcontroller Software Interface Standard (CMSIS) Pack is a vendor-independent hardware abstraction layer for the Cortex®-M processor series and defines generic tool interfaces. This pack is needed for 32-bit SAM MCU devices. | Device Family Pack (DFP): This is the Microchip Device Family Pack retrieves the device specific information and instantiates the same. | . The following figure displays Active Components and Project Graph Area. Along with above mentioned default components, it consists of other active components like BSP, Harmony Core, I2C Driver, TWIHS, USART, SDTIO and FreeRTOS which are activated/instantiated by user. The following figure displays the project configuration of selected active “System” component. User can modify/configure activated component by selecting a component under Active component or under Project Graph. This way user can do the configuration of selected component. Remove component . To remove a component available in Active component area, follow these steps: . | Select it (for example, FreeRTOS) in Active Component Area or in Project Graph Area then click on button . | A pop-up window will display asking whether to deactivate a component. The following figure deactivating the FreeRTOS component. | Click Yes to deactivate the FreeRTOS component. Note: As the “System” component is the main component in CSP, except “System” all other components can be deactivated. | . Available Components . This section displays the available components of the project. Available component list varies based on the Harmony Core repo synchronization and the Microcontroller selected while creating the project. To instantiate a component, from the available components, double click on any available component. After the component is instantiated, the instantiated component will be displayed in the Project Graph Area. The following sections cover available components and description, and for GUI see figure below. | Board Support Packages (BSPs): Includes default or board specific BSP. | Harmony Core: Includes Harmony Core Services i.e., Drivers and System Services. | Peripheral: Includes available peripherals like USART, TWIHS, TC and so on. | Third-Party Libraries: Lists the supported Third-Party software’s. Currently supported Real Time Operating System is “FreeRTOS”. | Tools: This lists the supported tools like Standard Input/Output (STDIO) which uses USART peripheral. | . Similarly, if users sync USB or TCP/IP repositories then the respective Middleware Software section shall be displayed under the available components section. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#operating-areas",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#operating-areas"
  },"92": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#note",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#note"
  },"93": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#reference-links",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#reference-links"
  },"94": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "MPLAB Harmony 3 Configurator (MHC)",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"95": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Open an Existing Harmony 3 Project",
    "content": "This page shows you how to open one of the many demonstration application projects that are included in the MPLAB® Harmony framework. Before doing this, you’ll need to do the following: . | Install MPLAB X IDE | Install MPLAB XC32 Compiler | Install the MPLAB Harmony Configurator (MHC) | Download the MPLAB Harmony Framework | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#open-an-existing-harmony-3-project",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#open-an-existing-harmony-3-project"
  },"96": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Steps",
    "content": ". | In the MPLAB X IDE, select File &gt; Open Project. | Demonstration applications come with most of the libraries. These can be found in each library’s apps folder. Browse to the firmware folder (as shown below) to find all evaluation boards that support the application. Select your evaluation board and click Open Project. | After the project opens, start MHC. In the MPLAB X IDE, select Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator. | Select the path to the folder containing the MPLAB Harmony framework and click Launch. | The Configuration Database Setup window opens. You shouldn’t have to change anything in this window. Click Launch. Please be patient while waiting for the last window to open. It will ask if you want to open the default saved state file. This file is used to save all selections made in MHC for the project you are opening. Click Open. You can now use the MPLAB Harmony Configurator. Please see the MHC Wiki for instructions on how to use it. | . Note: You can save or load an MHC configuration at any time. The default name of the MHC state file is: . &lt;MPLAB X project configuration name&gt;.xml . It can be found in the following folder: . …\\&lt;project name&gt;\\firmware\\src\\config\\&lt;project configuration name&gt;\\. If you are not using MPLAB X Project Configurations, the MHC state file can be found in the following folder: . …\\&lt;project name&gt;\\firmware\\src\\config\\default\\default.xml . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#steps",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#steps"
  },"97": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#note",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#note"
  },"98": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#reference-links",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#reference-links"
  },"99": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Open an Existing Harmony 3 Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html"
  },"100": {
    "doc": "Getting Started with MPLAB Harmony v3 on the SAMA5D2",
    "title": "Getting started with MPLAB® Harmony 3 on the SAMA5D2",
    "content": "The SAMA5D2’s ROM boot loader looks for a second stage boot loader in external NVM, relocates it to internal SRAM, and executes it. Harmony uses the AT91Bootstrap as its second stage boot loader. The AT91Bootstrap initializes clocks, PIO, and DDR prior to relocating the application image from NVM to DDR and starting it. As of the 3.2 release of Harmony only loading the AT91bootstrap and Harmony application from an external SD card has been tested. To boot your Harmony application for the SD card, first format the card with the FAT file system. Next, download the AT91Bootstrap binary from here and place the boot.bin on the SD card. The next step is to download the Harmony 3 framework. This process can be automated using the MPLAB® Harmony Framework Management Tool. First clone the MHC repository found here and launch the harmony-content-manager.jar . java -jar harmony-content-manager.jar. The downloader will clone the Harmony 3 repositories that you select. NOTE: From here on when the document references launching MHC it refers to the mhc.jar file downloaded by the content manager with the mhc repository, along with the rest of the Harmony Framework. Launching an Existing Project . Demo applications can be found in the apps directory in each Harmony repository downloaded. To load the demo application in MHC run: . java -jar mhc.jar -fw\"=(path to where you downloaded harmony)\" -mode=gui -c=\"(path to harmony.prj file associated with the demo application you'd like to run. e.g../csp/apps/uart/uart_echo_interrupt/firmware/src/config/sam_a5d2_xult/harmony.prj)\" . NOTE: MHC must be launched from inside the mhc directory. You can’t be in another directory and give a path to mhc.jar, you must be inside the same directory as the mhc.jar file or MHC won’t run correctly. Make sure the firmware path (-fw=) contains a trailing directory separator (/ on Linux, \\ on Windows) . This will launch the existing project in MHC. For documentation on the demo applications shipped with Harmony refer to the github.io pages for the repository containing the app you’d like to run (e.g. csp) . Once the project is loaded the code can be regenerated by selecting . Generate-&gt;Generate Code . from the menu. The IAR project has already been created for any demo applications and can be opened by opening (demo application’s firmware directory)/sam_a5d2_xult.IAR/(project name).eww. Once IAR is launched simply build the application and load the harmony.bin image as described below. Creating a New Project . Once you’ve cloned the Harmony 3 framework launch MHC by running: . java -jar mhc.jar -fw=\"(path to where you downloaded harmony)\" -mode=gui. With the MHC running create a new Harmony project under . File-&gt;New Configuration. NOTES: . | As of the 3.2 release using relative paths in MHC causes issues when generating code. Please uncheck the box marked “Convert to Relative Path for Configuration” | The diff tool should be configured immediately after tool install, before code generation is attempted, otherwise User changes may be lost. | Select File &gt; Preferences from the menu. | Enter the pathname to the executable file for your preferred “diff” tool and click Close. (Pass command line arguments as {0} {1} and so on.) | . | . Add the desired plibs, drivers, and system services your application requires and configure them accordingly, then generate the code. To compile your project launch IAR Embedded Workbench for ARM. (Harmony has been tested with version 8.30.1 of IAR EW.) Make sure you have IAR configured to use project connections by going to . Tools-&gt;Options-&gt;Project-&gt;Enable project connections. Create a new empty project in a new direcotry under the firmware directory created by MHC (e.g. HarmonyProjects/myApp/firmware/sam_a5d2_xult.IAR/myApp_sam_a5d2_xult.ewp). Under the Project menu bar select . Add Project Connection . Browse to the ipcf file MHC generated. Since the AT91Bootstrap is looking to load a raw binary, we need to have IAR convert the ELF it builds into a raw binary. Right click on the project name and select options. Under Output Converter select the . Generate additional output . box, select Raw binary as the Output format, select the . Override default . box and type . harmony.bin . in the text field. Now build your application. Once the application is built copy the harmony.bin file that was generated to the SD card. Insert the SD card into the board, apply power, and your Harmony application should boot and run. Debugging your application: . IAR supports source-level debugging of your application. First connect the SAM-ICE JTAG debugger to the JTAG header on the development board. Go to . Options-&gt;Debugger . and select . J-Link/J-Trace . as the Driver. If the application has booted from the SD card, simply load your project in IAR and select . Project-&gt;Attach to Running Target . This will allow you to halt the running program, set breakpoints, view and change memory and registers, etc. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_harmony_3/readme.html#getting-started-with-mplab-harmony-3-on-the-sama5d2",
    "relUrl": "/source/basic/sam_mpus_getting_started_harmony_3/readme.html#getting-started-with-mplab-harmony-3-on-the-sama5d2"
  },"101": {
    "doc": "Getting Started with MPLAB Harmony v3 on the SAMA5D2",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_harmony_3/readme.html#note",
    "relUrl": "/source/basic/sam_mpus_getting_started_harmony_3/readme.html#note"
  },"102": {
    "doc": "Getting Started with MPLAB Harmony v3 on the SAMA5D2",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_harmony_3/readme.html#reference-links",
    "relUrl": "/source/basic/sam_mpus_getting_started_harmony_3/readme.html#reference-links"
  },"103": {
    "doc": "Getting Started with MPLAB Harmony v3 on the SAMA5D2",
    "title": "Getting Started with MPLAB Harmony v3 on the SAMA5D2",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_harmony_3/readme.html",
    "relUrl": "/source/basic/sam_mpus_getting_started_harmony_3/readme.html"
  },"104": {
    "doc": "Getting started with SAM MPU Devices on MPLAB X Tools",
    "title": "Getting started with MPLAB® Harmony 3 on Microchip SAM MPU’s",
    "content": "The SAM MPU’s, like the SAMA5D2 and SAM9X60, have a ROM based boot loader that looks for a second stage boot loader in external NVM, relocates it to internal SRAM, and executes it. Harmony uses the AT91Bootstrap as its second stage boot loader. The AT91Bootstrap initializes clocks, PIO, and DDR prior to relocating the application image from NVM to DDR and starting it. To make development easier, rather than loading the AT91Bootstrap and Harmony images into NVM, we can use MPLAB X to load both the bootloader and application via the debug interface (e.g. JTAG/JLINK). The github page for the bootloader has instructions on how to configure and build on both Windows and Linux platforms. For now, we’ll just focus on only the configuration changes needed to build an image for use with MPLAB X. Some of our existing boards already have a defconfig for use with MPLAB X. Look for a defconfig with the name bkptnone in it, e.g, sama5d2_xplained_bkptnone_defconfig. You can then simply run: . make sama5d2_xplained_bkptnone_defconfig . If your board doesn’t already have a defconfig, not to worry, we can easily create one. To start, pick the defconfig for your board that runs out of some NVM, like an SD card, e.g. sama5d2_xplainedsd_uboot_defconfig. Run: . make sama5d2_xplainedsd_uboot_defconfig make menuconfig . Select “Image Loading Strategy” Select “Do not load any image after bootstrap run” . Select “Build image for use with debuggers” . Save the configuration and exit kconfig. Compile the bootloader. You’ll need the boot.bin file created as part of the build process. Prebuilt binaries are also available in this repository. | SAMA5D2 . | SAMA5D2 XULT HARMONY | SAMA5D2 XULT MPLAB | . | SAM9X60 . | SAM9X60 EK HARMONY | SAM9X60 EK MPLAB | . | . Next we need to tell MPLAB X how to use the boot.bin image we just created or downloaded. We do this by creating a python script named autoload.py in the root folder of the MPLAB X project. For example, if we want to run the pit led_toggle_interrupt project we would create the autoload.py file in .../csp/apps/pit/led_toggle_interrupt/firmware/sam_a5d2_xult_xc32.X . The contents of a typical autoload.py are shown below. global g_mpu_config g_mpu_config = {'type':'application', 'entry_addr':0x26f00000, 'bootstrap_entry_addr':0x200000, 'bootstrap_bin_path':'./boot.bin'} def on_pre_program(): pass . Note that for the SAM9X60 the entry_addr is 0x23f00000 and the bootstrap_entry_addr is 0x300000. Now copy the boot.bin file from the AT91Bootstrap build done previously to the same directory where the autoload.py script is. Now that the autoload.py and bootstrap are in place, we can use MPLAB X to download and debug our Harmony application. Start by loading the project in MPLAB X. Right click on the project name and select “Properties”. Select the correct HW debugging tool and Compiler. In this example the J-Link and XC-32 v2.41 are used. Simply hit the debug image button . The IDE will connect to the hardware, load the bootloader, wait for it to enter debug mode, then load the Harmony application into DDR and execute it. You can set breakpoints, examine variables, and debug the hardware as you normally would. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_mplabx/readme.html#getting-started-with-mplab-harmony-3-on-microchip-sam-mpus",
    "relUrl": "/source/basic/sam_mpus_getting_started_mplabx/readme.html#getting-started-with-mplab-harmony-3-on-microchip-sam-mpus"
  },"105": {
    "doc": "Getting started with SAM MPU Devices on MPLAB X Tools",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_mplabx/readme.html#note",
    "relUrl": "/source/basic/sam_mpus_getting_started_mplabx/readme.html#note"
  },"106": {
    "doc": "Getting started with SAM MPU Devices on MPLAB X Tools",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_mplabx/readme.html#reference-links",
    "relUrl": "/source/basic/sam_mpus_getting_started_mplabx/readme.html#reference-links"
  },"107": {
    "doc": "Getting started with SAM MPU Devices on MPLAB X Tools",
    "title": "Getting started with SAM MPU Devices on MPLAB X Tools",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam_mpus_getting_started_mplabx/readme.html",
    "relUrl": "/source/basic/sam_mpus_getting_started_mplabx/readme.html"
  },"108": {
    "doc": "Harmony Basics",
    "title": "MPLAB Harmony Basics Documentation",
    "content": "This page contains quick documentation for MPLAB® Harmony 3 Basics. | MPLAB Harmony 3 Configurator (MHC) . | MHC Project Graph . | MHC Clock Configuration . | MHC Pin Configuration . | MHC NVIC Configuration . | MHC DMA Configuration . | MHC Memory protection Unit Configuration . | MHC Code Generation . | MHC Window Manager and Log Level . | Create First MPLAB Harmony 3 Project . | Create “Hello World” application on SAM MCUs . | Create “Hello World” application on PIC MCUs . | Open an Existing Harmony 3 Project . | Harmony 3 Packages . | Create IAR or Keil project using MHC . | Create new TrustZone Project . | Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#mplab-harmony-basics-documentation",
    "relUrl": "/source/basic/readme.html#mplab-harmony-basics-documentation"
  },"109": {
    "doc": "Harmony Basics",
    "title": "Microprocessor units (MPUs)",
    "content": ". | Getting started with SAM MPU Devices on MPLAB X Tools . | Getting Started with MPLAB Harmony v3 on the SAMA5D2 . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#microprocessor-units-mpus",
    "relUrl": "/source/basic/readme.html#microprocessor-units-mpus"
  },"110": {
    "doc": "Harmony Basics",
    "title": "Web Links",
    "content": ". | VIDEO - How to Set-up the Tools Required to Get Started with MPLAB® Harmony v3 | VIDEO - Create Your First Project with SAMD21 using MPLAB Harmony v3 | VIDEO - Create Your First Project with SAMC21 using MPLAB Harmony v3 | How to Get Started with MPLAB Harmony v3 | Create a New MPLAB Harmony v3 Project | How to Set Up MPLAB Harmony v3 Software Development Framework | MPLAB Harmony Content Manager | . Note: . This page provides a quick reference covering the Basic features of MPLAB Harmony 3. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#web-links",
    "relUrl": "/source/basic/readme.html#web-links"
  },"111": {
    "doc": "Harmony Basics",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#reference-links",
    "relUrl": "/source/basic/readme.html#reference-links"
  },"112": {
    "doc": "Harmony Basics",
    "title": "Harmony Basics",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html",
    "relUrl": "/source/basic/readme.html"
  },"113": {
    "doc": "Create a Touch Project",
    "title": "Generate a Touch Project with MPLAB® Harmony",
    "content": "This guide shows you how to create a Touch project with the MPLAB® Harmony platform where you can graphically add sensors and configure QTouch® parameters. This project uses the SAMC21N Xplained Pro Evaluation Kit board along with the QT1 Mutual Capacitance Xplained Pro Extension Kit. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html#generate-a-touch-project-with-mplab-harmony",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html#generate-a-touch-project-with-mplab-harmony"
  },"114": {
    "doc": "Create a Touch Project",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html"
  },"115": {
    "doc": "Create a Touch Project",
    "title": "Web Links",
    "content": ". | Generate a Touch Project with MPLAB® Harmony | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html#web-links",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html#web-links"
  },"116": {
    "doc": "Create a Touch Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html#reference-links",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html#reference-links"
  },"117": {
    "doc": "Create a Touch Project",
    "title": "Create a Touch Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html"
  },"118": {
    "doc": "Create first Audio Application",
    "title": "Creating Your First Audio Application from Scratch",
    "content": "This tutorial provides information on how to create an audio project using MPLAB Harmony 3 and the SAM E70 Xplained Ultra board. It starts with a blank MPLAB® project and finishes with an audio application that is a subset of the audio_tone application. To keep the application as simple as possible, no graphics or other UI are included. It simply outputs a 1000 Hz sine wave over the I2S interface at 48,000 samples/sec. The sine tone is generated internally using math functions (no audio inputs). For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html#creating-your-first-audio-application-from-scratch",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html#creating-your-first-audio-application-from-scratch"
  },"119": {
    "doc": "Create first Audio Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html"
  },"120": {
    "doc": "Create first Audio Application",
    "title": "Web Links",
    "content": ". | Creating Your First Audio Application from Scratch | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html#web-links"
  },"121": {
    "doc": "Create first Audio Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html#reference-links"
  },"122": {
    "doc": "Create first Audio Application",
    "title": "Create first Audio Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html"
  },"123": {
    "doc": "Create first Audio Decoder Application",
    "title": "Creating Your First Audio Decoder Application from Scratch",
    "content": "This tutorial provides information on how to create an audio decoder project using MPLAB Harmony 3 and the SAM E70 Xplained Ultra board. It starts with a blank MPLAB® project and finishes with an audio decoder capable of playback of a WAV encoded file located on a USB flash drive, very similar to the audio_player_basic app in the audio . To keep the application as simple as possible, no graphics or other program controls are included. It simply reads the statically specified file from the USB flash drive, sets up the codec sample rate, and outputs the data from the WAV file over the I2S interface at the sample rate specified in the WAV file. The WAV file for this project will be created externally as dual channel, 16 bit data, at 16,000 Hz sample rate and will say “Hello World”. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html#creating-your-first-audio-decoder-application-from-scratch",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html#creating-your-first-audio-decoder-application-from-scratch"
  },"124": {
    "doc": "Create first Audio Decoder Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html"
  },"125": {
    "doc": "Create first Audio Decoder Application",
    "title": "Web Links",
    "content": ". | Creating Your First Audio Decoder Application from Scratch | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html#web-links"
  },"126": {
    "doc": "Create first Audio Decoder Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html#reference-links"
  },"127": {
    "doc": "Create first Audio Decoder Application",
    "title": "Create first Audio Decoder Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html"
  },"128": {
    "doc": "Create first Bluetooth Application",
    "title": "Creating Your First Bluetooth Application from Scratch",
    "content": "This page provides a user a quick start guide for building their first Bluetooth project in Harmony 3. This tutorial provides information on how to create a Bluetooth project using MPLAB Harmony 3. To keep the application as simple as possible, a very minimal UI is included (one button and one LED). It connects to a smartphone (iPhone or Android) using BLE (Bluetooth Low Energy), and sends a string of characters to the smartphone when a button is pressed. The following hardware setup is supported: . | SAM E70 Xplained Ultra board | BM64 Bluetooth Radio Daughter Board | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html#creating-your-first-bluetooth-application-from-scratch",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html#creating-your-first-bluetooth-application-from-scratch"
  },"129": {
    "doc": "Create first Bluetooth Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html"
  },"130": {
    "doc": "Create first Bluetooth Application",
    "title": "Web Links",
    "content": ". | Creating Your First Bluetooth Application from Scratch | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html#web-links"
  },"131": {
    "doc": "Create first Bluetooth Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html#reference-links"
  },"132": {
    "doc": "Create first Bluetooth Application",
    "title": "Create first Bluetooth Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html"
  },"133": {
    "doc": "Create first Motor Control Application",
    "title": "Create your first Motor Control Application",
    "content": "This page shows you how to use MHC to create a motor control application Brushless DC (BLDC) block commutation using a hall sensor on a SAM E54 microcontroller. This application reads the pattern from the hall sensor mounted on the motor shaft. Based on the hall pattern, the corresponding commutation is forced to the motor windings through three-phase inverters. The motor speed can be increased or decreased using the reference potentiometer in the MCLV-2 board. Two momentary switches are used, one for Start/Stop operation and the other for direction control (Forward/Reverse). The application will utilize: . | Position Decoder (PDEC) Peripheral Library (PLIB) to read the hall pattern from the hall sensor. | Timer/Counter for Control Applications (TCC0) PLIB to create three pairs of Pulse Width Modulation (PWM) frequency for three-phase inverters and to trigger the ADC0 periodically. | Analog-to-Digital Converter (ADC0) PLIB to read the output voltage of potentiometer to determine the speed. | Timer/Counter (TC0) PLIB used as an internal 1 mS timer counter. | Timer/Counter (TC1) PLIB used as a timer to measure the time elapsed between two consecutive hall edges. | Event System (EVSYS) PLIB used as a traffic controller between TCC0 (event generator) and ADC0 (event user). | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html#create-your-first-motor-control-application",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html#create-your-first-motor-control-application"
  },"134": {
    "doc": "Create first Motor Control Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html"
  },"135": {
    "doc": "Create first Motor Control Application",
    "title": "Web Links",
    "content": ". | Create your first Motor Control Application using MPLAB Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html#web-links"
  },"136": {
    "doc": "Create first Motor Control Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html#reference-links"
  },"137": {
    "doc": "Create first Motor Control Application",
    "title": "Create first Motor Control Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html"
  },"138": {
    "doc": "Create first TCPIP Application",
    "title": "Create your first TCP/IP Application",
    "content": "This tutorial is a getting-started guide to demonstrate how to create a MPLAB® Harmony 3 based TCP/IP application project. This tutorial implements a simple TCP/IP Client application on a microcontroller development board. This will guide you through the steps required to create a new TCP/IP application using MPLAB® Harmony 3 modules. Note : The getting-started guide demonstrates the creation of a TCP/IP demo on the SAM E70 Xplained Ultra board with the LAN8740 PHY Daughter board. These steps can be applied for other development boards applying the device/board specific configuration changes. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html#create-your-first-tcpip-application",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html#create-your-first-tcpip-application"
  },"139": {
    "doc": "Create first TCPIP Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html"
  },"140": {
    "doc": "Create first TCPIP Application",
    "title": "Web Links",
    "content": ". | Create your first TCP/IP Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html#web-links"
  },"141": {
    "doc": "Create first TCPIP Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html#reference-links"
  },"142": {
    "doc": "Create first TCPIP Application",
    "title": "Create first TCPIP Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html"
  },"143": {
    "doc": "Create first USB device application",
    "title": "Create your first USB Device Application",
    "content": "The purpose of this tutorial is to show you how to create an MPLAB® Harmony 3 project that enumerates as a USB CDC Device. The application demonstrates two-way communication between the USB Device and the USB Host PC. This tutorial focuses on using the interoperable MPLAB® Harmony USB Device stack and CDC Function driver in your application. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html#create-your-first-usb-device-application",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html#create-your-first-usb-device-application"
  },"144": {
    "doc": "Create first USB device application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html"
  },"145": {
    "doc": "Create first USB device application",
    "title": "Web Links",
    "content": ". | Create your first USB Device Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html#web-links"
  },"146": {
    "doc": "Create first USB device application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html#reference-links"
  },"147": {
    "doc": "Create first USB device application",
    "title": "Create first USB device application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html"
  },"148": {
    "doc": "Create first USB Host application",
    "title": "Create your first USB Host Application",
    "content": "The purpose of this tutorial is to show you how to create a MPLAB® Harmony 3 project that uses the MPLAB® Harmony File System to create a file on a USB Mass Storage Device (eg: USB Pen Drive). The application will provide a LED indication when the file create process has completed. This tutorial focuses on using the interoperable MPLAB® Harmony USB Host stack and Harmony File System service in your application. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html#create-your-first-usb-host-application",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html#create-your-first-usb-host-application"
  },"149": {
    "doc": "Create first USB Host application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html"
  },"150": {
    "doc": "Create first USB Host application",
    "title": "Web Links",
    "content": ". | Create your first USB Host Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html#web-links"
  },"151": {
    "doc": "Create first USB Host application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html#reference-links"
  },"152": {
    "doc": "Create first USB Host application",
    "title": "Create first USB Host application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html"
  },"153": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Create your first WIN1500 Bypass mode example using Harmony TCP/IP stack",
    "content": "This tutorial is a getting-started guide to demonstrate how to create a WINC1500 Bypass (Ethernet) mode example using MPLAB® Harmony v3 TCP/IP stack. This tutorial implements a simple STA Client application on a microcontroller development board. This will guide you through the steps required to create a new TCP/IP application using MPLAB® Harmony 3 modules. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html#create-your-first-win1500-bypass-mode-example-using-harmony-tcpip-stack",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html#create-your-first-win1500-bypass-mode-example-using-harmony-tcpip-stack"
  },"154": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html"
  },"155": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Web Links",
    "content": ". | Create your first WIN1500 Bypass mode example using Harmony TCP/IP stack | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html#web-links"
  },"156": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html#reference-links"
  },"157": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Create Your First WINC Bypass Mode Example",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html"
  },"158": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Configure Surface and Gesture Harmony v3 Touch Project",
    "content": "This article provides information on creating a Touch Surface and Gesture project in Microchip’s MPLAB® Harmony v3 platform as well as configuring surface and gesture parameters. This project uses the SAMC21N Xplained Pro Evaluation Kit board along with the QT1 Mutual Capacitance Xplained Pro Extension Kit . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html#configure-surface-and-gesture-harmony-v3-touch-project",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html#configure-surface-and-gesture-harmony-v3-touch-project"
  },"159": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html"
  },"160": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Web Links",
    "content": ". | Configure Surface and Gesture Harmony v3 Touch Project | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html#web-links",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html#web-links"
  },"161": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html#reference-links",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html#reference-links"
  },"162": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Create Touch Surface and Gesture Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html"
  },"163": {
    "doc": "Creating a new Graphics Application",
    "title": "Creating a New Graphics Application",
    "content": "This topic describes the basic steps to create a graphics-enabled application from scratch using SAM E70 Xplained Ultra board. It starts with a blank MPLAB® project and finishes with a graphics application equivalent to aria_quickstart. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html#creating-a-new-graphics-application",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html#creating-a-new-graphics-application"
  },"164": {
    "doc": "Creating a new Graphics Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html"
  },"165": {
    "doc": "Creating a new Graphics Application",
    "title": "Web Links",
    "content": ". | Creating a New Graphics Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html#web-links",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html#web-links"
  },"166": {
    "doc": "Creating a new Graphics Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html#reference-links",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html#reference-links"
  },"167": {
    "doc": "Creating a new Graphics Application",
    "title": "Creating a new Graphics Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html"
  },"168": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Graphics Quick Start Application Guides",
    "content": "A collection of application quickstart tutorials are provided with MPLAB Harmony Graphics Suite to help users understand and create applications quickly. These guides were created using Microchip supported development boards. Although these guides run on Microchip boards, customers are free to reference our solutions to enable their custom designs. Note: Complete applications are part of each MPLAB Harmony distribution. Visit the quickstart apps and feature apps for more information. QuickStart Applications Demonstrate . | Preferred Harmony Practices | Example Board Support Package (BSP) | Detailed Pin Configuration | Recommended Peripheral and external device communication | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html#graphics-quick-start-application-guides",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html#graphics-quick-start-application-guides"
  },"169": {
    "doc": "Graphics Quick Start Application Guides",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html"
  },"170": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Web Links",
    "content": ". | Graphics Quick Start Application Guides | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html#web-links",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html#web-links"
  },"171": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html#reference-links",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html#reference-links"
  },"172": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Graphics Quick Start Application Guides",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html"
  },"173": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "MPLAB Harmony 3 Audio Overview",
    "content": "This page provides a brief overview of audio and Harmony support for audio. The Audio repository contains a variety of audio-related firmware projects that demonstrate the capabilities of the MPLAB Harmony 3 audio offerings. Each example application project describes its hardware setup, block diagram, requirements, hardware compatibility and operation. Many of these applications can be used as the basis for fully featured products. They may contain integration with other technologies including USB, graphics or RTOS. It also contains drivers for hardware codecs that can be connected to development boards, such as the WM8904 Codec Daughter Card. Finally, it contains BSP Audio Templates that can be used to make configuring a new audio project a matter of just a few mouse clicks. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html#mplab-harmony-3-audio-overview",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html#mplab-harmony-3-audio-overview"
  },"174": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html"
  },"175": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "Web Links",
    "content": ". | MPLAB Harmony 3 Audio Overview | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html#web-links"
  },"176": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html#reference-links"
  },"177": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "MPLAB Harmony 3 Audio Overview",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html"
  },"178": {
    "doc": "Harmony Crypto Overview",
    "title": "Crypto Overview",
    "content": "The Cryptographic Library includes functions to perform encryption, decryption, hashing, authentication, and compression within the embedded application. Random number generation (RNG) functions are also provided. This page provides a brief overview of MPLAB Harmony support for cryptography. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html#crypto-overview",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html#crypto-overview"
  },"179": {
    "doc": "Harmony Crypto Overview",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html"
  },"180": {
    "doc": "Harmony Crypto Overview",
    "title": "Web Links",
    "content": ". | Crypto Overview | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html#web-links"
  },"181": {
    "doc": "Harmony Crypto Overview",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html#reference-links"
  },"182": {
    "doc": "Harmony Crypto Overview",
    "title": "Harmony Crypto Overview",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html"
  },"183": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "MPLAB® Harmony Graphics Suite",
    "content": "MPLAB® Harmony Graphics Suite is an extension of the MPLAB ecosystem for creating embedded graphic firmware solutions on Microchip 32-bit microcontroller and microprocessor products . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html#mplab-harmony-graphics-suite",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html#mplab-harmony-graphics-suite"
  },"184": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html"
  },"185": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony Graphics Suite | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html#web-links"
  },"186": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html#reference-links"
  },"187": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "Harmony Graphics Suite User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html"
  },"188": {
    "doc": "Harmony QTouch User Guide",
    "title": "QTouch® Modular Library Peripheral Touch Controller User’s Guide",
    "content": "The Microchip QTouch® Peripheral Touch Controller (PTC) offers built-in hardware for capacitive touch measurement on sensors that function as buttons, sliders, and wheels. The PTC supports both mutual and self-capacitance measurement without the need for any external component. It offers superb sensitivity and noise tolerance, as well as self-calibration, and minimizes the sensitivity tuning effort by the user. It also extends the support for capacitive touch surface and gesture functionality. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html#qtouch-modular-library-peripheral-touch-controller-users-guide",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html#qtouch-modular-library-peripheral-touch-controller-users-guide"
  },"189": {
    "doc": "Harmony QTouch User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html"
  },"190": {
    "doc": "Harmony QTouch User Guide",
    "title": "Web Links",
    "content": ". | QTouch Modular Library Peripheral Touch Controller User’s Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html#web-links"
  },"191": {
    "doc": "Harmony QTouch User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html#reference-links"
  },"192": {
    "doc": "Harmony QTouch User Guide",
    "title": "Harmony QTouch User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html"
  },"193": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Harmony TCPIP User Guide",
    "content": "This distribution package contains a variety of TCP/IP firmware projects that demonstrate the capabilities of the MPLAB Harmony TCP/IP Stack. Each project describes its hardware setup and requirements. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html#harmony-tcpip-user-guide",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html#harmony-tcpip-user-guide"
  },"194": {
    "doc": "Harmony TCP/IP User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html"
  },"195": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Web Links",
    "content": ". | Harmony TCPIP User Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html#web-links"
  },"196": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html#reference-links"
  },"197": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Harmony TCP/IP User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html"
  },"198": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Harmony USB Stack User Guide",
    "content": "This distribution package contains a variety of USB-related firmware projects that demonstrate the capabilities of the MPLAB Harmony USB stack. This section describes the hardware requirement and procedures to run these firmware projects on Microchip demonstration and development boards. It also provide information about the MPLAB Harmony USB stack, USB Stack Configuration and the USB Stack APIs. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html#harmony-usb-stack-user-guide",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html#harmony-usb-stack-user-guide"
  },"199": {
    "doc": "Harmony USB Stack User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html"
  },"200": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Web Links",
    "content": ". | Harmony USB Stack User Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html#web-links"
  },"201": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html#reference-links"
  },"202": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Harmony USB Stack User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html"
  },"203": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "WINC Driver Architecture",
    "content": "This section describes the WINC Driver Library. This Driver supports both ATWINC1500 and ATWINC3400. The MPLAB Harmony WINC Driver provides a high-level interface to the ATWINC1500 and ATWINC3400 Wi-Fi network controller modules. The WINC Driver Library, in conjunction with the ATWINC1500 or ATWINC3400 module, allows an application to: . | Join an existing 802.11 b/g/n 2.4GHz Wi-Fi Infrastructure network. | Create an 802.11 Wi-Fi Ad Hoc of Soft AP network. | Scan for other W-Fi devices in an area | Supports BLE 4.0 provisioning and profiles in central and peripheral mode (ATWINC3400 only) | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html#winc-driver-architecture",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html#winc-driver-architecture"
  },"204": {
    "doc": "Harmony WINC Driver Architecture",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html"
  },"205": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "Web Links",
    "content": ". | WINC Driver Architecture | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html#web-links"
  },"206": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html#reference-links"
  },"207": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "Harmony WINC Driver Architecture",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html"
  },"208": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Getting Started with Harmony v3 Drivers and Middleware on PIC32MZ EF MCUs using FreeRTOS",
    "content": "This tutorial shows you how to use the MHC to create an application that gets you started in developing applications on PIC32MZ EF MCUs using MPLAB Harmony v3 software framework with FreeRTOS™. Harmony v3 drivers support Asynchronous and Synchronous modes of operation. | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs) | Works seamlessly in bare-metal and RTOS environment | Interrupt and thread-safe | . | Synchronous Mode . | Blocking APIs | Suitable for use in RTOS environment | Interrupt and thread-safe | . | . In this tutorial, you will use Harmony drivers in Synchronous mode of operation and Harmony middleware libraries with FreeRTOS. The application makes use of Curiosity PIC32MZ EF 2.0 Development Board and I/O1 Xplained Pro Extension Kit. The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM and to a file in a USB thumb drive whenever the USB thumb drive is connected. Also, an LED (LED1) is toggled every time the temperature is displayed on the serial console and an LED (LED2) is in ON state when a USB thumb drive is connected. The application you create will utilize: . | I²C Synchronous Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | Universal Synchronous Asynchronous Receiver Transmitter (USART) Synchronous Driver to print the temperature values on a COM (serial) port terminal application running on a PC. | USB High-Speed Driver, USB Host Middleware, and File System Service libraries to write the temperature readings to a file in a USB thumb drive whenever a USB thumb drive is connected. | GPIO Peripheral Library to toggle an LED. | FreeRTOS library to create middleware, application threads, and intercommunicate between these threads. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html#getting-started-with-harmony-v3-drivers-and-middleware-on-pic32mz-ef-mcus-using-freertos",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html#getting-started-with-harmony-v3-drivers-and-middleware-on-pic32mz-ef-mcus-using-freertos"
  },"209": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html"
  },"210": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers and Middleware on PIC32MZ EF MCUs using FreeRTOS | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html#web-links",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html#web-links"
  },"211": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html#reference-links",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html#reference-links"
  },"212": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html"
  },"213": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Quickstart Prebuilt Graphics Applications",
    "content": "Quickstart prebuilt graphis applications lets you get started with MPLAB Harmony Graphics Suite in about 30 seconds. These applications should give you a ready-made starting point for writing your own graphics apps with MPLAB Harmony Graphics Suite. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#quickstart-prebuilt-graphics-applications",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#quickstart-prebuilt-graphics-applications"
  },"214": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html"
  },"215": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Web Links",
    "content": ". | Quickstart Prebuilt Graphics Applications | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#web-links",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#web-links"
  },"216": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#reference-links",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#reference-links"
  },"217": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Quickstart Prebuilt Graphics Applications",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html"
  },"218": {
    "doc": "Audio Tone using a lookup table",
    "title": "Lab 1: Audio-Tone Generation Using a Lookup Table with Harmony v3",
    "content": "In this lab, you will create a simple MPLAB Harmony project from scratch. You will use the MHC to configure the codec on the PIC32 Multimedia Expansion Board II. The application streams an audio tone (stored in the form of a lookup table in memory) over the I²S interface which gets played on the audio codec. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#lab-1-audio-tone-generation-using-a-lookup-table-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#lab-1-audio-tone-generation-using-a-lookup-table-with-harmony-v3"
  },"219": {
    "doc": "Audio Tone using a lookup table",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html"
  },"220": {
    "doc": "Audio Tone using a lookup table",
    "title": "Web Links",
    "content": ". | Lab 1: Audio-Tone Generation Using a Lookup Table with Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#web-links"
  },"221": {
    "doc": "Audio Tone using a lookup table",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#reference-links"
  },"222": {
    "doc": "Audio Tone using a lookup table",
    "title": "Audio Tone using a lookup table",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html"
  },"223": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Lab 2: Audio-Tone Generation from a Text File Stored in an SD Card with Harmony v3",
    "content": "This lab adds to the previous one. The audio_player_lab2 application reads an audio text file from the PIC32 Multimedia Expansion Board II SD card and streams it over the PIC32 I²S interface to the audio CODEC. The audio file is saved as a .txt file with comma-separated left and right channel audio data. The audio_player_lab2 application demonstrates the configuration and integration of the additional modules to audio_player_lab1 using MHC, thereby extending its functionality. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#lab-2-audio-tone-generation-from-a-text-file-stored-in-an-sd-card-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#lab-2-audio-tone-generation-from-a-text-file-stored-in-an-sd-card-with-harmony-v3"
  },"224": {
    "doc": "Audio Tone using text fil in SD card",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html"
  },"225": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Web Links",
    "content": ". | Lab 2: Audio-Tone Generation from a Text File Stored in an SD Card with Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#web-links"
  },"226": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#reference-links"
  },"227": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Audio Tone using text fil in SD card",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html"
  },"228": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Lab 5: Display Graphics Support to Select and Play Audio File",
    "content": "In this lab, you will add to the previous one, a graphics display UI on the PIC32 Multimedia Expansion Board II. The audio_player_lab5 application displays audio tracks from the SD card in a list box. You can navigate the list to select and play a track. It also provides a volume increase/decrease scroll bar and a mute on/off button. This lab will demonstrate the configuration and integration of additional modules to audio_player_lab4 using the MPLAB Harmony 3 Configurator (MHC), thereby extending its functionality. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#lab-5-display-graphics-support-to-select-and-play-audio-file",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#lab-5-display-graphics-support-to-select-and-play-audio-file"
  },"229": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html"
  },"230": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Web Links",
    "content": ". | Lab 5: Display Graphics Support to Select and Play Audio File | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#web-links"
  },"231": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#reference-links"
  },"232": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Display Graphics to Select and Play Audio File",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html"
  },"233": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Lab 4: Play a WAV Audio File from an SD Card with Harmony v3",
    "content": "This lab extends previous one and add new functionality to it. This application reads a WAV audio file from the SD card on the PIC32 Multimedia Expansion Board II and streams it over the PIC32 I²S interface through the audio CODEC. Here, we implement the functionality of an audio player (for WAV files only). The application switches to the next track when the current track playing is completed (assuming that there is more than one track on the SD card). This application also demonstrates the configuration and integration of the additional modules using MHC, thereby extending its functionality. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#lab-4-play-a-wav-audio-file-from-an-sd-card-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#lab-4-play-a-wav-audio-file-from-an-sd-card-with-harmony-v3"
  },"234": {
    "doc": "Play WAV Audio File from SD Card",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html"
  },"235": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Web Links",
    "content": ". | Lab 4: Play a WAV Audio File from an SD Card with Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#web-links"
  },"236": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#reference-links"
  },"237": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Play WAV Audio File from SD Card",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html"
  },"238": {
    "doc": "SD card Reader to load Audio Files",
    "title": "Lab3: SD Card Reader Support to Load Audio Files with Harmony v3",
    "content": "This lab extends previous one by adding Secure Digital (SD) card reader functionality. The audio_player_lab3 application shows how to edit the contents of an SD card. The PIC32 Multimedia Expansion Board II is connected to a USB host, (typically a PC) and after a successful enumeration, the SD card is presented as a mass storage drive on the PC allowing you to add or delete contents. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#lab3-sd-card-reader-support-to-load-audio-files-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#lab3-sd-card-reader-support-to-load-audio-files-with-harmony-v3"
  },"239": {
    "doc": "SD card Reader to load Audio Files",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html"
  },"240": {
    "doc": "SD card Reader to load Audio Files",
    "title": "Web Links",
    "content": ". | https://microchipdeveloper.com/harmony3:audio-player-lab3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#web-links"
  },"241": {
    "doc": "SD card Reader to load Audio Files",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#reference-links"
  },"242": {
    "doc": "SD card Reader to load Audio Files",
    "title": "SD card Reader to load Audio Files",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html"
  },"243": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "MPLAB® Harmony v3 SD Card Audio Player/Reader Tutorial",
    "content": "The rapid prototyping ability of MPLAB Harmony is due to the availability of software modules (Drivers, System Services and Middleware Libraries) and tools (MPLAB Harmony 3 Configurator (MHC) and MPLAB Harmony Graphics Composer (MHGC)) that are designed to allow maximum reuse of code and rapid development. The following exercises demonstrate the quick prototyping capability of MPLAB Harmony. These exercises should be completed sequentially to understand how the following exercise enhances and adds new functionality to the earlier exercise. | Lab 1: Audio-Tone Generation Using a Lookup Table | Lab 2: Audio-Tone Generation Using Text File Stored in SD Card | Lab 3: SD Card Reader Support to Load Audio Files | Lab 4: Play WAV Audio File from SD Card | Lab 5: Display Graphics Support to Select and Play an Audio File | . This tutorial series makes makes use of PIC32MZ Embedded Connectivity with FPU and PIC32 Multimedia Expansion Board II (sold separately). Note: This tutorial series is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#mplab-harmony-v3-sd-card-audio-playerreader-tutorial",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#mplab-harmony-v3-sd-card-audio-playerreader-tutorial"
  },"244": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html"
  },"245": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "Web Links",
    "content": ". | MPLAB Harmony v3 SD Card Audio Player/Reader Tutorial | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#web-links"
  },"246": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#reference-links"
  },"247": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "SD Card Audio Player Reader Tutorial",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html"
  },"248": {
    "doc": "Middleware Examples",
    "title": "MPLAB Harmony Middleware Example Documentation",
    "content": "This page contains quick documentation for MPLAB® Harmony 3 Middleware Libraries usage. | Getting Started with Harmony v3 Drivers and Middleware on PIC32MZ EF MCUs using FreeRTOS . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#mplab-harmony-middleware-example-documentation",
    "relUrl": "/source/middleware/readme.html#mplab-harmony-middleware-example-documentation"
  },"249": {
    "doc": "Middleware Examples",
    "title": "Audio",
    "content": ". | MPLAB Harmony 3 Audio Overview . | Creating your first Audio Application . | Creating Your first Audio Decoder Application . | SD Card Audio Player/Reader Tutorial . | Audio-Tone Generation Using a Lookup Table . | Audio-Tone Generation from a Text File Stored in an SD Card . | SD Card Reader Support to Load Audio Files . | Play a WAV Audio File from an SD Card . | Display Graphics Support to Select and Play Audio File . | . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#audio",
    "relUrl": "/source/middleware/readme.html#audio"
  },"250": {
    "doc": "Middleware Examples",
    "title": "Graphics",
    "content": ". | Quickstart Prebuilt Graphics Applications . | Creating a new Graphics Application . | Graphics Quick Start Application Guides . | Harmony Graphics Suite User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#graphics",
    "relUrl": "/source/middleware/readme.html#graphics"
  },"251": {
    "doc": "Middleware Examples",
    "title": "USB",
    "content": ". | Create your first USB Device Application . | Create Your First USB Host Application . | Harmony USB Stack User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#usb",
    "relUrl": "/source/middleware/readme.html#usb"
  },"252": {
    "doc": "Middleware Examples",
    "title": "TCP/IP",
    "content": ". | Create your first TCP/IP Application . | Harmony TCP/IP User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#tcpip",
    "relUrl": "/source/middleware/readme.html#tcpip"
  },"253": {
    "doc": "Middleware Examples",
    "title": "Touch",
    "content": ". | Create a Touch Project in Harmony . | Create Touch Surface &amp; Gesture Project in Harmony . | Harmony QTouch User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#touch",
    "relUrl": "/source/middleware/readme.html#touch"
  },"254": {
    "doc": "Middleware Examples",
    "title": "Crypto",
    "content": ". | Harmony Crypto Overview - Board Examples . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#crypto",
    "relUrl": "/source/middleware/readme.html#crypto"
  },"255": {
    "doc": "Middleware Examples",
    "title": "Wireless",
    "content": ". | Create Your First WINC Bypass Mode Example . | Harmony WINC Driver Architecture . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#wireless",
    "relUrl": "/source/middleware/readme.html#wireless"
  },"256": {
    "doc": "Middleware Examples",
    "title": "Bluetooth",
    "content": ". | Create your First Bluetooth Application in Harmony . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#bluetooth",
    "relUrl": "/source/middleware/readme.html#bluetooth"
  },"257": {
    "doc": "Middleware Examples",
    "title": "Motor control",
    "content": ". | Create your first Motor Control Application . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#motor-control",
    "relUrl": "/source/middleware/readme.html#motor-control"
  },"258": {
    "doc": "Middleware Examples",
    "title": "Web Links",
    "content": ". | How to Use the MPLAB Harmony v3 Debug System Service | . Note: . This page provides a quick reference covering the MPLAB Harmony 3 Middleware Libraries usage. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#web-links",
    "relUrl": "/source/middleware/readme.html#web-links"
  },"259": {
    "doc": "Middleware Examples",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#reference-links",
    "relUrl": "/source/middleware/readme.html#reference-links"
  },"260": {
    "doc": "Middleware Examples",
    "title": "Middleware Examples",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html",
    "relUrl": "/source/middleware/readme.html"
  },"261": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Migrate aria_quickstart v2.06 to 3.04 pic32mz_ef_sk_meb2",
    "content": "This guide is to help migrate the graphics application configuration pic32mz_ef_sk_meb2 from MPLAB Harmony v2.06 to MPLAB Harmony v3.04. MPLAB Harmony v3 introduces new features and APIs of which aria_quickstart pic32mz_ef_sk_meb2 application and configuration can take advantage. This page guides you to an overview of the steps to migrate your graphics apps to MPLAB Harmony v3. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#migrate-aria_quickstart-v206-to-304-pic32mz_ef_sk_meb2",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#migrate-aria_quickstart-v206-to-304-pic32mz_ef_sk_meb2"
  },"262": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html"
  },"263": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | Migrate aria_quickstart v2.06 to 3.04 pic32mz_ef_sk_meb2 | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#web-links"
  },"264": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#reference-links"
  },"265": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html"
  },"266": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Porting Application from ASF3 to MPLAB Harmony 3 Framework",
    "content": "This page guides to the different steps to consider when porting an embedded application from Microchip Advance Software Framework 3 (ASF3) to MPLAB® Harmony 3 framework. It covers the following migration aspects: . | How to create a MPLAB Harmony 3 project under MPLAB X IDE and navigate through MPLAB Harmony 3 Configurator (MHC) | How to identify and get the configuration of the different elements that compose the ASF3 project | How to port the System, Driver, or Middleware configuration using MPLAB Harmony 3 Configurator | Important aspects to consider when porting the project Application Layer | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html#porting-application-from-asf3-to-mplab-harmony-3-framework",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html#porting-application-from-asf3-to-mplab-harmony-3-framework"
  },"267": {
    "doc": "Porting ASF to Harmony 3",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html"
  },"268": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Web Links",
    "content": ". | Porting Application from ASF3 to MPLAB Harmony 3 Framework | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html#web-links"
  },"269": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html#reference-links"
  },"270": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Porting ASF to Harmony 3",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html"
  },"271": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Application migration from 8-bit AVR to 32-bit SAM D21 MCU",
    "content": "This page acts as a reference for migrating applications from 8-bit AVR Microcontroller (MCU) to 32-bit SAM MCU. This page shows how to migrate an application from ATMega4809 MCU to SAMD21G17D MCU with the help of an example. For the migration to a 32-bit MCU, the application uses SAM D21 Curiosity Nano Evaluation Kit and is developed on MPLAB® Harmony v3 software framework. The SAM D21 Curiosity Nano Evaluation Kit is a hardware platform to evaluate the SAMD21G17D microcontroller (MCU). It is supported by the MPLAB® X Integrated Development Environment (IDE) and MPLAB Harmony v3 software development framework. The evaluation kit provides easy access to the features of the SAM D21 MCU to integrate the device into a custom design. Because the evaluation kit contains an On-Board Nano Debugger for programming and debugging, no external tools are necessary to program the SAMD21G17D device. The evaluation kit is compatible with Curiosity Nano Base board (Part Number - AC164162) which allows you to quickly scale and prototype your next innovative design using the SAMD21G17D MCU. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. This migration guide refers an existing application “Getting Started with UART on ATmega4809” developed on ATmega4809 Curiosity Nano Evaluation Kit using MPLAB® Code Configurator (MCC) and discuss steps to migrate the existing application to SAM D21 Curiosity Nano Evaluation Kit which using MPLAB® Harmony Configurator (MHC). The application is further extended by adding more peripheral specific functionality. The application developed on SAM D21 MCU will utilize: . | PORT PLIB to control the LED. | External Interrupt Controller (EIC) PLIB and Systick PLIB to toggle the LED on SWITCH press event | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), STDIO Library and Direct Memory Access (DMA) PLIBs to print the Info messages on a COM (serial) port terminal application running on a PC and to receive command from serial terminal. | SERCOM (as SPI) to run a self-loopback test. | . Two ways to use this guide: . | Create the project from scratch: . | Follow step-by-step instructions below. | . | Use the solution project as an example: . | Build the solution project and program it to the SAM D21 Curiosity Nano Evaluation Kit to observe the expected behavior. | . | . This following bullet points provides links to the topics: . | Hardware Used | Software/Tools Used | Hardware Setup | Description . | Overview | Install MHC | Create MPLAB Harmony v3 Project | Configure Clock | Add SERCOM (USART) Peripheral | Generate Code | Add Code | Build and Program | Verify “Hello World” output | Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality | Verify Formatted STDIO, USART Receive and SWITCH/LED functionality | Extend application to configure SPI loopback using DMA based Transfers | Verify extended functionality - SPI loopback | . | Results | Analysis | Conclusions | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#application-migration-from-8-bit-avr-to-32-bit-sam-d21-mcu",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#application-migration-from-8-bit-avr-to-32-bit-sam-d21-mcu"
  },"272": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"273": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Hardware Used:",
    "content": ". | SAM D21 Curiosity Nano Evaluation Kit | Connection wires | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-used",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-used"
  },"274": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"275": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Software/Tools Used:",
    "content": "This project has been verified to work with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | Any Serial Terminal application like Tera Term terminal application. | . Because Microchip regularly update tools, occasionally issue(s) could be discovered while using the newer versions of the tools. If the project doesn’t seem to work and version incompatibility is suspected, It is recommended to double-check and use the same versions that the project was tested with. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#softwaretools-used",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#softwaretools-used"
  },"276": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"277": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Hardware Setup",
    "content": ". | Connect the SAM D21 Curiosity Nano Development Board to the Host PC as a USB Device through a Type-A male to micro-B USB cable connected to Micro-B USB (Debug USB) port | Connect a wire from PA16 to PA19 on SAM D21 Curiosity Nano Development Kit for SPI Self Loopback testing. | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-setup",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-setup"
  },"278": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"279": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Description",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#description",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#description"
  },"280": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": "Overview . This migration guide uses the AVR ATMega4809 application which helps in “Getting Started with UART on AVR”. | Click Here to download the application. | . The AVR ATMega4809 application shows how to implement a command line interface. This way, the microcontroller can receive control commands via the USART. In this use case, an LED is controlled using commands sent from the MPLAB Data Visualizer. The application flow is as follows: . | Configures the system clock The clock is configured to 1 MHz using 16 MHz Internal Oscillator | Configures USART3 USART3 is configured for 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | Configures pins The USART TX, RX pins and LED pin are configured | Implements STDIO receive and send functions STDIO library is implemented to receive and send commands from serial terminal | Reads and execute valid commands Receives command from serial terminal and executes it | . Follow the below steps to get started migrating to SAMD21 and later extend the functionality by adding more peripherals. Install MHC . | Install the MPLAB® Harmony Configurator (MHC) Plug-in in the MPLAB X IDE if not installed. | Verify the MPLAB® Harmony Configurator (MHC) Plug-in is installed. | Launch MPLAB X IDE from the Windows® Start Menu. Close all the projects and files that are currently open. | Go to Tools &gt; Embedded. | You will see MPLAB Harmony 3 Configurator in the menu | . | . Create MPLAB Harmony v3 Project . | Create MPLAB Harmony v3 Project Using MPLAB X IDE . | Select File &gt; New Project from the main IDE menu | In the Categories pane of the New Project dialog window, select Microchip Embedded. In the Projects pane, select 32-bit MPLAB Harmony 3 Project, then click Next | In the Framework Path edit box, browse to the folder you downloaded the framework to and select Next | In the Project Settings window, apply the following settings: | . | Location: indicates the path to the root folder of the new project. All project files will be placed inside this folder. The project location can be any valid path, for example: &lt;your project path&gt;/atmega4809_to_samd21 | Folder: indicates the name of the MPLAB X .X folder. Enter “atmega4809_to_samd21_migration” to create an atmega4809_to_samd21_migration.X folder. | . | Name: enter the project’s logical name as “atmega4809_to_sam_d21_cnano”. This is the name that will be shown from within the MPLAB X IDE. | Click Next to proceed to configuration settings | Follow the steps below to set the project’s configuration settings: | . | Name: enter the configuration name as “sam_d21_cnano”. | Target Device: select ATSAMD21G17D as the target device. | After selecting the target device, click Finish to launch MHC. | Device family pack path can be modified in below window. For now, use the default values | The MHC plugin’s main window for the project will be displayed as shown in the following image | . | . Configure Clock . | Configuring Clock Settings The SAM D21 family of microcontrollers (MCUs) contains a sophisticated clock distribution system designed to give maximum flexibility to the user application. The clock system allows the tuning of the performance and power consumption of the device in a dynamic manner. The MHC provides an easy to use UI (User Interface) window, and a Clock Easy View window to configure the system and peripheral clocks. | Launch Clock Easy View by going to Tools menu of MHC window and then select Clock Configuration | In the Clock Easy View, SAM D21 can operate at maximum 48 MHz, therefore Main Clock is set to 48 MHz. | Change the Main Clock to 1MHz | The Open loop Digital Frequency Locked Loop (DFLL 48 MHz) is configured and enabled to run the main clock. The configured DFLL is fed as input to the GCLK generator ‘0’ and a suitable clock divider (48) and masker must be selected to achieve a maximum frequency of 1 MHz. Refer to the following figure to configure the main clock to run at 1MHz | . | . MHC clock easy view provides all the clock options available in the SAMD21 in a UI, which makes easier to configure the clock whenever necessary. Add SERCOM (USART) Peripheral . | Adding SERCOM (USART) Peripheral MHC Graphical User Interface helps in selecting and configuring the peripherals needed by the project. It lists all the peripherals available in SAMD21 in an Active Component tab. | . | Click on the Available Components tab in the left pane in the MPLAB® Harmony Configurator (MHC) window. Expand Peripherals &gt; SERCOM | Double click or drag and drop SERCOM5 to add the USART Peripheral Library (PLIB) to the project graph. | . Note: SAM D21 Curiosity Nano On-Board Nano Debugger also includes a Virtual Com port which is routed to SERCOM5, therefore in this application, SERCOM5 is chosen. | Select the SERCOM5 Peripheral Library in the project graph. Verify that the default “SERCOM Operation Mode” configuration is set as USART and configure 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | . | Configuring USART pins using MHC PIN Configurator The Pin Manager consists of Pin Settings, the Pin Diagram, and the Pin Table tabs, which enables users to configure (assign peripheral function, set pin direction, configure pull-up or pull-down and so on) and map the I/O pins. | . The following color combinations are associated with the pins in the graphical or table View:  Gray: This pin is not usable in the selected configuration, and there is no enabled module which has any functionality on that pin. The grayed-out locks on a white background indicates the pins that are locked out by selected system functions.  Blue: This pin is available and can be allocated to a module.  Green (with a lock): This pin is allocated and selected for a module. The name displayed against the pin is either the name of the pin in the module’s context or a custom name entered. | Open the Pin Configuration tabs by clicking on MHC &gt; Tools &gt; Pin Configuration. | Launching Pin configuration opens Pin Settings, the Pin Diagram, and the Pin Table tabs. | select the MHC Pin Table tab and then scroll down to the SERCOM5 module as shown below.  Enable USART_TX on PA22 (Pin #31)  Enable USART_TX on PB22 (Pin #37) | . Generate Code . | Generate Code . | When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC) as shown below. | Save the configuration in its default location when prompted. | Click on the Code Generate button as shown below to start generating code. | . | . | Click on the Generate button in the Generate Project window, keeping the default settings as shown below. If prompted for saving the configuration, click Save. | As the code is generated, MHC displays the progress as shown below. | Navigate to the Projects tab in MPLAB X IDE to view the project tree structure. | Examine the generated code as shown below. | . MHC will include all the MPLAB Harmony library files and generate the code based on the MHC selections. The generated code would add files and folders to your Harmony project as shown. Among the generated code, notice the Peripheral Library (PLIB) files generated for SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), Clock and PORT peripherals. Add Code . | Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet in main function to print “Hello World” string on the serial terminal. uint8_t welcomeData[] = “Hello World\\r\\n”; . while ( true ) { SERCOM5_USART_Write(&amp;welcomeData[0],sizeof(welcomeData)); } &lt;img src = \"images/code_snippet1.png\" width=\"400\" height=\"300\" align=\"middle\"&gt; . | . Build and Program . | Before proceeding to Build and program, set up the compiler toolchain. Click on the Projects tab on the top left pane in MPLAB X IDE. Right click on the project name pic18f_to_sam_d21_cnano and go to Properties. | Make sure that XC32 (v2.41) is selected as the Compiler Toolchain for XC32. Click on Apply and then click on OK. | Clean and build your application by clicking on the Clean and Build button as shown below. | Program your application to the device by clicking on the Make and Program button as shown below. The lab should build and program successfully. | . Verify “Hello World” output . | Now, open the Tera Term terminal application on your PC (from the Windows® Start menu by pressing the Start button). Select the Serial Port as shown below. | Change the baud rate to 9600. | You should see the “Hello World” message displayed on the terminal as shown below. | . You successfully completed printing the “Hello World” message on serial terminal. Let us continue and extend the functionality of the application as below. Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality . | Configure STDIO Library to use printf and scanf function to write and read data from the serial terminal respectively | Receive the command from serial terminal and control the LED0 on the SAM D21 Curiosity evaluation kit | Use Switch SW0 on the SAM D21 Curiosity Evaluation Kit to toggle the LED twice when it is pressed. External Interrupt controller (EIC) and Systick peripherals are used to achieve this | . | If you closed MHC accidently and would like to open it again, go to Tools &gt; Embedded &gt; MPLAB Harmony 3 Configurator in MPLAB X IDE. | In the Project Graph, Select SERCOM5. Right click on yellow diamond and select consumer as STDIO as shown below | Select the MHC Pin Settings tab and then scroll down to the PORT pin PB10 (Pin Number 19) in the Pin ID column and configure PB10 as an output pin for LED functionality as shown below. | Select the Pin Settings tab and then scroll down to the PORT pin PB11 (Pin Number 20) in the Pin ID column and configure PB11 as an external interrupt pin for switch functionality as shown below. Internal pull-up is enabled to avoid false edge detection as there is no external pull-up on the SAM D21 Curiosity Nano Evaluation Kit. | Select the Project Graph tab. | Under the Available Components tab, expand Peripheral &gt; EIC. Select and double click on EIC to add the EIC module to the project. | . | . | Configure the EIC block to generate an interrupt every time the user presses the switch SW0 as shown below and enable filter functionality to avoid electrical noise on the switch pin. | Enable Systick to create a delay for toggling LED0, click on System in Project Graph and Configure as below. | When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. | Click on the Code Generate button to start generating code. | Click on the Generate button in the Generate Project window, keeping the default settings. If prompted for saving the configuration, click Save. | Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet to receive the command from serial terminal and a function to control the LED0 on the SAM D21 Curiosity Nano Evaluation Kit. | . | In main.c, add the below function above “main” function #include . void executeCommand(char *command) { if(strcmp(command, \"ON\") == 0) { LED_Clear(); printf(\"OK, LED ON.\\r\\n\"); } else if (strcmp(command, \"OFF\") == 0) { LED_Set(); printf(\"OK, LED OFF.\\r\\n\"); } else { printf(\"Incorrect command.\\r\\n\"); } } &lt;img src = \"images/code_snippet2.png\" align=\"middle\"&gt; . | Move “SERCOM5_USART_Write” function above while loop and add scanf inside the while loop as shown below. | Now, open the Tera Term terminal application on your PC. Enable Local echo in Setup &gt; Terminal as shown below. | Clean and build your application by clicking on the Clean and Build button. | . | . Verify Formatted STDIO, USART Receive and SWITCH/LED functionality . | Program your application to the device by clicking on the Make and Program button. The lab should build and program successfully. | In Tera Term you should see “Hello World” message displayed. | Type ON in serial terminal and press Enter to turn on LED0 on SAMD21 Curiosity Nano kit and Type OFF in serial terminal and press Enter to turn off LED0 on SAMD21 Curiosity Nano Evaluation Kit. | Switch SW0 is configured as interrupt using EIC peripheral, therefore register a call back in main function. Whenever user presses the switch, a callback will be notified and inside the call back, toggle the LED0 twice. | In main.c file, inside main function, add the below code. EIC_CallbackRegister(EIC_PIN_11,EIC_User_Handler, 0); SYSTICK_TimerStart(); | In main.c, add the below code above main function static void EIC_User_Handler(uintptr_t context) { uint8_t i = 0; . while(i&lt;4){ LED_Toggle(); SYSTICK_DelayMs(500); i++; } } &lt;img src = \"images/code_snippet4.png\" align=\"middle\"&gt; . | . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | Press the Switch SW0 on SAM D21 Curiosity Nano Evaluation Kit and observe LED0 Toggling twice at 500ms rate. You successfully completed controlling the LED0 on the SAMD21 Curiosity Nano Evaluation Kit by receiving the commands from the serial terminal through USART and also toggled the LED0 on Switch SW0 press using EIC and Systick peripheral. | . Extend application to configure SPI loopback using DMA based Transfers . Let us extend the functionality and add Serial Peripheral Interface (SPI) to perform a Self-Loopback test and add Direct memory address (DMA) to send the status of the SPI Transfer to the terminal without using CPU. | Select the Project Graph tab. Under the Available Components tab, expand Peripheral &gt; SERCOM. Select and double click on SERCOM1 to add the SPI module to the project. | In Project Graph select SERCOM1 and configure as below . | Open Pin Table, Select SERCOM1 and configure the pins as shown below . | Launch DMA Configurator from MHC &gt; Tools &gt; DMA Configuration | Click on ADD Channel and Select SERCOM5_Transmit to configure the DMA | When done, before generating code, click the *Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. | Click on the Code Generate button to start generating code. | Click on the Generate button in the Generate Project window, keeping the default settings. | If prompted for saving the configuration, click Save. | In main.c, Add below code snippet SERCOM1_SPI_WriteRead(&amp;txData[0], sizeof(txData), &amp;rxData[0], sizeof(rxData)); . /* Compare received data with the transmitted data */ if ((memcmp(txData, rxData, sizeof(txData)) == 0)) { /* Pass: Received data is same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \"Received SPI Valid Data\\r\\n\", \\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\ 25); } else { /* Fail: Received data is not same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \"Received Invalid SPI Data\\r\\n\", \\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\ 27); } DMAC_ChannelDisable(DMAC_CHANNEL_0); - Add below code snippet above main function uint8_t txData[] = \"SELF LOOPBACK DEMO FOR SPI!\"; uint8_t rxData[sizeof(txData)]; &lt;img src = \"images/code_snippet5.png\" align=\"middle\"&gt; . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | . Verify extended functionality - SPI loopback . | Connect PA16 and PA19 on SAM D21 Curiosity Nano Evaluation Kit using a connecting wire. | Open Tera Term and observe the data as shown below. | . You can still control the LED0 by sending the commands through serial terminal. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"281": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"282": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Results",
    "content": "You observed the migration of application from ATmega4809 to SAMD21. You successfully used USART and STDIO to print the messages and receive the commands. Ports and EIC were used to control the LED and also configured SPI and DMA to perform self-loop back test. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#results",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#results"
  },"283": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": "## Analysis You have successfully created your first application using MPLAB Harmony v3 on a SAM D21 microcontroller. Your application used all the fundamental elements that go into building a real-time application. Your successfully migrated application from ATmega4809 to SAMD21. In this application, you used MPLAB Harmony Configurator (MHC) to configure the SAM D21 and also used the MPLAB Harmony v3 Framework. You used the clock configurator to set up the CPU clock and also configured Systick. You configured SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), SERCOM 1 (SPI), and External Interrupt Controller (EIC) Peripheral Libraries (PLIBs). You also configured the Direct Memory Access (DMA) using the DMA configurator. You used the pin configurator to set up the pins for LED and switch functions. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"284": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": "## Conclusions This guide provided you overview of migrating an application from ATmega4809 to SAMD21. This guide also provided steps to configure and using all the fundamental components needed to build an application on a SAM D21 microcontroller with MPLAB Harmony v3 framework. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"285": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#reference-links",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#reference-links"
  },"286": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"287": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Atmel START to MPLAB Harmony 3 Migration Guide",
    "content": "This page guides to the different steps to consider when porting an embedded application from Atmel® START to the MPLAB® Harmony 3 framework. It covers the following migration aspects: . | How to create a MPLAB Harmony 3 project under MPLAB X IDE and navigate through the MPLAB Harmony Configurator (MHC). | How to identify different elements that compose a project under Atmel START. | How to port the system/driver/middleware configuration using MPLAB Harmony Configurator. | Important aspects to consider when porting the project application layer. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html#atmel-start-to-mplab-harmony-3-migration-guide",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html#atmel-start-to-mplab-harmony-3-migration-guide"
  },"288": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html"
  },"289": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | Atmel START to MPLAB Harmony 3 Migration Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html#web-links"
  },"290": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html#reference-links"
  },"291": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Atmel START to MPLAB Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html"
  },"292": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "content": "This page describes steps to build an MPLAB Harmony v3 project with ARM GNU Toolchain in MPLABX IDE. The page demonstrates configuring, building, and running an MPLAB Harmony v3 peripheral library (PLIB) application with the ARM GCC toolchain developed on the SAM D21 Xplained Pro Evaluation Kit. The application demonstrates how to use the AC (Analog Comparators) Peripheral library to perform a single-shot conversion when the peripheral is triggered by the RTC (Real-Time Counter) compare event. The generation of a trigger and compare operation is done while the CPU is in the standby sleep mode. The AC generates the interrupt at the end of the comparison which wakes the CPU. The SAM D21 Xplained Pro Evaluation Kit is ideal for evaluating and prototyping with the SAM D21 ARM® Cortex®-M0+ based microcontrollers. Xplained Pro Extension kits compatible with SAM D21 Xplained Pro can be purchased individually. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#build-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#build-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide"
  },"293": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"294": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Prerequisite:",
    "content": ". | Make sure MPLAB X IDE is installed and Harmony v3 repositories are cloned. For detailed information, refer MPLAB Harmony v3 | Download and install ARM GNU Toolchain v6.3.1 | Note: If Atmel Studio is already installed in PC, then installing ARM GCC toolchain is not required as Atmel Studio is already bundled with ARM GNU Toolchain. | . There are two ways to use this guide: . | Use the solution project as an example: . | Build the solution project and program it to the SAM D21 Xplained Pro Evaluation Kit to observe the expected behavior. | . | Create the project from scratch: . | Follow step-by-step instructions below. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#prerequisite",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#prerequisite"
  },"295": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Instructions to configure, build and run MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "content": "The following bullet points provides links to the topics: . | Hardware Used | Software/Tools Used | Description . | Overview | Open Project and Compile using XC32 Toolchain | Configure the project to use ARM GCC Toolchain | Compile the project using ARM GCC Toolchain | Running the Demo | . | Results | Conclusions | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#instructions-to-configure-build-and-run-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#instructions-to-configure-build-and-run-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide"
  },"296": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"297": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Hardware Used:",
    "content": ". | SAM D21 Xplained Pro Evaluation Kit | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#hardware-used",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#hardware-used"
  },"298": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"299": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Software/Tools Used:",
    "content": "This project has been verified to work with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “csp_apps_sam_d21_da1” repo v3.0.0 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony v3 “reference_apps” repo v1.1.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | ARM GNU Toolchain v6.3.1 | MPLAB XC32 Compiler v2.41 [Optional] | Any Serial Terminal application like Tera Term terminal application. | . Because Microchip regularly update tools, occasionally issue(s) could be discovered while using the newer versions of the tools. If the project doesn’t seem to work and version incompatibility is suspected, It is recommended to double-check and use the same versions that the project was tested with. ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#softwaretools-used",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#softwaretools-used"
  },"300": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Setting up SAM D21 Xplained Pro Evaluation Kit:",
    "content": ". | Connect a voltage below VDD to pin 17 of the EXT1 connector | Connect the Debug USB port on the board to the computer using a micro USB cable | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#setting-up-sam-d21-xplained-pro-evaluation-kit",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#setting-up-sam-d21-xplained-pro-evaluation-kit"
  },"301": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"302": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Description",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#description",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#description"
  },"303": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": "Overview: . The AC Sleepwalking Harmony v3 Application on SAM D21 Xplained Pro Evaluation Kit is used to show the steps to compile the project with ARM GCC Toolchain in MPLAB X IDE. Note: The AC Sleepwalking demo application is chosen as an example. The user could chose to use any MPLAB Harmony v3 application developed on MPLAB X IDE to be built with the ARM GCC toolchain. Open project and compile using XC32 Toolchain: . Note: This is an optional step. This could be followed to verify whether the existing Harmony v3 example used in this guide builds and works on the XC32 compiler toolchain. | Open MPLAB X IDE and close if any projects are opened. | Go to File -&gt; Open Project -&gt; &lt;Go to Harmony v3 repository&gt; -&gt; csp_apps_sam_d21_da1 /apps/ac/ac_sleepwalk_singleshot/firmware and select the “sam_d21_xpro.X” and open the project. | Before changing the toolchain to ARM GCC, ensure the example application demo is compiling and working fine with existing the XC32 toolchain. This is to avoid any errors because of missing library or source files. | Select the Project -&gt; Right Click -&gt; Properties -&gt; ensure correct hardware and XC32 compiler version is selected. | Compile the project. | Run on hardware to ensure the project is working as expected. | . Configure the project to use ARM GCC Toolchain: . This can be done with two methods, either automatically or manually. | Automatic Detection: If Atmel Studio is installed in PC, By default, MPLAB X IDE detects the ARM GCC toolchain (installed as a part of Atmel Studio) and shows it in the MPLAB X IDE’s Project properties. Refer the figure which shows ARM GCC Toolchain selection. Since the ARM GCC toolchain is already available, switch to the ARM GCC toolchain from the project properties. | Manual: If Atmel Studio is not installed, install the ARM GCC toolchain manually. Go to MPLAB X IDE -&gt; Tools -&gt; Options -&gt; Embedded -&gt; Build Tools -&gt; Add -&gt; give the base directory -&gt; **/toolchain/arm/arm-gnu-toolchain/bin\"**. Save it. | | Now, select the ARM GCC toolchain in the example application demo project properties. Select the Project -&gt; Right Click -&gt; Properties -&gt; select the ARM GCC toolchain in compiler options and save. | | . | . Compile the project using ARM GCC Toolchain: . If the project is compiled at this point, the compiler may throw some errors. To avoid compiler errors, follow the below steps. | Add include directories as shown in the following image to avoid missing file errors for device.h and device_cache.h. | The include directory paths are shown below: . | csp_apps_sam_d21_da1/apps/ac/ac_sleepwalk_singleshot/firmware/src/config/sam_d21_xpro | csp_apps_sam_d21_da1/apps/ac/ac_sleepwalk_singleshot/firmware/src/packs/ATSAMD21J18A_DFP | . | | . | Comment the user row configuration bits #pragmas from the “initialization.c” file. This is because #pragmas are not recognized by the ARM GCC compiler. | . | Add or Edit the below files to make the project work with ARM GCC toolchain. | Add custom Linker file to the project. | Replace XC32 startup code with ARM GCC startup code. This can be done by adding “startup_gcc.c” file and excluding (or removing) “startup_xc32.c” file from project. Edit “libc_syscalls.c” file to compile with ARM GCC toolchain. | Add STDIO -&gt; “gcc_monitor.c” file to make printf/scanf work properly. Exclude (or remove) the “xc32_monitor.c” file from the MPLAB Harmony v3 project. | | This can be done as follows: | Go to config folder of Harmony v3 project config folder | Download the solution project from link reference_apps | From the downloaded solution project, copy the files from /apps/sam_d21_xpro/samd21_ac_sleepwalk_singleshot_gcc/src_gcc_toolchain and paste in the example application (downloaded from csp_apps_sam_d21_da1) folder apps/ac/ac_sleepwalk_singleshot/firmware/src/config/sam_d21_xpro | Paste the files “ATSAMD21J18A.ld”, “startup_gcc.c” in “sam_d21_xpro” folder and “gcc_monitor.c” file in “stdio” folder. | Right click Linker Files in MPLABX project -&gt; Click Add Existing Item -&gt; select corresponding recently added linker file and add to project. Below image is for reference. | . | Similarly, add “startup_gcc.c” file and “gcc_monitor.c” file to the project. | To Exclude a file from Project -&gt; select the file -&gt; Right Click -&gt; select “Exclude file(s) from current configuration” or Remove file from the Project. The former option just exclude from the project and latter option will remove the file from project. | Replace the contents of “libc_syscalls.c” file in the project with the contents of “libc_syscalls.c” file in the zip. This file has definition of_sbrk() needed for ARM GCC compiler in addition to content what already present in it. | . | After completing the above steps, compile the project. | The project should compile successfully. | . | . Running the Demo: . | Perform Prerequisite, Configure the project to use ARM GCC toolchain, Compile the project using ARM GCC Toolchain and Setting up SAM D21 Xplained Pro Evaluation Kit steps mentioned above, if not done already. | Open the Tera Term terminal application on your PC (from the Windows® Start menu by pressing the Start button) | Connect to the EDBG Virtual COM port and configure the baud rate to 115200 | Build and Program the application using the MPLAB X IDE. | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"304": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"305": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Results:",
    "content": ". | The console displays the message stating whether voltage at PA04 is lower or greater than the internal bandgap voltage (1.1 V) | LED0 toggles when comparison is done. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#results",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#results"
  },"306": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"307": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Conclusions:",
    "content": "This guide demonstrated building an MPLAB Harmony v3 peripheral Libraries (PLIBs) example with ARM GCC Toolchain. The same approach can be followed for any other Harmony v3 project. ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#conclusions",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#conclusions"
  },"308": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#reference-links",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#reference-links"
  },"309": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"310": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Differences between MPLAB® Harmony 2 and MPLAB® Harmony 3",
    "content": "This page overviews key differences between MPLAB® Harmony 2 and MPLAB® Harmony 3. | Supports SAM Devices | Differences in Peripheral libraries | Differences in Drivers and Services | No Differences in Middleware! | Differences in the MHC GUI | Online Help | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html#differences-between-mplab-harmony-2-and-mplab-harmony-3",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html#differences-between-mplab-harmony-2-and-mplab-harmony-3"
  },"311": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html"
  },"312": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Web Links",
    "content": ". | Differences between MPLAB Harmony 2 and MPLAB Harmony 3 | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html#web-links"
  },"313": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html#reference-links"
  },"314": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Differences between Harmony 2 to Harmony 3",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html"
  },"315": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "MPLAB Harmony 3 Application Development Guide for MPLAB Harmony 2 Users",
    "content": "This page is intended to guide MPLAB® Harmony 2 users on how to develop applications using MPLAB Harmony 3. MPLAB Harmony is a software framework consisting of compatible and interoperable modules, such as peripheral libraries (PLIBs), drivers, system services, middleware, and third-party libraries. MPLAB Harmony 3 has the same basic principles as MPLAB Harmony 2; however, new features and improvements were made for this release. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html#mplab-harmony-3-application-development-guide-for-mplab-harmony-2-users",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html#mplab-harmony-3-application-development-guide-for-mplab-harmony-2-users"
  },"316": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html"
  },"317": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony v3 Application Development Guide for MPLAB Harmony v2 Users | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html#web-links"
  },"318": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html#reference-links"
  },"319": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "Harmony 2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html"
  },"320": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Introduction to MPLAB and Harmony 3 for Atmel Studio and ASF users",
    "content": "This page overviews introduction to MPLAB® X IDE and MPLAB Harmony v3 framework for the users to get started with new tools and solutions for 32-bit Arm microcontrollers. This page guides Atmel Studio, Atmel START and ASF users to familiarize with MPLAB X IDE and MPLAB Harmony 3. The page also guides to the description of MPLAB X IDE features, MPLAB Harmony v3 architecture, and cite references to equivalent features in Atmel Studio or ASF to enable better understanding. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#introduction-to-mplab-and-harmony-3-for-atmel-studio-and-asf-users",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#introduction-to-mplab-and-harmony-3-for-atmel-studio-and-asf-users"
  },"321": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html"
  },"322": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Web Links",
    "content": ". | Introduction to MPLAB and Harmony v3 for Atmel Studio and ASF users | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#web-links",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#web-links"
  },"323": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#reference-links",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#reference-links"
  },"324": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html"
  },"325": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Application migration from 8-bit PIC18F to 32-bit SAM D21 MCU",
    "content": "This page acts as a reference for migrating applications from 8-bit PIC Microcontroller (MCU) to 32-bit SAM MCU. This page shows how to migrate an application from PIC18F47Q10 MCU to SAMD21G17D MCU with the help of an example. For the migration to a 32-bit MCU, the application uses SAM D21 Curiosity Nano Evaluation Kit and is developed on MPLAB® Harmony v3 software framework. The SAM D21 Curiosity Nano Evaluation Kit is a hardware platform to evaluate the SAMD21G17D microcontroller (MCU). It is supported by the MPLAB® X Integrated Development Environment (IDE) and MPLAB Harmony v3 software development framework. The evaluation kit provides easy access to the features of the SAM D21 MCU to integrate the device into a custom design. Because the evaluation kit contains an On-Board Nano Debugger for programming and debugging, no external tools are necessary to program the SAMD21G17D device. The evaluation kit is compatible with Curiosity Nano Base board (Part Number - AC164162) which allows you to quickly scale and prototype your next innovative design using the SAMD21G17D MCU. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. This migration guide refers an existing application Getting Started with UART Using EUSART on PIC18 developed on PIC18F47Q10 Curiosity Nano evaluation kit using MPLAB® Code Configurator (MCC) and discuss steps to migrate the existing application to SAM D21 Curiosity Nano Evaluation Kit using MPLAB® Harmony Configurator (MHC). The application is further extended by adding more peripheral specific functionality. The application developed on SAM D21 MCU will utilize: . | PORT PLIB to control the LED. | External Interrupt Controller (EIC) PLIB and Systick PLIB to toggle the LED on SWITCH press event | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), STDIO Library and Direct Memory Access (DMA) PLIBs to print the Info messages on a COM (serial) port terminal application running on a PC and to receive command from serial terminal. | SERCOM (as SPI) to run a self-loopback test. | . Two ways to use this guide: . | Create the project from scratch: . | Follow step-by-step instructions below. | . | Use the solution project as an example: . | Build the solution project and program it to the SAM D21 Curiosity Nano Evaluation Kit to observe the expected behavior. | . | . This following bullet points provides links to the topics: . | Hardware Used | Software/Tools Used | Hardware Setup | Description . | Overview | Install MHC | Create MPLAB Harmony v3 Project | Configure Clock | Add SERCOM (USART) Peripheral | Generate Code | Add Code | Build and Program | Verify “Hello World” output | Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality | Verify Formatted STDIO, USART Receive and SWITCH/LED functionality | Extend application to configure SPI loopback using DMA based Transfers | Verify extended functionality - SPI loopback | . | Results | Analysis | Conclusions | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#application-migration-from-8-bit-pic18f-to-32-bit-sam-d21-mcu",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#application-migration-from-8-bit-pic18f-to-32-bit-sam-d21-mcu"
  },"326": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"327": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Hardware Used:",
    "content": ". | SAM D21 Curiosity Nano Evaluation Kit | Connection wires | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#hardware-used",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#hardware-used"
  },"328": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"329": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Software/Tools Used:",
    "content": "This project has been verified to work with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | Any Serial Terminal application like Tera Term terminal application. | . Because Microchip regularly update tools, occasionally issue(s) could be discovered while using the newer versions of the tools. If the project doesn’t seem to work and version incompatibility is suspected, It is recommended to double-check and use the same versions that the project was tested with. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#softwaretools-used",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#softwaretools-used"
  },"330": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"331": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Hardware Setup",
    "content": ". | Connect the SAM D21 Curiosity Nano Development Board to the Host PC as a USB Device through a Type-A male to micro-B USB cable connected to Micro-B USB (Debug USB) port | Connect a wire from PA16 to PA19 on SAM D21 Curiosity Nano Development Kit for SPI Self Loopback testing. | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#hardware-setup",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#hardware-setup"
  },"332": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"333": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Description",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#description",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#description"
  },"334": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": "Overview . This migration guide uses the PIC18 application which helps in “Getting Started with UART Using EUSART on PIC18”. | Click Here to view/download the application. | For details on the application, refer “Section 4” in the user guide. | . The PIC18 application shows how to implement a command line interface. This way, the microcontroller can receive control commands via the EUSART. In this use case, an LED is controlled using commands sent from the MPLAB Data Visualizer. The application flow is as follows: . | Configures the system clock The clock is configured to 1 MHz using High Frequency Internal Oscillator (HFINTOSC). | Configures USART3 USART3 is configured for 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | Configures pins The USART TX, RX pins and LED pin are configured | Implements STDIO receive and send functions STDIO library is implemented to receive and send commands from serial terminal | Reads and execute valid commands Receives command from serial terminal and executes it | . Follow the below steps to get started migrating to SAMD21 and later extend the functionality by adding more peripherals. Install MHC . | Install the MPLAB® Harmony Configurator (MHC) Plug-in in the MPLAB X IDE if not installed. | Verify the MPLAB® Harmony Configurator (MHC) Plug-in is installed. | Launch MPLAB X IDE from the Windows® Start Menu. Close all the projects and files that are currently open. | Go to Tools &gt; Embedded. | You will see MPLAB Harmony 3 Configurator in the menu | . | . Create MPLAB Harmony v3 Project . | Create MPLAB Harmony v3 Project Using MPLAB X IDE . | Select File &gt; New Project from the main IDE menu | In the Categories pane of the New Project dialog window, select Microchip Embedded. In the Projects pane, select 32-bit MPLAB Harmony 3 Project, then click Next | In the Framework Path edit box, browse to the folder you downloaded the framework to and select Next | In the Project Settings window, apply the following settings: | . | Location: indicates the path to the root folder of the new project. All project files will be placed inside this folder. The project location can be any valid path, for example: &lt;your project path&gt;\\pic18f_to_samd21 | Folder: indicates the name of the MPLAB X .X folder. Enter “pic18f_to_samd21_migration” to create a pic18f_to_samd21_migration.X folder. | Name: enter the project’s logical name as “pic18f_to_sam_d21_cnano”. This is the name that will be shown from within the MPLAB X IDE. | Click Next to proceed to configuration settings | Follow the steps below to set the project’s configuration settings: | . | Name: enter the configuration name as “sam_d21_cnano”. | Target Device: select ATSAMD21G17D as the target device. | After selecting the target device, click Finish to launch MHC. | Device family pack path can be modified in below window. For now, use the default values | The MHC plugin’s main window for the project will be displayed as shown in the following image | . | . Configure Clock . | Configuring Clock Settings The SAM D21 family of microcontrollers (MCUs) contains a sophisticated clock distribution system designed to give maximum flexibility to the user application. The clock system allows the tuning of the performance and power consumption of the device in a dynamic manner. The MHC provides an easy to use UI (User Interface) window, and a Clock Easy View window to configure the system and peripheral clocks. | Launch Clock Easy View by going to Tools menu of MHC window and then select Clock Configuration | In the Clock Easy View, SAM D21 can operate at maximum 48 MHz, therefore Main Clock is set to 48 MHz. | Change the Main Clock to 1MHz | The Open loop Digital Frequency Locked Loop (DFLL 48 MHz) is configured and enabled to run the main clock. The configured DFLL is fed as input to the GCLK generator ‘0’ and a suitable clock divider (48) and masker must be selected to achieve a maximum frequency of 1 MHz. Refer to the following figure to configure the main clock to run at 1MHz | . | . MHC clock easy view provides all the clock options available in the SAMD21 in a UI, which makes easier to configure the clock whenever necessary. Add SERCOM (USART) Peripheral . | Adding SERCOM (USART) Peripheral MHC Graphical User Interface helps in selecting and configuring the peripherals needed by the project. It lists all the peripherals available in SAMD21 in an Active Component tab. | . | Click on the Available Components tab in the left pane in the MPLAB® Harmony Configurator (MHC) window. Expand Peripherals &gt; SERCOM | Double click or drag and drop SERCOM5 to add the USART Peripheral Library (PLIB) to the project graph. | . Note: SAM D21 Curiosity Nano On-Board Nano Debugger also includes a Virtual Com port which is routed to SERCOM5, therefore in this application, SERCOM5 is chosen. | Select the SERCOM5 Peripheral Library in the project graph. Verify that the default “SERCOM Operation Mode” configuration is set as USART and configure 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | . | Configuring USART pins using MHC PIN Configurator The Pin Manager consists of Pin Settings, the Pin Diagram, and the Pin Table tabs, which enables users to configure (assign peripheral function, set pin direction, configure pull-up or pull-down and so on) and map the I/O pins. | . The following color combinations are associated with the pins in the graphical or table View:  Gray: This pin is not usable in the selected configuration, and there is no enabled module which has any functionality on that pin. The grayed-out locks on a white background indicates the pins that are locked out by selected system functions.  Blue: This pin is available and can be allocated to a module.  Green (with a lock): This pin is allocated and selected for a module. The name displayed against the pin is either the name of the pin in the module’s context or a custom name entered. | Open the Pin Configuration tabs by clicking on MHC &gt; Tools &gt; Pin Configuration. | Launching Pin configuration opens Pin Settings, the Pin Diagram, and the Pin Table tabs. | select the MHC Pin Table tab and then scroll down to the SERCOM5 module as shown below.  Enable USART_TX on PA22 (Pin #31)  Enable USART_TX on PB22 (Pin #37) | . Generate Code . | Generate Code . | When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC) as shown below. | Save the configuration in its default location when prompted. | Click on the Code Generate button as shown below to start generating code. | . | . | Click on the Generate button in the Generate Project window, keeping the default settings as shown below. If prompted for saving the configuration, click Save. | As the code is generated, MHC displays the progress as shown below. | Navigate to the Projects tab in MPLAB X IDE to view the project tree structure. | Examine the generated code as shown below. | . MHC will include all the MPLAB Harmony library files and generate the code based on the MHC selections. The generated code would add files and folders to your Harmony project as shown. Among the generated code, notice the Peripheral Library (PLIB) files generated for SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), Clock and PORT peripherals. Add Code . | Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet in main function to print “Hello World” string on the serial terminal. uint8_t welcomeData[] = “Hello World\\r\\n”; . while ( true ) { SERCOM5_USART_Write(&amp;welcomeData[0],sizeof(welcomeData)); } &lt;img src = \"images/code_snippet1.png\" width=\"400\" height=\"300\" align=\"middle\"&gt; . | . Build and Program . | Before proceeding to Build and program, set up the compiler toolchain. Click on the Projects tab on the top left pane in MPLAB X IDE. Right click on the project name pic18f_to_sam_d21_cnano and go to Properties. | Make sure that XC32 (v2.41) is selected as the Compiler Toolchain for XC32. Click on Apply and then click on OK. | Clean and build your application by clicking on the Clean and Build button as shown below. | Program your application to the device by clicking on the Make and Program button as shown below. The lab should build and program successfully. | . Verify “Hello World” output . | Now, open the Tera Term terminal application on your PC (from the Windows® Start menu by pressing the Start button). Select the Serial Port as shown below. | Change the baud rate to 9600. | You should see the “Hello World” message displayed on the terminal as shown below. | . You successfully completed printing the “Hello World” message on serial terminal. Let us continue and extend the functionality of the application as below. Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality . | Configure STDIO Library to use printf and scanf function to write and read data from the serial terminal respectively | Receive the command from serial terminal and control the LED0 on the SAM D21 Curiosity evaluation kit | Use Switch SW0 on the SAM D21 Curiosity Evaluation Kit to toggle the LED twice when it is pressed. External Interrupt controller (EIC) and Systick peripherals are used to achieve this . | If you closed MHC accidently and would like to open it again, go to Tools &gt; Embedded &gt; MPLAB Harmony 3 Configurator in MPLAB X IDE. | In the Project Graph, Select SERCOM5. Right click on yellow diamond and select consumer as STDIO as shown below | Select the MHC Pin Settings tab and then scroll down to the PORT pin PB10 (Pin Number 19) in the Pin ID column and configure PB10 as an output pin for LED functionality as shown below. | Select the Pin Settings tab and then scroll down to the PORT pin PB11 (Pin Number 20) in the Pin ID column and configure PB11 as an external interrupt pin for switch functionality as shown below. Internal pull-up is enabled to avoid false edge detection as there is no external pull-up on the SAM D21 Curiosity Nano Evaluation Kit. | Select the Project Graph tab. | . | Under the Available Components tab, expand Peripheral &gt; EIC. Select and double click on EIC to add the EIC module to the project. | . | Configure the EIC block to generate an interrupt every time the user presses the switch SW0 as shown below and enable filter functionality to avoid electrical noise on the switch pin. 21. Enable Systick to create a delay for toggling LED0, click on System in Project Graph and Configure as below. 22. When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. 23. Click on the Code Generate button to start generating code. 24. Click on the Generate button in the Generate Project window, keeping the default settings. If prompted for saving the configuration, click Save. 25. Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet to receive the command from serial terminal and a function to control the LED0 on the SAM D21 Curiosity Nano Evaluation Kit. | . | In main.c, add the below function above “main” function #include . void executeCommand(char *command) { if(strcmp(command, \"ON\") == 0) { LED_Clear(); printf(\"OK, LED ON.\\r\\n\"); } else if (strcmp(command, \"OFF\") == 0) { LED_Set(); printf(\"OK, LED OFF.\\r\\n\"); } else { printf(\"Incorrect command.\\r\\n\"); } } &lt;img src = \"images/code_snippet2.png\" align=\"middle\"&gt; . | Move “SERCOM5_USART_Write” function above while loop and add scanf inside the while loop as shown below. | Now, open the Tera Term terminal application on your PC. Enable Local echo in Setup &gt; Terminal as shown below. | Clean and build your application by clicking on the Clean and Build button. | . | . Verify Formatted STDIO, USART Receive and SWITCH/LED functionality . | Program your application to the device by clicking on the Make and Program button. The lab should build and program successfully. | In Tera Term you should see “Hello World” message displayed. | Type ON in serial terminal and press Enter to turn on LED0 on SAMD21 Curiosity Nano kit and Type OFF in serial terminal and press Enter to turn off LED0 on SAMD21 Curiosity Nano Evaluation Kit. | Switch SW0 is configured as interrupt using EIC peripheral, therefore register a call back in main function. Whenever user presses the switch, a callback will be notified and inside the call back, toggle the LED0 twice. | In main.c file, inside main function, add the below code. EIC_CallbackRegister(EIC_PIN_11,EIC_User_Handler, 0); SYSTICK_TimerStart(); | In main.c, add the below code above main function static void EIC_User_Handler(uintptr_t context) { uint8_t i = 0; . while(i&lt;4){ LED_Toggle(); SYSTICK_DelayMs(500); i++; } } &lt;img src = \"images/code_snippet4.png\" align=\"middle\"&gt; . | . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | Press the Switch SW0 on SAM D21 Curiosity Nano Evaluation Kit and observe LED0 Toggling twice at 500ms rate. You successfully completed controlling the LED0 on the SAMD21 Curiosity Nano Evaluation Kit by receiving the commands from the serial terminal through USART and also toggled the LED0 on Switch SW0 press using EIC and Systick peripheral. | . Extend application to configure SPI loopback using DMA based Transfers . Let us extend the functionality and add Serial Peripheral Interface (SPI) to perform a Self-Loopback test and add Direct memory address (DMA) to send the status of the SPI Transfer to the terminal without using CPU. | Select the Project Graph tab. Under the Available Components tab, expand Peripheral &gt; SERCOM. Select and double click on SERCOM1 to add the SPI module to the project. | In Project Graph select SERCOM1 and configure as below . | Open Pin Table, Select SERCOM1 and configure the pins as shown below . | Launch DMA Configurator from MHC &gt; Tools &gt; DMA Configuration | Click on ADD Channel and Select SERCOM5_Transmit to configure the DMA | When done, before generating code, click the *Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. | Click on the Code Generate button to start generating code. | Click on the Generate button in the Generate Project window, keeping the default settings. | If prompted for saving the configuration, click Save. | In main.c, Add below code snippet SERCOM1_SPI_WriteRead(&amp;txData[0], sizeof(txData), &amp;rxData[0], sizeof(rxData)); . /* Compare received data with the transmitted data */ if ((memcmp(txData, rxData, sizeof(txData)) == 0)) { /* Pass: Received data is same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \"Received SPI Valid Data\\r\\n\", \\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\ 25); } else { /* Fail: Received data is not same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \"Received Invalid SPI Data\\r\\n\", \\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\ 27); } DMAC_ChannelDisable(DMAC_CHANNEL_0); - Add below code snippet above main function uint8_t txData[] = \"SELF LOOPBACK DEMO FOR SPI!\"; uint8_t rxData[sizeof(txData)]; &lt;img src = \"images/code_snippet5.png\" align=\"middle\"&gt; . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | . Verify extended functionality - SPI loopback . | Connect PA16 and PA19 on SAM D21 Curiosity Nano Evaluation Kit using a connecting wire. | Open Tera Term and observe the data as shown below. | . You can still control the LED0 by sending the commands through serial terminal. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"335": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"336": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Results",
    "content": "You observed the migration of application from PIC18F to SAMD21. You successfully used USART and STDIO to print the messages and receive the commands. Ports and EIC were used to control the LED and also configured SPI and DMA to perform self-loop back test. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#results",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#results"
  },"337": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"338": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Analysis",
    "content": "You have successfully created your first application using MPLAB Harmony v3 on a SAM D21 microcontroller. Your application used all the fundamental elements that go into building a real-time application. Your successfully migrated application from PIC18F to SAMD21. In this application, you used MPLAB Harmony Configurator (MHC) to configure the SAM D21 and also used the MPLAB Harmony v3 Framework. You used the clock configurator to set up the CPU clock and also configured Systick. You configured SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), SERCOM 1 (SPI), and External Interrupt Controller (EIC) Peripheral Libraries (PLIBs). You also configured the Direct Memory Access (DMA) using the DMA configurator. You used the pin configurator to set up the pins for LED and switch functions. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#analysis",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#analysis"
  },"339": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"340": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Conclusions",
    "content": "This guide provided you overview of migrating an application from PIC18F to SAMD21. This guide also provided steps to configure and using all the fundamental components needed to build an application on a SAM D21 microcontroller with MPLAB Harmony v3 framework. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#conclusions",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#conclusions"
  },"341": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#reference-links",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#reference-links"
  },"342": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"343": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "MPLAB Harmony 2 to Harmony 3 TCP/IP Application Migration Guide",
    "content": "This guide provides the step by step procedure to migrate a TCPIP application from Harmony 2 to Harmony 3 environment. This will configure the MPLAB Harmony 3 TCPIP/IP Stack, System components and other middleware components. In this migration you will learn how to implement and test a network application which will utilise a Web net server in a real world application. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-tcpip-application-migration-guide",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-tcpip-application-migration-guide"
  },"344": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html"
  },"345": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony 2 to Harmony 3 TCP/IP Application Migration Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#web-links"
  },"346": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#reference-links"
  },"347": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html"
  },"348": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "MPLAB Harmony 2 to Harmony 3 USB Application Migration Guide",
    "content": "This guide provides a step by step procedure to migrate USB applications from MPLAB® Harmony v2.xx to a v3.x.x framework. There are no API level differences between the MPLAB® Harmony v2.xx and v3.x.x USB Stacks. However, there may be API level changes in other components such as Clock, Timer, Ports etc. There are also differences in the MHC GUI. In order to migrate a USB application from MPLAB® Harmony v2.xx to v3.x.x, the user must recreate the application using MPLAB® Harmony v3.x.x MHC. In this guide an existing MPLAB® Harmony v2.xx USB Device CDC single com port demonstration is used to show the step by step procedure to migrate to the MPLAB® Harmony v3.x.x framework. This guide demonstrates how to use the MHC to configure various modules such as Clock, Ports, USB Device Layer, USB Controller Driver, and CDC Function driver etc. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-usb-application-migration-guide",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-usb-application-migration-guide"
  },"349": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html"
  },"350": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony 2 to Harmony 3 USB Application Migration Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html#web-links"
  },"351": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html#reference-links"
  },"352": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html"
  },"353": {
    "doc": "Migration Guides",
    "title": "MPLAB Harmony Migration Guides Documentation",
    "content": "This page contains quick documentation to migrate to MPLAB® Harmony 3. ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#mplab-harmony-migration-guides-documentation",
    "relUrl": "/source/migration/readme.html#mplab-harmony-migration-guides-documentation"
  },"354": {
    "doc": "Migration Guides",
    "title": "Harmony 2 to Harmony 3",
    "content": ". | Differences between MPLAB Harmony 2 and Harmony 3 . | MPLAB Harmony 3 Application Development Guide for MPLAB Harmony 2 Users . | Graphics Applications . | TCP/IP Applications . | USB Applications . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#harmony-2-to-harmony-3",
    "relUrl": "/source/migration/readme.html#harmony-2-to-harmony-3"
  },"355": {
    "doc": "Migration Guides",
    "title": "Atmel Studio, ASF, START to Harmony 3",
    "content": ". | Introduction to MPLAB and Harmony 3 for Atmel Studio and ASF users . | Porting Application from ASF3 to MPLAB Harmony 3 Framework . | Atmel START to MPLAB Harmony 3 Migration Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#atmel-studio-asf-start-to-harmony-3",
    "relUrl": "/source/migration/readme.html#atmel-studio-asf-start-to-harmony-3"
  },"356": {
    "doc": "Migration Guides",
    "title": "8 bit MPLAB Code Configurator (MCC) to 32 bit MPLAB Harmony Configurator (MHC)",
    "content": ". | Application migration from 8-bit PIC18F to 32-bit SAM D21 . | Application migration from 8-bit AVR to 32-bit SAM D21 . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#8-bit-mplab-code-configurator-mcc-to-32-bit-mplab-harmony-configurator-mhc",
    "relUrl": "/source/migration/readme.html#8-bit-mplab-code-configurator-mcc-to-32-bit-mplab-harmony-configurator-mhc"
  },"357": {
    "doc": "Migration Guides",
    "title": "Build MPLAB Harmony v3 project with ARM GCC",
    "content": ". | Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE . | . Note: . This page provides a quick reference covering the Migration to MPLAB Harmony 3. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#build-mplab-harmony-v3-project-with-arm-gcc",
    "relUrl": "/source/migration/readme.html#build-mplab-harmony-v3-project-with-arm-gcc"
  },"358": {
    "doc": "Migration Guides",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#reference-links",
    "relUrl": "/source/migration/readme.html#reference-links"
  },"359": {
    "doc": "Migration Guides",
    "title": "Migration Guides",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html",
    "relUrl": "/source/migration/readme.html"
  },"360": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on PIC32MK GP MCUs",
    "content": "This tutorial shows you how to use the MHC to create an application that will help you get started in developing applications on PIC32MK GP MCUs using MPLAB Harmony v3 Software Framework. The application makes use of a PIC32MK General Purpose (GP) Development board and a MikroElectronika Weather click board (sold separately). The application reads the current room temperature from the temperature sensor on the MikroElectronika Weather click board. The temperature reading is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch S1 on the PIC32MK GP Development Board. Also, an LED (LED1) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | The Serial Peripheral Interface (SPI) Peripheral Library (PLIB) to read the temperature from a temperature sensor. | The TMR2 PLIB to periodically sample temperature sensor data. | The CORE TIMER PLIB to use a blocking timer delay for initializing the temperature sensor. | The Universal Asynchronous Receiver Transmitter (UART) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC. | The General Purpose Input/Output (GPIO) PLIB to change the periodicity of temperature sensor data readings using the SWITCH press event and to toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mk-gp-mcus",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mk-gp-mcus"
  },"361": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html"
  },"362": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on PIC32MK GP MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html#web-links"
  },"363": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html#reference-links"
  },"364": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html"
  },"365": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Getting Started With Harmony v3 Peripheral Libraries on PIC32MX 470 MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on PIC32MX470 MCUs using MPLAB Harmony v3 software framework. The application makes use of PIC32MX470 Curiosity Development Board , MikroElectronika Weather click board, and MikroElectronika USB UART click board (sold separately). The application reads the current room temperature from the temperature sensor on the MikroElectronika Weather click board. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch S1 on the PIC32MX470 Curiosity Development Board. Also, LED1 is toggled every time the temperature is displayed on the serial console. The application you create utilizes: . | I²C Peripheral Library (PLIB) to read the temperature from a temperature sensor. | TMR2 PLIB to periodically sample temperature sensor data. | CORETIMER PLIB to use blocking timer delay for initializing temperature sensor. | UART and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC. | GPIO Peripheral Library to change the periodicity of temperature sensor data read using SWITCH press event and toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mx-470-mcus",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mx-470-mcus"
  },"366": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html"
  },"367": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started With Harmony v3 Peripheral Libraries on PIC32MX 470 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html#web-links"
  },"368": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html#reference-links"
  },"369": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html"
  },"370": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on PIC32MZ EF MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on PIC32MZ EF MCUs using MPLAB Harmony v3 software framework. The application makes use of Curiosity PIC32MZ EF 2.0 Development Board and I/O1 Xplained Pro Extension Kit. The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch SW1 on the Curiosity PIC32MZ EF 2.0 Development Board. Also, LED1 is toggled every time the temperature is displayed on the serial console. The application you create utilizes: . | I²C Peripheral Library (PLIB) to read the temperature from a temperature sensor. | TMR1 PLIB to periodically sample temperature sensor data. | Universal Asynchronous Receiver Transmitter (UART) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC. | GPIO PLIB to change the periodicity of temperature sensor data read using the SWITCH press event and toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mz-ef-mcus",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mz-ef-mcus"
  },"371": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html"
  },"372": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on PIC32MZ EF MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html#web-links"
  },"373": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html#reference-links"
  },"374": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html"
  },"375": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAMC2x MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on SAM C21x MCUs using MPLAB Harmony v3 software framework. The application makes use of SAMC21N Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds and back to 500 milliseconds every time you press the switch SW0 on the SAMC21N Xplained Pro Evaluation Kit. Also, an LED LED0 is toggled every time temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I2C) Peripheral Library (PLIB) to read the temperature from a temperature sensor. | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data. | SERCOM (as USART), Direct Memory Access (DMA) PLIB to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS PLIB to toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-samc2x-mcus",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-samc2x-mcus"
  },"376": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html"
  },"377": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAMC2x MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html#web-links"
  },"378": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html#reference-links"
  },"379": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Getting Started with PLIBs on SAMC2x MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html"
  },"380": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Low Power Application on SAMC2x (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "SAMC2x is part of Microchip’s 32-bit Arm® Cortex® M0+ microcontroller (MCU) family that can be used to meet the needs of power-constrained applications. SAMC2x MCUs provide various sleep modes to meet the power consumption requirements of the application. The Power Manager (PM) module is responsible for controlling the low power modes. SAMC2x supports two low power modes; IDLE and STANDBY. Idle sleep mode: In Idle mode, CPU and Synchronous clocks are stopped except when requested. Idle mode allows power optimization with fast wakeup time. Standby sleep mode: In standby mode, the CPU is stopped as well as the peripherals, except those that are running using the RUN IN STANDBY option. Standby mode allows the device to consume the lowest power with little overhead on wakeup time. The application makes use of the SAM C21 Xplained Pro evaluation kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the application is in sleep (standby) mode. The application wakes up from the sleep mode and enters active mode when you cover the light sensor (by placing a hand over it) on the I/O1 Xplained Pro extension kit. The application periodically prints room temperature on a serial terminal while the light sensor is covered. The application goes back to sleep (standby) mode when you uncover the light sensor. LED0 in the SAM C21 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch SW0, the application switches sleep mode from standby mode to idle mode. The application you create will utilize: . | SERCOM (as I²C) Peripheral Library to read the temperature from the temperature sensor. | RTC Peripheral Library to periodically generate an event for the ADC to sample the light sensor. | SERCOM (as USART) and DMA Peripheral Libraries to print the temperature values on a COM (serial) port terminal application running on a PC. | PORT Peripheral Library to toggle the LED. | ADC Peripheral Library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM (Power Manager) and Supply Controller (SUPC) Peripheral Libraries to configure low power modes. | EIC (External Interrupt controller) Peripheral Library to control switch SW0. Event System Peripheral Library to trigger the start of the ADC conversion on every RTC compare match event. The event system allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html#low-power-application-on-samc2x-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html#low-power-application-on-samc2x-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"381": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html"
  },"382": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Web Links",
    "content": ". | Low Power Application on SAMC2x (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html#web-links"
  },"383": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html#reference-links"
  },"384": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Low Power with PLIBs on SAMC2x MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html"
  },"385": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM D21 MCUs",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM D21 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM D21 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds and back to 500 milliseconds every time you press the switch SW0 on the SAM D21 Xplained Pro Evaluation Kit. Also, an LED0 is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I²C) PLIB to read the temperature from a temperature sensor | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC | PORT PLIB to toggle the LED | External Interrupt Controller (EIC) PLIB to change the periodicity of temperature sensor data read using SWITCH press event | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d21-mcus",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d21-mcus"
  },"386": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html"
  },"387": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM D21 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html#web-links"
  },"388": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html#reference-links"
  },"389": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Getting Started with PLIBs on SAM D21 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html"
  },"390": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on SAM D5x/E5x MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM E54 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds and back to 500 milliseconds every time you press the switch SW0 on the SAM E54 Xplained Pro Evaluation Kit. Also, LED0 is toggled every time temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I²C) Peripheral Library (PLIB) to read the temperature from a temperature sensor. | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data. | SERCOM (as USART), Direct Memory Access (DMA) PLIBS to print the temperature values on a COM (serial) port terminal application running on a PC. PORTS PLIB to toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d5xe5x-mcus",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d5xe5x-mcus"
  },"391": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html"
  },"392": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html#web-links"
  },"393": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html#reference-links"
  },"394": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html"
  },"395": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Low Power Application on SAM E54 (Cortex M4) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "This tutorial shows you how to create a low power application on a SAM E54 using MPLAB® Harmony v3 software framework. The SAM E54 is a 32-bit Arm® Cortex®-M4 based microcontroller that provides features to reduce power consumption through different Sleep modes, such as Idle, Standby, Backup, Hibernate and Off. | In Idle mode, the CPU and the synchronous clocks are stopped, except when requested. This mode allows power optimization with a fast wake-up time. | In Standby mode, the CPU and the peripherals are stopped, except those that are running using the Run in Standby mode feature. This mode allows the device to consume the lowest power with little overhead on wake-up time. | In Backup mode, the device is entirely powered off, except for the peripherals in the backup domain. This mode allows you to achieve the lowest power consumption aside from Off mode but increases the wake-up time compared to Standby mode. | In Hibernate sleep mode, the device is entirely powered off, except for the peripherals in the Hibernate sleep mode. This mode allows you to achieve the lowest power consumption but little more than Backup mode and wake-up time is little faster than Backup mode. | In Off mode, the device is entirely powered off. This mode allows you to achieve the lowest power consumption. Since the device must be reset to recover from this mode, the wake-up time is longer. | . The Power Manager (PM) module is responsible for controlling the Low Power modes. Additionally, the SAM E54 provides SleepWalking, an advanced low power operation mode which is based on event propagation managed by the Event System (EVSYS). This application makes use of the SAM E54 Xplained Pro Evaluation Kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the device is set to Standby Sleep mode. The device wakes up from Standby mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro extension kit. The application periodically prints the room temperature on a serial terminal while the light sensor is covered. The device goes back to Standby mode when you uncover the light sensor. LED0 on the SAM E54 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch button SW0, the application switches Sleep mode from Standby mode to Idle mode. The application you create will utilize the following peripherals: . | SERCOM3 (as I²C) peripheral library to read the temperature from the temperature sensor. | Real-Time Clock (RTC) peripheral library to periodically generate an event for the ADC to sample the light sensor. | SERCOM2 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to print messages on a serial console running on a computer. | Direct Memory Access Controller (DMAC) peripheral library to send the converted temperature value to the SERCOM0. | PORT peripheral library to toggle the LED0. | Analog-to-Digital Converter (ADC1) peripheral library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM and Supply Controller (SUPC) peripheral libraries to configure Low Power modes. | External Interrupt Controller (EIC) peripheral library to control the user button SW0. | EVSYS peripheral library to trigger the start of the ADC conversion on every RTC compare match event. The EVSYS allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html#low-power-application-on-sam-e54-cortex-m4-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/same54_low_power/readme.html#low-power-application-on-sam-e54-cortex-m4-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"396": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html",
    "relUrl": "/source/peripheral/same54_low_power/readme.html"
  },"397": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Web Links",
    "content": ". | Low Power Application on SAM E54 (Cortex M4) MCU Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/same54_low_power/readme.html#web-links"
  },"398": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/same54_low_power/readme.html#reference-links"
  },"399": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Low Power with PLIBs on SAM E54 MCU",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html",
    "relUrl": "/source/peripheral/same54_low_power/readme.html"
  },"400": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM E70/S70/V70/V71 MCUs",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM E70/S70/V70/V71 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM E70 Xplained Ultra board and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds, and back to 500 milliseconds every time you press the switch SW0 on the SAM E70 Xplained Ultra Evaluation Kit. Also, an LED, LED3, is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | Two-Wire Interfaces (TWIHS) (I²C) Peripheral Library to read the temperature from a temperature sensor | Timer Counter (TC) Peripheral Library to periodically sample temperature sensor data | Universal Synchronous Asynchronous Receiver Transmitter (USART) and Direct Memory Access (DMA) Peripheral Libraries to print the temperature values on a COM (serial) port terminal application running on a PC | PORTS Peripheral Library to change the periodicity of temperature sensor data read using SWITCH event and toggle the LED | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-e70s70v70v71-mcus",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-e70s70v70v71-mcus"
  },"401": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html"
  },"402": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM E70/S70/V70/V71 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html#web-links"
  },"403": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html#reference-links"
  },"404": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html"
  },"405": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with Harmony v3 Drivers and System Services on SAM E70/S70/V70/V71 MCUs",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM E70/S70/V70/V71 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM E70 Xplained Ultra board and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM. When a character is entered on the console, the last five written temperature values are read from the EEPROM and displayed on the console. Also, an LED (LED3) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | Two-Wire Interfaces (TWIHS) (I²C) Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | Timer System Service to periodically sample temperature sensor data. | Universal Synchronous Asynchronous Receiver Transmitter (USART) Driver (in Direct Memory Access (DMA) mode) to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS Peripheral Library to toggle an LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html#getting-started-with-harmony-v3-drivers-and-system-services-on-sam-e70s70v70v71-mcus",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html#getting-started-with-harmony-v3-drivers-and-system-services-on-sam-e70s70v70v71-mcus"
  },"406": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html"
  },"407": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers and System Services on SAM E70/S70/V70/V71 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html#web-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html#web-links"
  },"408": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html#reference-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html#reference-links"
  },"409": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html"
  },"410": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Getting Started with Harmony v3 Drivers on SAM E70/S70/V70/V71 MCUs Using FreeRTOS",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM E70/S70/V70/V71 MCUs using MPLAB Harmony v3 software framework. Harmony v3 drivers support Asynchronous and Synchronous modes of operation. | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs) | Works seamlessly in bare-metal and RTOS environment | Interrupt and thread-safe | . | Synchronous Mode . | Blocking APIs | Suitable for use in RTOS environment | Interrupt and thread-safe | . | . In this tutorial, you will use Harmony drivers in Synchronous mode of operation. The application makes use of SAM E70 Xplained Ultra board and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM. When a character is entered on the console, the last five written temperature values are read from the EEPROM and displayed on the console. Also, an LED (LED3) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | Two-Wire Interface High Speed (TWIHS) (I²C) Synchronous Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | USART Synchronous Driver to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS Peripheral Library to toggle an LED. | FreeRTOS library to create application threads and intercommunicate between application threads. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-e70s70v70v71-mcus-using-freertos",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-e70s70v70v71-mcus-using-freertos"
  },"411": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html"
  },"412": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers on SAM E70/S70/V70/V71 MCUs Using FreeRTOS | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html#web-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html#web-links"
  },"413": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html#reference-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html#reference-links"
  },"414": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html"
  },"415": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM L10 MCUs",
    "content": "This tutorial shows you how to use the MHC to create an application that gets you started in developing applications on SAM L10 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM L10 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch SW0 on the SAM L10 Xplained Pro Evaluation Kit. Also, an LED0 is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I²C) PLIB to read the temperature from a temperature sensor | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC | PORT PLIB to toggle the LED | External Interrupt Controller (EIC) PLIB to change the periodicity of temperature sensor data read using SWITCH press event | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-l10-mcus",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-l10-mcus"
  },"416": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html"
  },"417": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM L10 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html#web-links"
  },"418": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html#reference-links"
  },"419": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Getting Started with PLIBs on SAM L10 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html"
  },"420": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Low Power Application on SAM L10 (Cortex M23) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "This tutorial shows you how to create a low power application on a SAM L10 using MPLAB® Harmony v3 software framework. The SAM L10 is a 32-bit Arm® Cortex®-based M23 microcontroller that provides features to reduce power consumption through different Sleep modes, such as Idle, Standby, and Off. | In Idle mode, the CPU and the synchronous clocks are stopped, except when requested. This mode allows power optimization with a fast wake-up time. | In Standby mode, the CPU and the peripherals are stopped, except those that are running using the Run in Standby mode feature. This mode allows the device to consume the lowest power with little overhead on wake-up time. | In Off mode, the device is entirely powered off. This mode allows you to achieve the lowest power consumption. Since the device must be reset to recover from this mode, the wake-up time is longer. | . The Power Manager (PM) module is responsible for controlling the Low Power modes. Additionally, the SAM L10 provides SleepWalking, an advanced low power operation mode which is based on event propagation managed by the Event System (EVSYS). This application makes use of the SAM L10 Xplained Pro Evaluation Kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the device is set to Standby Sleep mode. The device wakes up from Standby mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro extension kit. The application periodically prints the room temperature on a serial terminal while the light sensor is covered. The device goes back to Standby mode when you uncover the light sensor. LED0 on the SAM L10 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch button SW0, the application switches Sleep mode from Standby mode to Idle mode. The application you create will utilize the following peripherals: . | SERCOM1 (as I²C) peripheral library to read the temperature from the temperature sensor. | Real-Time Clock (RTC) peripheral library to periodically generate an event for the ADC to sample the light sensor. | SERCOM0 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to print messages on a serial console running on a computer. | Direct Memory Access Controller (DMAC) peripheral library to send the converted temperature value to the SERCOM0. | PORT peripheral library to toggle the LED0. | Analog-to-Digital Converter (ADC) peripheral library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM and Supply Controller (SUPC) peripheral libraries to configure Low Power modes. | External Interrupt Controller (EIC) peripheral library to control the user button SW0. | EVSYS peripheral library to trigger the start of the ADC conversion on every RTC compare match event. The EVSYS allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html#low-power-application-on-sam-l10-cortex-m23-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html#low-power-application-on-sam-l10-cortex-m23-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"421": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html"
  },"422": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Web Links",
    "content": ". | Low Power Application on SAM L10 (Cortex M23) MCUs Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html#web-links"
  },"423": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html#reference-links"
  },"424": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Low Power with PLIBs on SAM L10 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html"
  },"425": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Low Power Application on SAM L21 (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "This tutorial shows you how to create a low power application on a SAM L21 using MPLAB® Harmony v3 software framework. The SAM L21 is a 32-bit Arm® Cortex® M0+ based microcontroller (MCU) that provides features to reduce power consumption through different Sleep modes such as Idle, Standby, Backup, and Off. | In Idle mode, the CPU and the synchronous clocks are stopped, except when requested. This mode allows power optimization with a fast wake-up time. | In Standby mode, the CPU and the peripherals are stopped, except those that are running using the Run in Standby mode feature. This mode allows the device to consume the lowest power with little overhead on wake-up time. | In Backup mode, the device is entirely powered off, except for the peripherals in the backup domain. This mode allows you to achieve the lowest power consumption aside from Off mode but increases the wake-up time compared to Standby mode. | In Off mode, the device is entirely powered off. It allows you to achieve the lowest power consumption. Since the device must be reset to recover from this mode, the wake-up time is the highest. | . The Power Manager (PM) module is responsible for controlling the Low Power modes. Additionally, the SAM L21 provides SleepWalking, an advanced low power operation mode, which is based on event propagation managed by the Event System (EVSYS). This application makes use of the SAM L21 Xplained Pro B evaluation kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the device is set to Standby Sleep mode. The device wakes up from Standby mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro extension kit. The application periodically prints room temperature on a serial terminal while the light sensor is covered. The device goes back to Standby mode when you uncover the light sensor. LED0 in the SAM L21 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch button SW0, the application switches Sleep mode from Standby mode to Idle mode. The application you create will utilize the following peripherals: . | SERCOM2 (as I²C) peripheral library to read the temperature from the temperature sensor. | Real-Time Clock (RTC) peripheral library to periodically generate an event for the ADC to sample the light sensor. | SERCOM3 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to print messages on a serial console running on a computer. | Direct Memory Access Controller (DMAC) peripheral library to send the converted temperature value to the SERCOM3. | PORT peripheral library to toggle the LED0. | Analog-to-Digital Converter (ADC) peripheral library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM and Supply Controller (SUPC) peripheral libraries to configure Low Power modes. | External Interrupt Controller (EIC) peripheral library to control the user button SW0. | EVSYS peripheral library to trigger the start of the ADC conversion on every RTC compare match event. The EVSYS allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html#low-power-application-on-sam-l21-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html#low-power-application-on-sam-l21-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"426": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html"
  },"427": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Web Links",
    "content": ". | Low Power Application on SAM L21 (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html#web-links"
  },"428": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html#reference-links"
  },"429": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Low Power with PLIBs on SAM L21 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html"
  },"430": {
    "doc": "Peripheral Libraries",
    "title": "MPLAB Harmony Peripheral Libraries Documentation",
    "content": "This page contains quick documentation for MPLAB® Harmony 3 Peripheral Libraries (PLIBs) and drivers usage. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#mplab-harmony-peripheral-libraries-documentation",
    "relUrl": "/source/peripheral/readme.html#mplab-harmony-peripheral-libraries-documentation"
  },"431": {
    "doc": "Peripheral Libraries",
    "title": "Peripheral Libraries (PLIBs)",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAMC2x MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM E70/S70/V70/V71 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM L10 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM D21 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on PIC32MZ EF MCUs . | Getting Started with Harmony v3 Peripheral Libraries on PIC32MX 470 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on PIC32MK GP MCUs . | Low Power Application on SAMC2x (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries . | Low Power Application on SAM L21 (Cortex M0+) MCUs using MPLAB Harmony v3 Peripheral Libraries . | Low Power Application on SAM L10 (Cortex M23) MCUs Using MPLAB Harmony v3 Peripheral Libraries . | Low Power Application on SAM E54 (Cortex M4) MCU Using MPLAB Harmony v3 Peripheral Libraries . | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#peripheral-libraries-plibs",
    "relUrl": "/source/peripheral/readme.html#peripheral-libraries-plibs"
  },"432": {
    "doc": "Peripheral Libraries",
    "title": "Drivers",
    "content": ". | Getting Started with Harmony v3 Drivers and System Services on SAM E70/S70/V70/V71 MCUs . | Getting Started with Harmony v3 Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS . | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#drivers",
    "relUrl": "/source/peripheral/readme.html#drivers"
  },"433": {
    "doc": "Peripheral Libraries",
    "title": "Web Links",
    "content": ". | VIDEO - Create Your First Project with SAMD21 using MPLAB Harmony v3 | VIDEO - Create Your First Project with SAMC21 using MPLAB Harmony v3 | Clock System Configuration and Usage on SAM E5x (Cortex M4) Devices | Clock System Configuration and Usage on SAM C2x (Cortex M0+) Devices | How to Build an Application by Adding a New PLIB, Driver, or Middleware to an Existing MPLAB Harmony v3 Project | Various Timers on SAM Devices | How to Use the TCM on A Cortex-M7 Based MCU with the XC32 Compiler | How to Create Non-Cacheable Memory Region on CortexM7 (SAM S70/ E70/ V70/ V71) MCUs Using MPLAB Harmony v3 | SleepWalking with Event System Using the SAM E54 | Execute-In-Place (XIP) with QSPI on Cortex-M7 MCUs Using MPLAB Harmony v3 | Using XDMAC with QSPI on Arm Cortex-M7 MCUs Using MPLAB Harmony v3 | How to Wake-up Fast From an External Event on Cortex M0+ Based MCUs | Using Sigma-Delta Analog-to-Digital Converter (SDADC) on a SAMC MCU with MPLAB Harmony v3 | . Note: . This page provides a quick reference covering the MPLAB Harmony 3 Peripheral Libraries (PLIBs) and drivers usage. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#web-links",
    "relUrl": "/source/peripheral/readme.html#web-links"
  },"434": {
    "doc": "Peripheral Libraries",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#reference-links",
    "relUrl": "/source/peripheral/readme.html#reference-links"
  },"435": {
    "doc": "Peripheral Libraries",
    "title": "Peripheral Libraries",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html",
    "relUrl": "/source/peripheral/readme.html"
  },"436": {
    "doc": "Create First Harmony 3 Project",
    "title": "Create First MPLAB Harmony 3 Project",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#create-first-mplab-harmony-3-project",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#create-first-mplab-harmony-3-project"
  },"437": {
    "doc": "Create First Harmony 3 Project",
    "title": "Overview",
    "content": "The purpose of this tutorial is to show you how to use Microchip MPLAB® Harmony 3 to create a simple “heartbeat” LED application that flashes an LED using the MPLAB® X IDE and the MPLAB® Harmony Configurator (MHC). As a bonus, you can reuse the heartbeat LED application in future projects as a simple indicator of system health. This tutorial focuses on direct use of MPLAB® Harmony peripheral libraries to build an application. If you are interested in using interoperable MPLAB® Harmony drivers, services, or middleware in your application, please see “Creating Your First Project – Harmony” when you’ve finished with this tutorial. The application can be defined by the following flowchart: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#overview",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#overview"
  },"438": {
    "doc": "Create First Harmony 3 Project",
    "title": "Required Software",
    "content": "The instructions in this tutorial assume that you have already installed following software. | MPLAB X Integrated Development Environment | MPLAB XC32/32++ C Compiler | MPLAB Harmony Configurator | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#required-software",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#required-software"
  },"439": {
    "doc": "Create First Harmony 3 Project",
    "title": "Required Hardware",
    "content": "The instructions in this tutorial use SAMC21N Xplained Pro Evaluation Kitand it has one Yellow Color user LED (PC05) connected GPIO. Similar kits will work similarly, but the setup and steps may not be exactly as described. Setup: The following figure shows the hardware setup details: . | Connect SAMC21N Xplained Pro Evaluation Kit micro USB port to PC using a micro USB cable | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#required-hardware",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#required-hardware"
  },"440": {
    "doc": "Create First Harmony 3 Project",
    "title": "Procedure",
    "content": "The following are the steps to create, generate, build and flash LED Blinking application. Before proceeding, make sure you have downloaded the required Harmony 3 packages (for directions, the MPLAB® Harmony Configurator (MHC) User’s Guide) and setup the required hardware as shown previously. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#procedure",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#procedure"
  },"441": {
    "doc": "Create First Harmony 3 Project",
    "title": "Create a new project",
    "content": ". | Open the MPLAB® X IDE. | Create a New Project by clicking the New Project icon or by selecting File &gt; New Project. | In the New Project window select 32-Bit MPLAB® Harmony 3 Project. | Click Next. Note: If 32-Bit MPLAB® Harmony 3 Project is not displayed, please download and install the MPLAB® Harmony 3 Configurator before continuing with these steps. | Enter the path to the folder in which you downloaded the MPLAB® Harmony 3 packages in the Framework Path edit box. | In the Project Setting dialog window, fill in or select the information needed as follows: . | Location: Create a “MyBlinky” folder in the location of your choice. | Folder: Project Folder name i.e. “sam_c21n_xpro” | Name: Project Name i.e. “my_blinky_sam_c21n_xpro” | . | In the Configuration Settings dialog window, enter the configuration name as “sam_c21n_xpro” and select the Target Device ATSAMC21N18A from the drop-down menu as shown below. | Click Finish. | When the Configuration Database Setup dialog appears, just click Launch as shown below to open MPLAB® Harmony Configurator plugin. If the below dialog window doesn’t appear then MHC can be launched by selecting MPLAB® Harmony 3 Configurator under Tools ? Embedded. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#create-a-new-project",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#create-a-new-project"
  },"442": {
    "doc": "Create First Harmony 3 Project",
    "title": "Setup MPLAB® Harmony Project Configurator to Generate Code",
    "content": ". | From the “Available Components” panel of MHC (on the left side of the MHC window), drag and drop the TC0 peripheral into the Components Graph: . | Click on the “TC0” component and configure as below and in the figure: . | Select Prescaler value to “Prescaler: GCLK_TC/1024” | Set Timer Period (Milli Sec) to “500” This will toggle the LED every 0.5 seconds, producing a LED blink every second. | . | Launch the Pin Configuration manager from the MHC’s Tools menu: | Setup pin “PC05” as the board’s LED, set custom name as “LED” and Direction as “Out”: This is necessary because the project doesn’t use a Board Support Package (BSP). | Generate the application’s code for the first time. | Select the Generate Code button of MHC’s window . | Save the project’s configuration (any name will do for the .xml file): . | Select default as the Merge Strategy (i.e. USER_ALL) and click Generate Now the project’s initial software has been configured. Note: Here is a brief explanation of the different merge strategies that are available: ALL: The user will be prompted with a merge window for all generated files. This includes files that have no user modifications but are changed because of changes in MHC configuration or component updates. (This choice is always the safest.) USER_ALL: The user will always be prompted with a merge window for all generated files that contain user modifications. USER_RECENT: The user will be prompted with a merge window for all generated files that contain user modifications. OVERWRITE: All generated file content will be replaced by the contents of this generate operation. All user changes will be overwritten. | Let’s examine the software just created in the Projects panel of MPLAB® X IDE Header Files are shown on the top and Source Files are shown on the bottom. Note: the icons used in this picture of the project’s organization make it seem like the files of the project are organized this way on disk. In fact, this is a virtual organization of these files, not an actual one. On disk, the source and header files are not separated. The following table describes the Header and Source files generated from the sample project: | . | # | Source File | Descriptions | . | 1 | definitions.h | Provides configuration-specific definitions | . | 2 | exceptions.c | Implements exception handlers | . | 3 | initialization.c | Implements SYS_Initialize to initializes all libraries and applications | . | 4 | interrupts.c | Implements the interrupt vectors | . | 5 | peripheral [libraries] | Implements peripheral libraries used by the project | . | 6 | startup.c | Startup code for the application | . If you click on the Files tab you will see the actual organization of these files on your drive: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#setup-mplab-harmony-project-configurator-to-generate-code",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#setup-mplab-harmony-project-configurator-to-generate-code"
  },"443": {
    "doc": "Create First Harmony 3 Project",
    "title": "Adding Code to main.c",
    "content": "Double click on main.c to bring up an editor window and update it to obtain the following code: . #include \"definitions.h\" // SYS function prototypes static bool volatile bToggleLED = false; // This function is called after period expires void TC0_CH0_TimerInterruptHandler(TC_TIMER_STATUS status, uintptr_t context) { bToggleLED = true; } // ***************************************************************************** // ***************************************************************************** // Section: Main Entry Point // ***************************************************************************** // ***************************************************************************** int main ( void ) { // Initialize all modules SYS_Initialize(NULL); // Register callback function for CH0 period interrupt TC0_TimerCallbackRegister(TC0_CH0_TimerInterruptHandler, (uintptr_t)NULL); // Start the timer channel 0 TC0_TimerStart(); while ( true ) { if ( bToggleLED ) { bToggleLED = false; LED_Toggle(); } } // Execution should not come here during normal operation return EXIT_FAILURE; } . If you do a control click on “LED_Toggle()” the editor will bring up where this token is defined in the file plib_port.h: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#adding-code-to-mainc",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#adding-code-to-mainc"
  },"444": {
    "doc": "Create First Harmony 3 Project",
    "title": "Upload project to SAMC21N Xplained pro Evaluation Kit",
    "content": ". | Do a right mouse click on the project’s name and bring up the Project Properties dialog: . | Under Categories section, select Conf: (sam_c21n_xpro), and in the Configuration section, select the hardware tool and XC32 Compiler toolchain (here v2.41). Click Apply, and then click OK . | Build and run the project: The board’s LED should flash with a 1 second period . | . We have now implemented a heartbeat for future applications. The LED blinking indicates that the application hasn’t frozen or isn’t stuck in a while(1){} loop (e.g.: assert or exception). ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#upload-project-to-samc21n-xplained-pro-evaluation-kit",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#upload-project-to-samc21n-xplained-pro-evaluation-kit"
  },"445": {
    "doc": "Create First Harmony 3 Project",
    "title": "Result",
    "content": "If configured correctly, the LED PC05 on the SAMC21N Xplained Pro Evaluation Kit should now flash ON/OFF at 500 ms intervals. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#result",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#result"
  },"446": {
    "doc": "Create First Harmony 3 Project",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.7.1 | MPLAB Harmony v3 “dev_packs” repo v3.7.0 | MPLAB Harmony v3 “mhc” repo v3.4.0 | MPLAB Harmony Configurator Plugin v3.5.0 | MPLAB X IDE v5.40 | MPLAB XC32 Compiler v2.41 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#note",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#note"
  },"447": {
    "doc": "Create First Harmony 3 Project",
    "title": "References",
    "content": ". | SAMC21N Xplained Pro Evaluation Kit User Guide and Datasheet | MPLAB X IDE User’s Guide see Documentation section at bottom of the page. | User’s Guide direct download | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#references",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#references"
  },"448": {
    "doc": "Create First Harmony 3 Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#reference-links",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#reference-links"
  },"449": {
    "doc": "Create First Harmony 3 Project",
    "title": "Create First Harmony 3 Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html"
  },"450": {
    "doc": "Release notes",
    "title": "Microchip MPLAB® Harmony 3 Release Notes",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#microchip-mplab-harmony-3-release-notes",
    "relUrl": "/release_notes.html#microchip-mplab-harmony-3-release-notes"
  },"451": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.1.0 (September 2020)",
    "content": ". | Repo restructured to move offline documentation to “docs” folder | . New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | Application migration from 8-bit PIC18F to 32-bit SAM D21 | Migration - Full | . | Application migration from 8-bit AVR to 32-bit SAM D21 | Migration - Full | . | Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE | Migration - Full | . | Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers | Basic - Brief Overview and Web link | . | Low Power Application on SAM L10 MCUs using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Low Power Application on SAM E54 MCU using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Create your first Motor Control Application using MPLAB Harmony v3 | Middleware - Brief Overview and Web link | . Updated Doc Pages . | Doc Name | Doc Type - Content | Comments | . | Harmony 3 Packages | Basic - Full | Updated the Harmony 3 Package readme.md with the latest release contents. | . | New video Weblinks added in Basic page | New video Weblinks added in Peripheral page | New doc Weblink added in Peripheral page | . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v110-september-2020",
    "relUrl": "/release_notes.html#quick-docs-release-v110-september-2020"
  },"452": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.0.0 (June 2020)",
    "content": "New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | MPLAB Harmony 3 Configurator (MHC) | Basic - Full | . | MHC Project Graph | Basic - Full | . | MHC Clock Configuration | Basic - Full | . | MHC Pin Configuration | Basic - Full | . | MHC NVIC Configuration | Basic - Full | . | MHC DMA Configuration | Basic - Full | . | MHC Memory Protection Unit Configuration | Basic - Full | . | MHC Code Generation | Basic - Full | . | MHC Window Manager and Log Level | Basic - Full | . | Create First MPLAB Harmony 3 Project | Basic - Full | . | Create “Hello World” application on SAM MCUs | Basic - Full | . | Create “Hello World” application on PIC MCUs | Basic - Full | . | Open an Existing Harmony 3 Project | Basic - Full | . | Harmony 3 Packages | Basic - Full | . | Create IAR or Keil project using MHC | Basic - Full | . | Create new TrustZone Project | Basic - Full | . | Getting Started with MPLAB Harmony v3 on the SAMA5D2 | Basic - Full | . | Getting started with SAM MPU Devices on MPLAB X Tools | Basic - Full | . | Differences between MPLAB Harmony 2 and Harmony 3 | Migration - Brief Overview and Web link | . | MPLAB Harmony 3 Application Development Guide for MPLAB Harmony 2 Users | Migration - Brief Overview and Web link | . | Graphics Applications | Migration - Brief Overview and Web link | . | TCP/IP Applications | Migration - Brief Overview and Web link | . | USB Applications | Migration - Brief Overview and Web link | . | Introduction to MPLAB and Harmony 3 for Atmel Studio and ASF users | Migration - Brief Overview and Web link | . | Porting Application from ASF3 to MPLAB Harmony 3 Framework | Migration - Brief Overview and Web link | . | Atmel START to MPLAB Harmony 3 Migration Guide | Migration - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAMC2x MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM D5x/E5x MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM E70/S70/V70/V71 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM L10 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM D21 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on PIC32MZ EF MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on PIC32MX 470 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on PIC32MK GP MCUs | Peripheral - Brief Overview and Web link | . | Low Power Application on SAMC2x MCUs Using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Low Power Application on SAM L21 MCUs using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Drivers and System Services on SAM E70 | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Drivers on SAM E70 using FreeRTOS | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Middleware on PIC32MZ EF using FreeRTOS | Middleware - Brief Overview and Web link | . | MPLAB Harmony 3 Audio Overview | Middleware - Brief Overview and Web link | . | Creating your first Audio Application | Middleware - Brief Overview and Web link | . | Creating Your first Audio Decoder Application | Middleware - Brief Overview and Web link | . | SD Card Audio Player/Reader Tutorial | Middleware - Brief Overview and Web link | . | Audio-Tone Generation Using a Lookup Table | Middleware - Brief Overview and Web link | . | Audio-Tone Generation from a Text File Stored in an SD Card | Middleware - Brief Overview and Web link | . | SD Card Reader Support to Load Audio Files | Middleware - Brief Overview and Web link | . | Play a WAV Audio File from an SD Card | Middleware - Brief Overview and Web link | . | Display Graphics Support to Select and Play Audio File | Middleware - Brief Overview and Web link | . | Quickstart Prebuilt Graphics Applications | Middleware - Brief Overview and Web link | . | Creating a new Graphics Application | Middleware - Brief Overview and Web link | . | Graphics Quick Start Application Guides | Middleware - Brief Overview and Web link | . | Harmony Graphics Suite User Guide | Middleware - Brief Overview and Web link | . | Create your first USB Device Application | Middleware - Brief Overview and Web link | . | Create Your First USB Host Application | Middleware - Brief Overview and Web link | . | Harmony USB Stack User Guide | Middleware - Brief Overview and Web link | . | Create your first TCP/IP Application | Middleware - Brief Overview and Web link | . | Harmony TCP/IP User Guide | Middleware - Brief Overview and Web link | . | Create a Touch Project in Harmony | Middleware - Brief Overview and Web link | . | Create Touch Surface &amp; Gesture Project in Harmony | Middleware - Brief Overview and Web link | . | Harmony QTouch User Guide | Middleware - Brief Overview and Web link | . | Harmony Crypto Overview - Board Examples | Middleware - Brief Overview and Web link | . | Create Your First WINC Bypass Mode Example | Middleware - Brief Overview and Web link | . | Harmony WINC Driver Architecture | Middleware - Brief Overview and Web link | . | Create your First Bluetooth Application in Harmony | Middleware - Brief Overview and Web link | . Updated Doc Pages . - NA - . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v100-june-2020",
    "relUrl": "/release_notes.html#quick-docs-release-v100-june-2020"
  },"453": {
    "doc": "Release notes",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#reference-links",
    "relUrl": "/release_notes.html#reference-links"
  },"454": {
    "doc": "Release notes",
    "title": "Release notes",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/release_notes.html",
    "relUrl": "/release_notes.html"
  },"455": {
    "doc": "Harmony 3 Quick Docs",
    "title": "Harmony 3 Quick Docs",
    "content": "# MPLAB Harmony 3 Quick Documentation Package MPLAB Harmony 3 is an extension of the MPLAB® ecosystem for creating embedded firmware solutions for Microchip 32-bit SAM and PIC® microcontroller and microprocessor devices. Refer to the following links for more information. This repository contains the MPLAB Harmony 3 Quick Documentation Package. Quick documents are standalone html pages that help to get started developing applications using Microchip 32-bit SAM and PIC MCUs using MPLAB Harmony 3 software framework. [](/quick_docs/source/basic/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; [](/quick_docs/source/migration/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; [](/quick_docs/source/peripheral/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; [](/quick_docs/source/middleware/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ ]() - [**Harmony Basics**](/quick_docs/source/basic/readme.html) : Cover topics that help to get started developing applications using MPLAB Harmony 3 software framework. For Example: MPLAB Harmony 3 Configurator (MHC), Creating the first application on Harmony 3, etc. - [**Migration Guides**](/quick_docs/source/migration/readme.html) : Cover topics that help migrate from other Microchip 32-bit software solutions offering to MPLAB Harmony 3 based solution. For example: Port an existing application from Harmony 2/ASF/START to Harmony 3, etc. - [**Peripheral Libraries**](/quick_docs/source/peripheral/readme.html) : Cover topics that help use MPLAB Harmony peripheral libraries and drivers. For Example: Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs. - [**Middleware Examples**](/quick_docs/source/middleware/readme.html) : Cover topics that help use MPLAB Harmony middleware libraries to implement larger feature rich applications involving integration of multiple technologies. For Example: SD Card Audio Player/Reader Tutorial. The above doc types serve as a reference to evaluate solutions on 32-bit SAM and PIC MCUs by developing applications using MPLAB Harmony 3 software framework on Microchip 32-bit SAM and PIC development boards/kits. **Note**: The doc pages in this repository is a quick source covering the above types. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Refer the specific peripheral/technology repository to find specific documentation. **Repository and documentation support:** - The following table lists the fundamental and few technology specific repositories in MPLAB Harmony 3 Software Framework | Repository | # Documentation | --- | ---| csp | Covers documentation for the peripheral libraries (PLIBs) and related applications that directly control the SAM and PIC peripherals | core | Covers documentation for drivers, system services and the related applications using them. Applications that use the drivers and system services that have advanced capabilities and a higher level of abstraction that gives better hardware independence | usb | Covers documentation for USB library and related applications that demonstrate the capabilities of the MPLAB Harmony USB stack | net | Covers documentation for TCP/IP stack and related applications that demonstrate the capabilities of the MPLAB Harmony TCP/IP stack. These applications use well-known protocols like TCP, UDP, HTTP, SMTP, etc | gfx | Covers documentation for the quick start applications that demonstrates MPLAB Harmony Aria/Legato Graphics Libraries | gfx_apps | Covers documentation for the non quick start applications that demonstrates MPLAB Harmony Aria/Legato Graphics Libraries | audio | Covers documentation for Harmony Audio offerings and applications that demonstrates capabilities of the MPLAB Harmony audio offerings, drivers for hardware codecs that can be connected to development boards, audio decoders, etc | ### Note: The above is not an exhaustive list of all MPLAB Harmony 3 packages and corresponding documentation offerings. Refer the MPLAB Harmony 3 GitHub Launch page to view the complete list of MPLAB Harmony 3 packages. In each of these packages refer the underlying documentation. Refer to the following links for release notes and reference application information. - [Release Notes](/quick_docs/release_notes.html) - [MPLAB® Harmony License](/quick_docs/mplab_harmony_license.html) - [MPLAB® Harmony 3 Quick Docs Wiki](https://github.com/Microchip-MPLAB-Harmony/quick_docs/wiki) ____ [ ]() &nbsp; &nbsp; &nbsp; [ ]() &nbsp; &nbsp; &nbsp; [ ]() &nbsp; &nbsp; [ ]() [ ]() ____ [![License](https://img.shields.io/badge/license-Harmony%20license-orange.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/blob/master/mplab_harmony_license.md) [![Latest release](https://img.shields.io/github/release/Microchip-MPLAB-Harmony/quick_docs.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/releases/latest) [![Latest release date](https://img.shields.io/github/release-date/Microchip-MPLAB-Harmony/quick_docs.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/releases/latest) [![Commit activity](https://img.shields.io/github/commit-activity/y/Microchip-MPLAB-Harmony/quick_docs.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/graphs/commit-activity) [![Contributors](https://img.shields.io/github/contributors-anon/Microchip-MPLAB-Harmony/quick_docs.svg)]() ____ [![Follow us on Youtube](https://img.shields.io/badge/Youtube-Follow%20us%20on%20Youtube-red.svg)](https://www.youtube.com/user/MicrochipTechnology) [![Follow us on LinkedIn](https://img.shields.io/badge/LinkedIn-Follow%20us%20on%20LinkedIn-blue.svg)](https://www.linkedin.com/company/microchip-technology) [![Follow us on Facebook](https://img.shields.io/badge/Facebook-Follow%20us%20on%20Facebook-blue.svg)](https://www.facebook.com/microchiptechnology/) [![Follow us on Twitter](https://img.shields.io/twitter/follow/MicrochipTech.svg?style=social)](https://twitter.com/MicrochipTech) [![](https://img.shields.io/github/stars/Microchip-MPLAB-Harmony/quick_docs.svg?style=social)]() [![](https://img.shields.io/github/watchers/Microchip-MPLAB-Harmony/quick_docs.svg?style=social)]() ",
    "url": "http://localhost:4000/quick_docs/",
    "relUrl": "/"
  }
}
