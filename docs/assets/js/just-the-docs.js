var myVariable = `
{"0": {
    "doc": "License",
    "title": "License",
    "content": "IMPORTANT: READ CAREFULLY . MICROCHIP IS WILLING TO LICENSE THIS INTEGRATED SOFTWARE FRAMEWORK SOFTWARE AND ACCOMPANYING DOCUMENTATION OFFERED TO YOU ONLY ON THE CONDITION THAT YOU ACCEPT ALL OF THE FOLLOWING TERMS. TO ACCEPT THE TERMS OF THIS LICENSE, CLICK “I ACCEPT” AND PROCEED WITH THE DOWNLOAD OR INSTALL. IF YOU DO NOT ACCEPT THESE LICENSE TERMS, CLICK “I DO NOT ACCEPT,” AND DO NOT DOWNLOAD OR INSTALL THIS SOFTWARE. NON-EXCLUSIVE SOFTWARE LICENSE AGREEMENT FOR MICROCHIP MPLAB HARMONY INTEGRATED SOFTWARE FRAMEWORK . This Nonexclusive Software License Agreement (“Agreement”) is between you, your heirs, agents, successors and assigns (“Licensee”) and Microchip Technology Incorporated, a Delaware corporation, with a principal place of business at 2355 W. Chandler Blvd., Chandler, AZ 85224-6199, and its subsidiary, Microchip Technology (Barbados) II Incorporated (collectively, “Microchip”) for Microchip’s MPLAB Harmony Integrated Software Framework (“Software”) and accompanying documentation (“Documentation”). The Software and Documentation are licensed under this Agreement and not sold. U.S. copyright laws and international copyright treaties, and other intellectual property laws and treaties protect the Software and Documentation. Microchip reserves all rights not expressly granted to Licensee in this Agreement. | License and Sublicense Grant. (a) Definitions. As used this Agreement, the following terms shall have the meanings defined below: . (i) \\\"Licensee Products\\\" means Licensee products that use or incorporate Microchip Products. (ii) \\\"Microchip Product\\\" means Microchip 16-bit and 32-bit microcontrollers, digital signal controllers or other Microchip semiconductor products with PIC16 and PIC18 prefix and specifically excepting the CX870 and CY920, which are not covered under this Agreement, that use or implement the Software. (iii) \\\"Object Code\\\" means the Software computer programming code provided by Microchip that is in binary form (including related documentation, if any) and error corrections, improvements and updates to such code provided by Microchip in its sole discretion, if any. (iv) \\\"Source Code\\\" means the Software computer programming code provided by Microchip that may be printed out or displayed in human readable form (including related programmer comments and documentation, if any), and error corrections, improvements, updates, modifications and derivatives of such code developed by Microchip, Licensee or Third Party. (v) \\\"Third Party\\\" means Licensee's agents, representatives, consultants, clients, customers, or contract manufacturers. (vi) \\\"Third Party Products\\\" means Third Party products that use or incorporate Microchip Products. (b) Software License Grant. Subject to the terms of this Agreement, Microchip grants strictly to Licensee a personal, worldwide, non-exclusive, non-transferable limited license to use, modify (except as limited by Section 1(f) below), copy and distribute the Software only when the Software is embedded on a Microchip Product that is integrated into Licensee Product or Third Party Product pursuant to Section 2(d) below. Any portion of the Software (including derivatives or modifications thereof) may not be: . (i) embedded on a non-Microchip microcontroller or digital signal controller; (ii) distributed (in Source Code or Object Code), except as described in Section 2(d) below. (c) Documentation License Grant. Subject to all of the terms and conditions of this Agreement, Microchip grants strictly to Licensee a perpetual, worldwide, non-exclusive license to use the Documentation in support of Licensee’s use of the Software. (d) Sublicense Grants. Subject to terms of this Agreement, Licensee may grant a limited sublicense to a Third Party to use the Software as described below only if such Third Party expressly agrees to be bound by terms of confidentiality and limited use that are no broader in scope and duration than the confidentiality and limited use terms of this Agreement: . (i) Third Party may modify Source Code for Licensee, except as limited by Section 1(f) below. (ii) Third Party may program Software into Microchip Products for Licensee. (iii) Third Party may use Software to develop and/or manufacture Licensee Product. (iv) Third Party may use Software to develop and/or manufacture Third Party Products where either: (x) the sublicensed Software contains Source Code modified or otherwise optimized by Licensee for Third Party use; or (y) the sublicensed Software is programmed into Microchip Products by Licensee on behalf of such Third Party. (v) Third Party may use the Documentation in support of Third Party's authorized use of the Software in conformance with this Section 2(d). (e) Audit. Authorized representatives of Microchip shall have the right to reasonably inspect Licensee’s premises and to audit Licensee’s records and inventory of Licensee Products, whether located on Licensee’s premises or elsewhere at any time, announced or unannounced, and in its sole and absolute discretion, in order to ensure Licensee’s adherence to the terms of this Agreement. (f) License and Sublicense Limitation. This Section 1 does not grant Licensee or any Third Party the right to modify any dotstack™ Bluetooth® stack, profile, or iAP protocol included in the Software. | Third Party Requirements. Licensee acknowledges that it is Licensee’s responsibility to comply with any third party license terms or requirements applicable to the use of such third party software, specifications, systems, or tools, including but not limited to SEGGER Microcontroller GmbH &amp; Co. KG’s rights in the emWin software and certain libraries included herein. Microchip is not responsible and will not be held responsible in any manner for Licensee’s failure to comply with such applicable terms or requirements. | Open Source Components. Notwithstanding the license grants contained herein, Licensee acknowledges that certain components of the Software may be covered by so-called “open source” software licenses (“Open Source Components”). Open Source Components means any software licenses approved as open source licenses by the Open Source Initiative or any substantially similar licenses, including any license that, as a condition of distribution, requires Microchip to provide Licensee with certain notices and/or information related to such Open Source Components, or requires that the distributor make the software available in source code format. Microchip will use commercially reasonable efforts to identify such Open Source Components in a text file or “About Box” or in a file or files referenced thereby (and will include any associated license agreement, notices, and other related information therein), or the Open Source Components will contain or be accompanied by its own license agreement. To the extent required by the licenses covering Open Source Components, the terms of such licenses will apply in lieu of the terms of this Agreement, and Microchip hereby represents and warrants that the licenses granted to such Open Source Components will be no less broad than the license granted in Section 1(b). To the extent the terms of the licenses applicable to Open Source Components prohibit any of the restrictions in this Agreement with respect to such Open Source Components, such restrictions will not apply to such Open Source Components. | Licensee’s Obligations. (a) Licensee will ensure Third Party compliance with the terms of this Agreement. (b) Licensee will not: (i) engage in unauthorized use, modification, disclosure or distribution of Software or Documentation, or its derivatives; (ii) use all or any portion of the Software, Documentation, or its derivatives except in conjunction with Microchip Products; or (iii) reverse engineer (by disassembly, decompilation or otherwise) Software or any portion thereof; or (iv) copy or reproduce all or any portion of Software, except as specifically allowed by this Agreement or expressly permitted by applicable law notwithstanding the foregoing limitations. (c) Licensee must include Microchip’s copyright, trademark and other proprietary notices in all copies of the Software, Documentation, and its derivatives. Licensee may not remove or alter any Microchip copyright or other proprietary rights notice posted in any portion of the Software or Documentation. (d) Licensee will defend, indemnify and hold Microchip and its subsidiaries harmless from and against any and all claims, costs, damages, expenses (including reasonable attorney’s fees), liabilities, and losses, including without limitation product liability claims, directly or indirectly arising from or related to: (i) the use, modification, disclosure or distribution of the Software, Documentation or any intellectual property rights related thereto; (ii) the use, sale, and distribution of Licensee Products or Third Party Products, and (iii) breach of this Agreement. THE FOREGOING STATES THE SOLE AND EXCLUSIVE LIABILITY OF THE PARTIES FOR INTELLECTUAL PROPERTY RIGHTS INFRINGEMENT. | Confidentiality. (a) Licensee agrees that the Software (including but not limited to the Source Code, Object Code and library files) and its derivatives, Documentation and underlying inventions, algorithms, know-how and ideas relating to the Software and the Documentation are proprietary information belonging to Microchip and its licensors (“Proprietary Information”). Except as expressly and unambiguously allowed herein, Licensee will hold in confidence and not use or disclose any Proprietary Information and shall similarly bind its employees and Third Party(ies) in writing. Proprietary Information shall not include information that: (i) is in or enters the public domain without breach of this Agreement and through no fault of the receiving party; (ii) the receiving party was legally in possession of prior to receiving it; (iii) the receiving party can demonstrate was developed by it independently and without use of or reference to the disclosing party’s Proprietary Information; or (iv) the receiving party receives from a third party without restriction on disclosure. If Licensee is required to disclose Proprietary Information by law, court order, or government agency, such disclosure shall not be deemed a breach of this Agreement provided that Licensee gives Microchip prompt notice of such requirement in order to allow Microchip to object or limit such disclosure, Licensee cooperates with Microchip to protect Proprietary Information, and Licensee complies with any protective order in place and discloses only the information required by process of law. (b) Licensee agrees that the provisions of this Agreement regarding unauthorized use and nondisclosure of the Software, Documentation and related Proprietary Rights are necessary to protect the legitimate business interests of Microchip and its licensors and that monetary damages alone cannot adequately compensate Microchip or its licensors if such provisions are violated. Licensee, therefore, agrees that if Microchip alleges that Licensee or Third Party has breached or violated such provision then Microchip will have the right to petition for injunctive relief, without the requirement for the posting of a bond, in addition to all other remedies at law or in equity. | Ownership of Proprietary Rights. (a) Microchip and its licensors retain all right, title and interest in and to the Software and Documentation (“Proprietary Rights”) including, but not limited to: (i) patent, copyright, trade secret and other intellectual property rights in the Software, Documentation, and underlying technology; (ii) the Software as implemented in any device or system, all hardware and software implementations of the Software technology (expressly excluding Licensee and Third Party code developed and used in conformance with this Agreement solely to interface with the Software and Licensee Products and/or Third Party Products); and (iii) all modifications and derivative works thereof (by whomever produced). Further, modifications and derivative works shall be considered works made for hire with ownership vesting in Microchip on creation. To the extent such modifications and derivatives do not qualify as a “work for hire,” Licensee hereby irrevocably transfers, assigns and conveys the exclusive copyright thereof to Microchip, free and clear of any and all liens, claims or other encumbrances, to the fullest extent permitted by law. Licensee and Third Party use of such modifications and derivatives is limited to the license rights described in Section 1 above. (b) Licensee shall have no right to sell, assign or otherwise transfer all or any portion of the Software, Documentation or any related intellectual property rights except as expressly set forth in this Agreement. | Termination of Agreement. Without prejudice to any other rights, this Agreement terminates immediately, without notice by Microchip, upon a failure by License or Third Party to comply with any provision of this Agreement. Further, Microchip may also terminate this Agreement upon reasonable belief that Licensee or Third Party have failed to comply with this Agreement. Upon termination, Licensee and Third Party will immediately stop using the Software, Documentation, and derivatives thereof, and immediately destroy all such copies, remove Software from any of Licensee’s tangible media and from systems on which the Software exists, and stop using, disclosing, copying, or reproducing Software (even as may be permitted by this Agreement). Termination of this Agreement will not affect the right of any end user or consumer to use Licensee Products or Third Party Products provided that such products were purchased prior to the termination of this Agreement. | Dangerous Applications. The Software is not fault-tolerant and is not designed, manufactured, or intended for use in hazardous environments requiring failsafe performance (“Dangerous Applications”). Dangerous Applications include the operation of nuclear facilities, aircraft navigation, aircraft communication systems, air traffic control, direct life support machines, weapons systems, or any environment or system in which the failure of the Software could lead directly or indirectly to death, personal injury, or severe physical or environmental damage. Microchip specifically disclaims (a) any express or implied warranty of fitness for use of the Software in Dangerous Applications; and (b) any and all liability for loss, damages and claims resulting from the use of the Software in Dangerous Applications. | Warranties and Disclaimers. THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. MICROCHIP AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR THE ACCURACY, RELIABILITY OR APPLICATION OF THE SOFTWARE OR DOCUMENTATION. MICROCHIP AND ITS LICENSORS DO NOT WARRANT THAT THE SOFTWARE WILL MEET REQUIREMENTS OF LICENSEE OR THIRD PARTY, BE UNINTERRUPTED OR ERROR-FREE. MICROCHIP AND ITS LICENSORS HAVE NO OBLIGATION TO CORRECT ANY DEFECTS IN THE SOFTWARE. LICENSEE AND THIRD PARTY ASSUME THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE AND DOCUMENTATION PROVIDED UNDER THIS AGREEMENT. | Limited Liability. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL OR EQUITABLE THEORY FOR ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS. The aggregate and cumulative liability of Microchip and its licensors for damages hereunder will in no event exceed $1000 or the amount Licensee paid Microchip for the Software and Documentation, whichever is greater. Licensee acknowledges that the foregoing limitations are reasonable and an essential part of this Agreement. | General. (a) Governing Law, Venue and Waiver of Trial by Jury. THIS AGREEMENT SHALL BE GOVERNED BY AND CONSTRUED UNDER THE LAWS OF THE STATE OF ARIZONA AND THE UNITED STATES WITHOUT REGARD TO CONFLICTS OF LAWS PROVISIONS. Licensee agrees that any disputes arising out of or related to this Agreement, Software or Documentation shall be brought in the courts of State of Arizona. The parties agree to waive their rights to a jury trial in actions relating to this Agreement. (b) Attorneys’ Fees. If either Microchip or Licensee employs attorneys to enforce any rights arising out of or relating to this Agreement, the prevailing party shall be entitled to recover its reasonable attorneys’ fees, costs and other expenses. (c) Entire Agreement. This Agreement shall constitute the entire agreement between the parties with respect to the subject matter hereof. It shall not be modified except by a written agreement signed by an authorized representative of Microchip. (d) Severability. If any provision of this Agreement shall be held by a court of competent jurisdiction to be illegal, invalid or unenforceable, that provision shall be limited or eliminated to the minimum extent necessary so that this Agreement shall otherwise remain in full force and effect and enforceable. (e) Waiver. No waiver of any breach of any provision of this Agreement shall constitute a waiver of any prior, concurrent or subsequent breach of the same or any other provisions hereof, and no waiver shall be effective unless made in writing and signed by an authorized representative of the waiving party. (f) Export Regulation. Licensee agrees to comply with all export laws and restrictions and regulations of the Department of Commerce or other United States or foreign agency or authority. (g) Survival. The indemnities, obligations of confidentiality, and limitations on liability described herein, and any right of action for breach of this Agreement prior to termination shall survive any termination of this Agreement. (h) Assignment. Neither this Agreement nor any rights, licenses or obligations hereunder, may be assigned by Licensee without the prior written approval of Microchip except pursuant to a merger, sale of all assets of Licensee or other corporate reorganization, provided that assignee agrees in writing to be bound by the Agreement. (i) Restricted Rights. Use, duplication or disclosure by the United States Government is subject to restrictions set forth in subparagraphs (a) through (d) of the Commercial Computer-Restricted Rights clause of FAR 52.227-19 when applicable, or in subparagraph (c)(1)(ii) of the Rights in Technical Data and Computer Software clause at DFARS 252.227-7013, and in similar clauses in the NASA FAR Supplement. Contractor/manufacturer is Microchip Technology Inc., 2355 W. Chandler Blvd., Chandler, AZ 85225-6199. | . If Licensee has any questions about this Agreement, please write to Microchip Technology Inc., 2355 W. Chandler Blvd., Chandler, AZ 85224-6199 USA, ATTN: Marketing. Microchip MPLAB Harmony Integrated Software Framework. Copyright © 2015 Microchip Technology Inc. All rights reserved. License Rev. 11/2015 . Copyright © 2015 Qualcomm Atheros, Inc. All Rights Reserved. Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ",
    "url": "http://localhost:4000/quick_docs/mplab_harmony_license.html",
    "relUrl": "/mplab_harmony_license.html"
  },"1": {
    "doc": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "title": "Introduction",
    "content": "This training module describes the following for at91bootstrap, a second-stage bootloader for Microchip Technology Arm®-based Microprocessor Units (MPU), where to get the source code, how to configure, compile and debug using MPLAB® X IDE on windows host. | The following solution is tested based on at91bootstrap version 4.0.7. | The at91bootstrap bootloader can be stored in external NVMs like (SD Memory Card), Multimedia Card (MMC), Embedded Multimedia Card (eMMC), NAND Flash, Serial Flash, QSPI Flash, Data Flash memory). The first-stage bootloader (ROM Boot Code) will load at91bootstrap from external NVM depending on the value of the Boot Configuration Packet. | Click here to learn how to configure Boot Configuration Packet for SAM9X60. Note: To learn about the boot process and first stage boot configuration, refer section:Boot Strategies of the respective MPUs data sheet. | at91bootstrap if configured to do so, will initialize the following peripherals and memory controllers: . | Advanced Interrupt Controller (AIC) | Peripheral I/O Controller (PIO) | Power Management Controller (PMC) | Clock Generator (CKGR) | Static Memory Controller (HSMC) | NAND Flash Controller (NFC) | Multiport DDR-SDRAM Controller (MPDDRC) | Secure Digital Multimedia Card Controller (SDMMC) | . | at91bootstrap is written and maintained by Microchip Technology and hosted on GitHub. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#introduction",
    "relUrl": "/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#introduction"
  },"2": {
    "doc": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "title": "Required software and hardware tools",
    "content": "Details . This document is written with the assumption that the user is aware of the external NVMS &amp; DDR memory available in the respective MPU boards (Like Evaluation Kits, Curiosity Boards, SIP or SOM) by reading the respective user guide. | To build/debug at91bootstrap using MPLAB® X IDE on windows host, the following tools should be installed properly: . | Download and install MPLAB® X IDE. | Download and install XC32 Compiler. | . | User can use below hardware tools: . | SAM9X60 Evaluation kit. (or) SAM9X60 Curiosity Development Board. | External J32 debugger if SAM9X60 Curiosity Development Board is used. | SAMA7G54 Evaluiation Kit | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#required-software-and-hardware-tools",
    "relUrl": "/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#required-software-and-hardware-tools"
  },"3": {
    "doc": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "title": "Getting at91bootstrap Source Code",
    "content": "Details . | Create a Project Directory: Create a project directory to keep all the sources together for a given project. For the purpose of this tutorial topic, the created project directory is Harmony3. | Get at91bootstrap: Get the complete source code of at91bootstrap by either of the following ways: . | If you have git installed , clone the repo into the project directory by using the command: . $ git clone git@https://github.com/linux4sam/at91bootstrap . | If you don’t have git installed, then Download at91bootstrap and unzip into your project directory. | Note: Use at91bootstrap version v4.0.7 or higher | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#getting-at91bootstrap-source-code",
    "relUrl": "/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#getting-at91bootstrap-source-code"
  },"4": {
    "doc": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "title": "Configure, build and debug at91bootstrap",
    "content": "Details . User should follow the below steps to build the at91bootstrap either to debug the harmony application executed from QSPI on MPLAB® X IDE or to run the harmony application executed from QSPI : . | Preparing the build Environment. | Configure the at91bootstrap. | Building the at91bootstrap. | Debugging the at91bootstrap. | . 1. Preparing the build Environment . Details . 1.1. Open at91Bootstrap project: To begin, launch MPLAB® X IDE and then go to File –&gt; Open Project –&gt;choose downloaded at91bootstrap project. Now set it as main project. &lt;img src = \\\"images/1_1a.png\\\" align=\\\"middle\\\"&gt; . 1.2. Compiler setting: User can use XC32 compiler to build at91bootstrap. Go to Project –&gt; Properties –&gt; Makefile —&gt; Copy the XC32 installation path and update it in the build/debug and clean command –&gt; Apply —&gt; ok . E.g. Build/Debug command: make CROSS_COMPILE=”C:/Program Files/Microchip/xc32/v4.30/bin/bin/pic32c-“ Clean command: make mplabclean CROSS_COMPILE=”C:/Program Files/Microchip/xc32/v4.30/bin/bin/pic32c-“ . 2. Configure the at91bootstrap . Details . The at91bootstrap can be configured to debug harmony application executed from QSPI flash on MPLAB® X IDE or to run harmony application from QSPI flash by using KCONFIG. 2.1 Configure at91bootstrap to debug harmony application executed from QSPI flash on MPLAB® X IDE . Details . To configure at91bootstrap to debug harmony application executed from QSPI flash on MPLAB® X IDE, go to Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; (board)df_qspi_uboot_defconfig –&gt; Open. Then perform the following changes: . | Primary Operation –&gt; Load and Stop. | Flash Memory –&gt; QSPI Configuration –&gt; eXecute In Place | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup: . | Flash offset –&gt; QSPI offset where a user wants to flash the application. | Demo app image size –&gt; Size of the app image. | External RAM address to load Demo-App image –&gt; Provide the QSPI starting address of the application. It should match the .text load address in your application linker script. External QSPI address of SAM9X60 board starts from 0x70000000 – 0x708000000. Please refer to the data sheet for more details. External QSPI address of SAMA7G5 board starts from 0x20000000 – 0x280000000. Please refer to the data sheet for more details. | . | . An example configuration for SAMA7G5-EK is shown below. Now Click Apply –&gt; OK. The boot file(at91bootstrap.elf) generated by doing this kconfig, can be used to debug harmony application executed from QSPI flash on MPLAB® X IDE. 2.2. Configure at91bootstrap to run harmony application from QSPI flash . Details . To configure at91bootstrap to debug harmony application executed from QSPI flash on MPLAB® X IDE this, go to Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; (board)df_qspi_uboot_defconfig –&gt; Open. Then perform the following changes: . | Primary Operation –&gt; Load and Launch next software. | Flash Memory –&gt; QSPI Configuration –&gt; eXecute In Place | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup: . | Flash offset –&gt; QSPI offset where a user wants to flash the application. | Demo app image size –&gt; Size of the app image. | External RAM address to load Demo-App image –&gt; Provide the QSPI starting address of the application. It should match the .text load address in your harmony application linker script. External QSPI address of SAM9X60 board starts from 0x70000000 – 0x708000000. Please refer to the data sheet for more details. External QSPI address of SAMA7G5 board starts from 0x20000000 – 0x280000000. Please refer to the data sheet for more details. | . | . An example configuration for SAMA7G5-EK is shown below. Now Click Apply –&gt; OK. The boot file(at91bootstrap.elf) generated by doing this kconfig, can be used to run harmony application executed from QSPI flash. 3. Building the at91bootstrap . Details . To build the at91bootstrap go to project –&gt; Clean and build or simply click the build icon in the IDE. Note: When building using XC32 compiler, if a user doesn’t have XC32 pro compiler, a warning saying cannot optimize size will pop up in the compiler output window as follows. To avoid this either use XC32 pro compiler or just ignore this. Once the build is successful, you will get the build success message in the IDE as shown in the above Image. Now user will be able to see the boot.bin file in the project directory/build/binaries. boot.bin file is the at91bootstrap file. 4. Debugging the at91bootstrap . Details . To debug the at91bootstrap, go to project –&gt; Set as main project. Then click project –&gt; Debug or simply click the debug icon in the IDE. Now user can start debugging the at91bootstrp by clicking the debug symbols available in the IDE like Step into, Reset, Step over etc. When debugging the application, serial console outputs can be monitored by connecting windows host with the board (Eg: SAM9X60-EK) through a terminal emulation program. For example, refer to this link to download terminal emulation program and follow the steps to establish a serial communication with SAM9X60-EK. An example image showing the serial console output while debugging at91bootstrap is shown below. &lt;/details&gt; . ",
    "url": "http://localhost:4000/quick_docs/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#configure-build-and-debug-at91bootstrap",
    "relUrl": "/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#configure-build-and-debug-at91bootstrap"
  },"5": {
    "doc": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "title": "Note",
    "content": ". | Click here to learn how to configure first stage bootloader for SAM9X60 MPU | Click here to develop a harmony based application executed from QSPI for SAM9X60 MPU using MPLAB® X IDE | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#note-1",
    "relUrl": "/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#note-1"
  },"6": {
    "doc": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#reference-links",
    "relUrl": "/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html#reference-links"
  },"7": {
    "doc": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "title": "Configure at91bootstrap Second Stage Bootloader to enable QSPI XIP on MPUs",
    "content": "                                                                                                      . Note: . This guide will teach you how to configure at91bootstrap(Second Stage Bootloader) to enable QSPI-XIP on MPUs. | SAM9X60 boot process click here | SAM9X60 data sheet | SAMA7G54 Evaluation kit | SAMA7G5 series data sheet | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html",
    "relUrl": "/source/basic/configure_at91bootstrap_to_enable_qspi_xip_mpus/readme.html"
  },"8": {
    "doc": "Create First Harmony 3 Project",
    "title": "Create First MPLAB Harmony 3 Project",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#create-first-mplab-harmony-3-project",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#create-first-mplab-harmony-3-project"
  },"9": {
    "doc": "Create First Harmony 3 Project",
    "title": "Overview",
    "content": "The purpose of this tutorial is to show you how to use Microchip MPLAB® Harmony 3 to create a simple “heartbeat” LED application that flashes an LED using the MPLAB® X IDE and the MPLAB® Harmony Configurator (MHC). As a bonus, you can reuse the heartbeat LED application in future projects as a simple indicator of system health. This tutorial focuses on direct use of MPLAB® Harmony peripheral libraries to build an application. If you are interested in using interoperable MPLAB® Harmony drivers, services, or middleware in your application, please see “Creating Your First Project – Harmony” when you’ve finished with this tutorial. The application can be defined by the following flowchart: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#overview",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#overview"
  },"10": {
    "doc": "Create First Harmony 3 Project",
    "title": "Required Software",
    "content": "The instructions in this tutorial assume that you have already installed following software. | MPLAB X Integrated Development Environment | MPLAB XC32/32++ C Compiler | MPLAB Harmony Configurator | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#required-software",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#required-software"
  },"11": {
    "doc": "Create First Harmony 3 Project",
    "title": "Required Hardware",
    "content": "The instructions in this tutorial use SAMC21N Xplained Pro Evaluation Kitand it has one Yellow Color user LED (PC05) connected GPIO. Similar kits will work similarly, but the setup and steps may not be exactly as described. Setup: The following figure shows the hardware setup details: . | Connect SAMC21N Xplained Pro Evaluation Kit micro USB port to PC using a micro USB cable . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#required-hardware",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#required-hardware"
  },"12": {
    "doc": "Create First Harmony 3 Project",
    "title": "Procedure",
    "content": "The following are the steps to create, generate, build and flash LED Blinking application. Before proceeding, make sure you have downloaded the required Harmony 3 packages (for directions, the MPLAB® Harmony Configurator (MHC) User’s Guide) and setup the required hardware as shown previously. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#procedure",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#procedure"
  },"13": {
    "doc": "Create First Harmony 3 Project",
    "title": "Create a new project",
    "content": ". | Open the MPLAB® X IDE. | Create a New Project by clicking the New Project icon or by selecting File &gt; New Project. | In the New Project window select 32-Bit MPLAB® Harmony 3 Project. | Click Next. Note: If the option 32-Bit MPLAB Harmony v3 Project is not available, install the MPLAB® Harmony 3 Launcher plug-in from Tools &gt; Plugins &gt; Available Plugins before continuing with this demonstration. | Enter the path to the folder in which you downloaded the MPLAB® Harmony 3 packages in the Framework Path edit box. | In the Project Setting dialog window, fill in or select the information needed as follows: . | Location: Create a “MyBlinky” folder in the location of your choice. | Folder: Project Folder name i.e. “sam_c21n_xpro” | Name: Project Name i.e. “my_blinky_sam_c21n_xpro” | . | In the Configuration Settings dialog window, enter the configuration name as “sam_c21n_xpro” and select the Target Device ATSAMC21N18A from the drop-down menu as shown below. | Click Finish. | When the Configuration Database Setup dialog appears, just click Launch as shown below to open MPLAB® Harmony Configurator plugin. If the below dialog window doesn’t appear then MHC can be launched by selecting MPLAB® Harmony 3 Configurator under Tools ? Embedded. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#create-a-new-project",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#create-a-new-project"
  },"14": {
    "doc": "Create First Harmony 3 Project",
    "title": "Setup MPLAB® Harmony Project Configurator to Generate Code",
    "content": ". | From the “Available Components” panel of MHC (on the left side of the MHC window), drag and drop the TC0 peripheral into the Components Graph: . | Click on the “TC0” component and configure as below and in the figure: . | Select Prescaler value to “Prescaler: GCLK_TC/1024” | Set Timer Period (Milli Sec) to “500” | . This will toggle the LED every 0.5 seconds, producing a LED blink every second. | Launch the Pin Configuration manager from the MHC’s Tools menu: . | Setup pin “PC05” as the board’s LED, set custom name as “LED” and Direction as “Out”: . This is necessary because the project doesn’t use a Board Support Package (BSP). | Generate the application’s code for the first time. | Select the Generate Code button of MHC’s window . | Save the project’s configuration (any name will do for the .xml file): . | Select default as the Merge Strategy (i.e. USER_ALL) and click Generate . Now the project’s initial software has been configured. Note: Here is a brief explanation of the different merge strategies that are available: . | ALL: The user will be prompted with a merge window for all generated files. This includes files that have no user modifications but are changed because of changes in MHC configuration or component updates. (This choice is always the safest.) | USER_ALL: The user will always be prompted with a merge window for all generated files that contain user modifications. | USER_RECENT: The user will be prompted with a merge window for all generated files that contain user modifications. | OVERWRITE: All generated file content will be replaced by the contents of this generate operation. All user changes will be overwritten. | . | Let’s examine the software just created in the Projects panel of MPLAB® X IDE Header Files are shown on the top and Source Files are shown on the bottom. Note: The icons used in this picture of the project’s organization make it seem like the files of the project are organized this way on disk. In fact, this is a virtual organization of these files, not an actual one. On disk, the source and header files are not separated. The following table describes the Header and Source files generated from the sample project: . | # | Source File | Descriptions | . | 1 | definitions.h | Provides configuration-specific definitions | . | 2 | exceptions.c | Implements exception handlers | . | 3 | initialization.c | Implements SYS_Initialize to initializes all libraries and applications | . | 4 | interrupts.c | Implements the interrupt vectors | . | 5 | peripheral [libraries] | Implements peripheral libraries used by the project | . | 6 | startup.c | Startup code for the application | . If you click on the Files tab you will see the actual organization of these files on your drive: . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#setup-mplab-harmony-project-configurator-to-generate-code",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#setup-mplab-harmony-project-configurator-to-generate-code"
  },"15": {
    "doc": "Create First Harmony 3 Project",
    "title": "Adding Code to main.c",
    "content": "Double click on main.c to bring up an editor window and update it to obtain the following code: . #include \\\"definitions.h\\\" // SYS function prototypes static bool volatile bToggleLED = false; // This function is called after period expires void TC0_CH0_TimerInterruptHandler(TC_TIMER_STATUS status, uintptr_t context) { bToggleLED = true; } // ***************************************************************************** // ***************************************************************************** // Section: Main Entry Point // ***************************************************************************** // ***************************************************************************** int main ( void ) { // Initialize all modules SYS_Initialize(NULL); // Register callback function for CH0 period interrupt TC0_TimerCallbackRegister(TC0_CH0_TimerInterruptHandler, (uintptr_t)NULL); // Start the timer channel 0 TC0_TimerStart(); while ( true ) { if ( bToggleLED ) { bToggleLED = false; LED_Toggle(); } } // Execution should not come here during normal operation return EXIT_FAILURE; } . If you do a control click on “LED_Toggle()” the editor will bring up where this token is defined in the file plib_port.h: . &lt;img src = \\\"images/code1.png\\\" width=\\\"700\\\" height=\\\"150\\\" align=\\\"middle\\\"&gt; &lt;img src = \\\"images/code2.png\\\" width=\\\"700\\\" height=\\\"210\\\" align=\\\"middle\\\"&gt; . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#adding-code-to-mainc",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#adding-code-to-mainc"
  },"16": {
    "doc": "Create First Harmony 3 Project",
    "title": "Upload project to SAMC21N Xplained pro Evaluation Kit",
    "content": ". | Do a right mouse click on the project’s name and bring up the Project Properties dialog: . | Under Categories section, select Conf: (sam_c21n_xpro), and in the Configuration section, select the hardware tool and XC32 Compiler toolchain (here v2.41). Click Apply, and then click OK . | Build and run the project: The board’s LED should flash with a 1 second period . | . We have now implemented a heartbeat for future applications. The LED blinking indicates that the application hasn’t frozen or isn’t stuck in a while(1){} loop (e.g.: assert or exception). ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#upload-project-to-samc21n-xplained-pro-evaluation-kit",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#upload-project-to-samc21n-xplained-pro-evaluation-kit"
  },"17": {
    "doc": "Create First Harmony 3 Project",
    "title": "Result",
    "content": "If configured correctly, the LED PC05 on the SAMC21N Xplained Pro Evaluation Kit should now flash ON/OFF at 500 ms intervals. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#result",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#result"
  },"18": {
    "doc": "Create First Harmony 3 Project",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#note-1",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#note-1"
  },"19": {
    "doc": "Create First Harmony 3 Project",
    "title": "References",
    "content": ". | SAMC21N Xplained Pro Evaluation Kit User Guide and Datasheet | MPLAB X IDE User’s Guide see Documentation section at bottom of the page. | User’s Guide direct download | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#references",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#references"
  },"20": {
    "doc": "Create First Harmony 3 Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html#reference-links",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html#reference-links"
  },"21": {
    "doc": "Create First Harmony 3 Project",
    "title": "Create First Harmony 3 Project",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_first_harmony_3_project/readme.html",
    "relUrl": "/source/basic/create_first_harmony_3_project/readme.html"
  },"22": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Create “Hello World” application on PIC MCUs",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#create-hello-world-application-on-pic-mcus",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#create-hello-world-application-on-pic-mcus"
  },"23": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Introduction",
    "content": "MPLAB Harmony v3 is a software development framework consisting of compatible and interoperable modules that include peripheral libraries (PLIBs), drivers, system services, middleware and third-party libraries. The MPLAB Harmony Configurator (MHC) is a GUI-based tool that provides an easy way to enable and configure various MPLAB Harmony modules. The MHC is a plug-in to the MPLAB X Integrated Development Environment (IDE). This page describes how to create an application on a 32-bit PIC32 microcontroller (MCU) using MHC with MPLAB Harmony v3 modules. This application sends a “Hello World!” string to a console running on a computer. For this demonstration, the following MPLAB Harmony v3 modules are used and configured using the MHC: . | Clock PLIB using the Clock Manager to configure the microcontroller clock. | GPIO PLIB using the Pin Manager to configure the microcontroller I/Os. | UART PLIB to configure USART peripheral as serial port. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#introduction",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#introduction"
  },"24": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Required Software",
    "content": "The instructions in this tutorial assume that you have already installed following software. | MPLAB X Integrated Development Environment | MPLAB XC32/32++ C Compiler | MPLAB Harmony Configurator | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#required-software",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#required-software"
  },"25": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Required Hardware",
    "content": "The instructions in this tutorial use Curiosity PIC32MZ EF 2.0 Development Board. Similar kits will work similarly, but the setup and steps may not be exactly as described. Setup: The following figure shows the hardware setup details: . | Connect Curiosity PIC32MZ EF 2.0 Development Board micro USB port to PC using a micro USB cable . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#required-hardware",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#required-hardware"
  },"26": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Procedure",
    "content": "Step 1: Creating an MPLAB Harmony v3-based Project: . | Launch MPLAB X IDE. | In MPLAB X IDE, select File &gt; New Project (or click the New Project icon). | In the New Project window, select Microchip Embedded in the Categories pane and select 32-bit MPLAB Harmony 3 Project in the Projects pane. Note: If the option 32-Bit MPLAB Harmony v3 Project is not available, install the MPLAB® Harmony 3 Launcher plug-in from Tools &gt; Plugins &gt; Available Plugins before continuing with this demonstration. | Click Next. | Under Framework Selection, in the Manage Framework section, enter the Framework Path (Path to the folder in which the MPLAB Harmony v3 packages are downloaded). For this demonstration, the MPLAB Harmony v3 packages are downloaded in the following location: D:/microchip/github/h3. Note: For this demonstration application, the following MPLAB Harmony v3 packages are required: mhc, dev_packs, and csp. The MPLAB Harmony 3 Content Manager tool simplifies the downloading of the MPLAB Harmony v3 packages. If these packages are not downloaded, then the user can use the MPLAB Harmony 3 Content Manager tool to download them onto their computer. | Click Next. | Under Project Settings, in the Name and Location section, enter the following details: . | Location: Indicates the path to the root folder of the new project. All project files will be placed in this folder. The project location can be any valid path, for example: D:/microchip/github/h3/tech_brief. | Folder: Indicates the name of the MPLAB X IDE folder. Enter hello_world to create a hello_world.X folder. | Name: Enter name of the project as hello_world_pic32mz_ef_curiosity2. This name will be displayed in the MPLAB X IDE. | Path: The path information will be updated as and when users make changes to other fields. | . Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | Click Next. | Under the Configuration Settings section, enter the details as given below: . | Name: Enter the configuration name as pic32mz_ef_curiosity2. | Target Device: Choose PIC32MZ2048EFM144. | . Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | Click Finish to launch the MHC. Note: After clicking the Finish button, if MHC does not launch, users can launch it by selecting Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator from the MPLAB X IDE. | Before launching the MHC, the Configuration Database Setup window will be displayed, where the Device Family Pack (DFP) and Cortex Microcontroller Software Interface Standard (CMSIS) path can be changed, if required. For this demonstration, the default settings are used. | Click Launch. | The MHC plug-in will open in a new window. The image below highlights different section available in the MHC. Note: For this demonstration, Stand-alone mode is used for the MHC Window Manager by changing the settings in the MPLAB X IDE, by selecting &gt; Tools &gt; Options &gt; Plugins &gt; MPLAB Harmony Configurator 3 &gt; Window Manager. If the Native Netbeans mode of the MHC is required, users can set it as default mode by configuring it. | . Step 2: Adding and configuring the MPLAB Harmony components: . | From Tools, select Clock Configuration to launch the Clock Easy View. The Clock Easy View window will be displayed inside the MHC Window. | In the Clock Easy View window, scroll to the right and verify that the SYSCLK is set to 200 MHz. | To add and configure the UART Peripheral Library follow these steps: . | Under Available Components, expand Peripherals and then expand the options available for UART. | Double-click on UART6 to add it to the project graph | . | Select the UART6 Peripheral Library in the Project Graph, and in the Configuration Options window. Configure it as follows: . | Verify that the default baud rate is set to 115,200 | . | Configure the UART pins in the Pin Settings window. In the MHC, select Tools &gt; Pin Configuration to open the Pin Settings window. | The MHC Pin Settings window will open and display these options: Pin Diagram, Pin Table, and Pin Settings. Note: According to schematic of the Curiosity PIC32MZ EF 2.0 Development Board, the PICkit™ On Board 4 (PKOB4) can be used as Virtual Com Port to have serial communication between PIC32MZ EF device and connected computer console. For that, RF2 (Pin #79) of the PIC32MZ EF must be configured as U6TX. | Click the Pin Settings tab and configure the RF2 pin as U6TX. | The same pin (RF2) can be configured by clicking the Pin Table tab. Note: The demonstration will use the UART PLIB for printing messages on the serial terminal. Therefore, in the UART6 configuration, only the transmit pin is configured and the receive pin is not configured. | . Step 3: Generating the Code . | In MHC click on the Save MHC State icon to save the MHC state before generating the code. | Save the configuration in its default location, when prompted. | Click on the generate code icon to generate the code. | The Modified Configuration window is prompted, click Save to save the configuration. | In the Generate Project window, click Generate to generate the code. | The above step triggers these actions in MHC: . | Generate the code as per the configurations done. | Place the generated code and required MPLAB Harmony framework files in the MPLAB Harmony project directory, in this case: D:/microchip/github/h3/tech_brief/firmware/src. | Add all generated codes and MPLAB Harmony framework files into the MPLAB Harmony project, as shown in the following figure. | . Note: The MPLAB Harmony project will be shown in another window as this project is in Standalone mode. | The generated code descriptions are as follows: . | definitions.h: Includes all the header files required for the project. | initialization.c: Initializes all the MPLAB Harmony modules used in the application. | interrupts.c: Contains the mapping of all the interrupt vectors on the selected device. | main.c: A function call to initialize the system present in this file. The user needs to develop their application in this file. | peripheral: All peripheral source codes are added in this folder. | . Note: The MHC provides an option to change the generated file name, and if this option is not used, by default, the file name main.c is generated. | . Step 4: Developing and Running an Application . To develop and run an application, follow these steps: . | Developing an application: For this demo application, add the highlighted codes (as shown in image below) in the main.c file. This will send the “Hello World!” string to the console running on the PC. The following code is provided for convenience: . uint8_t buffer[]= \\\"Hello World!\\r\\n\\\"; UART6_Write(&amp;buffer[0], sizeof(buffer)); . | Selecting Hardware Tool and Compiler: In the MPLAB X IDE Project Properties window perform these actions: | Under Categories section, select Conf: (pic32mz_ef_curiosity2), and in the Configuration section, select the hardware tool and compiler toolchain. | Click Apply, and then click OK. | Connecting Hardware: Connect a micro-USB cable between the DEBUG USB on the board and the PC. This enables the programming of the microcontroller and provide a serial connection with the console device (computer). | Setting up the Serial Console: Open a terminal application, such as Tera Term on the PC and perform the serial port setup. Below is the default setup details for Tera Term. | Programing and Running the Application: Build and program the Curiosity PIC32MZ EF 2.0 Development Board by using the MPLAB X IDE. | Select MPLAB PKoB 4 under Curiosity/Starter Kits (PKOB4) when prompted. | Observing the Output: Observe the “Hello World!” string on the console. If the desired output is not found on the console, press the Reset button on the Curiosity Development board to reset the device, and ensure that the UART message is communicated. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#procedure",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#procedure"
  },"27": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#note-1",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#note-1"
  },"28": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html#reference-links",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html#reference-links"
  },"29": {
    "doc": "Create Hello World application on PIC MCUs",
    "title": "Create Hello World application on PIC MCUs",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_pic_mcus/readme.html",
    "relUrl": "/source/basic/create_hello_world_pic_mcus/readme.html"
  },"30": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Create “Hello World” application on SAM MCUs",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#create-hello-world-application-on-sam-mcus",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#create-hello-world-application-on-sam-mcus"
  },"31": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Introduction",
    "content": "MPLAB Harmony v3 is a software development framework consisting of compatible and interoperable modules that include peripheral libraries (PLIBs), drivers, system services, middleware and third-party libraries. The MPLAB Harmony Configurator (MHC) is a GUI-based tool that provides an easy way to enable and configure various MPLAB Harmony modules. The MHC is a plug-in to the MPLAB X Integrated Development Environment (IDE). This page explains how to create a simple application on an Arm® Cortex®-based SAM Microcontroller (MCU) using the MHC with MPLAB Harmony v3 modules. This application sends a “Hello World!” string to a console running on a computer. For this demonstration, the following MPLAB Harmony v3 modules are used and configured using the MHC: . | Clock PLIB using the Clock Manager to configure the microcontroller clock. | PORT PLIB using the Pin Manager to configure the microcontroller I/Os. | Serial Communication (SERCOM) USART PLIB to configure USART peripheral as serial port. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#introduction",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#introduction"
  },"32": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Required Software",
    "content": "The instructions in this tutorial assume that you have already installed following software. | MPLAB X Integrated Development Environment | MPLAB XC32/32++ C Compiler | MPLAB Harmony Configurator | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#required-software",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#required-software"
  },"33": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Required Hardware",
    "content": "The instructions in this tutorial use SAMD21 Xplained Pro board and it has one Yellow Color user LED (PB30) connected GPIO. Similar kits will work similarly, but the setup and steps may not be exactly as described. Setup: The following figure shows the hardware setup details: . | Connect SAMD21 Xplained Pro Board micro USB port to PC using a micro USB cable . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#required-hardware",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#required-hardware"
  },"34": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Procedure",
    "content": "Step 1: To create an MPLAB Harmony v3-based project, follow these steps: . | Launch MPLAB X IDE. | In MPLAB X IDE, select File &gt; New Project (or click the New Project icon). | In the New Project window, select Microchip Embedded in the Categories pane and select 32-bit MPLAB Harmony 3 Project in the Projects pane. Note: If the option 32-Bit MPLAB Harmony v3 Project is not available, install the MPLAB® Harmony 3 Launcher plug-in from Tools &gt; Plugins &gt; Available Plugins before continuing with this demonstration. | Click Next. | Under the Manage Framework section, enter the Framework Path (Path to the folder in which the MPLAB Harmony v3 packages are downloaded). For this demonstration, the MPLAB Harmony v3 packages are downloaded in the following location: D:/microchip/github/h3. Note: For this demonstration application, the following MPLAB Harmony v3 packages are required: mhc, dev_packs, and csp. The MPLAB Harmony 3 Content Manager tool simplifies the downloading of the MPLAB Harmony v3 packages. If these packages are not downloaded, then the user can use the MPLAB Harmony 3 Content Manager tool to download them onto their computer. | Click Next. | Under the Name and Location section, enter the following details: . | Location: Indicates the path to the root folder of the new project. All project files will be placed in this folder. The project location can be any valid path, for example: D:/microchip/github/h3/tech_brief. | Folder: Indicates the name of the MPLAB X IDE folder. Enter hello_world to create a hello_world.X folder. | Name: Enter name of the project as hello_world_sam_d21_xpro. This name will be displayed in the MPLAB X IDE. | Path: The path information will be updated as and when users make changes to other fields. | . Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | Click Next. | Under the Configuration Settings section, enter the details as given below: . | Name: Enter the configuration name as sam_d21_xpro | Target Device: Choose ATSAMD21J18A. | . Note: Click the Show Visual Help button to open a contextual help window for a detailed description of various fields in the Project Settings. | Click Finish to launch the MHC. Note: After clicking the Finish button, if MHC does not launch, users can launch it by selecting Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator from the MPLAB X IDE. | Before launching the MHC, the Configuration Database Setup window will be displayed, where the Device Family Pack (DFP) and Cortex Microcontroller Software Interface Standard (CMSIS) path can be changed, if required. For this demonstration, the default settings are used. | Click Launch. | The MHC plug-in will open in a new window. The image below highlights different section available in the MHC. Note: For this demonstration, Stand-alone mode is used for the MHC Window Manager by changing the settings in the MPLAB X IDE, by selecting &gt; Tools &gt; Options &gt; Plugins &gt; MPLAB Harmony Configurator 3 &gt; Window Manager. If the Native Netbeans mode of the MHC is required, users can set it as default mode by configuring it. | . Step 2: To add and configure the MPLAB Harmony components using the MHC, follow these steps: . | From Tools, select Clock Configuration to launch the Clock Easy View. The Clock Easy View window will be displayed inside the MHC Window. | In the Clock Easy View window, scroll to the right and verify that the Main Clock is set to 48 MHz. | To add and configure the USART Peripheral Library follow these steps: . | Under Available Components, expand Peripherals and then expand the options available for SERCOM. | Double-click on the SERCOM3 to add it to the project | . | Select the SERCOM3 Peripheral Library in the Project Graph, and in the Configuration Options window, configure it as follows: . | SERCOM Operation mode is set for USART with Internal Clock (default setting). | Clear Receive Enable, as the string will only be transmitted in this example. | Set the Baud Rate to 9600. | For Transmit Pinout choose SERCOM PAD[0] (default setting). | By default, the Receive Pinout is SERCOM PAD[0]. If the Receive Pinout feature is disabled, it will not affect the operation. | . | Configure the USART pin in the Pin Settings: In the MHC, select Tools &gt; Pin Configuration to open the Pin Settings window. | The MHC Pin Settings window will open and display these options: Pin Diagram, Pin Table, and Pin Settings. Note: According to the schematic of the SAMD21 Xplained Pro board, the on-board Embedded Debugger (EDBG) can be used as Virtual Com Port to have serial communication between the SAMD21 device and a connected computer console. Therefore, the PA22 (Pin #43) of the SAMD21 must be configured as USART_TX (SERCOM3 PAD0). | Click the Pin Settings tab and configure the PA22 pin as SERCOM3_PAD0. | The same pin (PA22) can be configured by clicking the Pin Table tab. Note: . | The USART_TX function (Transmit Pinout) is by default configured to be on SERCOM3 PAD0, for additional information, refer to MHC SERCOM Configuration. | In the SERCOM3 USART configuration, the USART is enabled only for transmit functionality. Therefore, the USART receive pin is not configured. | . | . Step 3: To generate the code, follow these steps: . | In MHC click on the Save MHC State icon to save the MHC state before generating the code. | Save the configuration in its default location, when prompted. | Click on the generate code icon to generate the code. | The Modified Configuration window is prompted, click Save to save the configuration. | In the Generate Project window, click Generate to generate the code. | The above step triggers these actions in MHC: . | Generate the code as per the configurations done. | Place the generated code and required MPLAB Harmony framework files in the MPLAB Harmony project directory, in this case: D:/microchip/github/h3/tech_brief/firmware/src. | Add all generated codes and MPLAB Harmony framework files into the MPLAB Harmony project, as shown in the following figure. | . Note: The MPLAB Harmony project will be shown in another window as this project is in Standalone mode. | The generated code descriptions are as follows: . | definitions.h: Includes all the header files required for the project. | initialization.c: Initializes all the MPLAB Harmony modules used in the application. | interrupts.c: Contains the mapping of all the interrupt vectors on the selected device. | main.c: A function call to initialize the system present in this file. The user needs to develop their application in this file. | peripheral: All peripheral source codes are added in this folder. | . Note: The MHC provides an option to change the generated file name, and if this option is not used, by default, the file name main.c is generated. | . Step 4: To develop and run an application, follow these steps: . | Developing an application: For this demo application, add the highlighted codes (as shown in image below) in the main.c file. This will send the “Hello World!” string to the console running on the PC. The following code is provided for convenience: . uint8_t buffer[]= \\\"Hello World!\\r\\n\\\"; SERCOM3_USART_Write(&amp;buffer[0], sizeof(buffer)); . | Selecting Hardware Tool and Compiler: In the MPLAB X IDE Project Properties window perform these actions: | Under Categories section, select Conf: (sam_d21_xpro), and in the Configuration section, select the hardware tool and compiler toolchain. | Click OK. | Connecting Hardware: Connect a micro-USB cable between the DEBUG USB on the board and the PC. This enables the programming of the microcontroller and provide a serial connection with the console device (computer). | Setting up the Serial Console: Open a terminal application, such as Tera Term on the PC and perform the serial port setup. Below is the default setup details for Tera Term. | Programing and Running the Application: Build and program the SAMD21 Xplained Pro kit by using the MPLAB X IDE. | Observing the Output: Observe the “Hello World!” string on the console. If the desired output is not found on the console, press the Reset button on the Xplained Pro board to reset the device, and ensure that the UART message is communicated. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#procedure",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#procedure"
  },"35": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#note-1",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#note-1"
  },"36": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html#reference-links",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html#reference-links"
  },"37": {
    "doc": "Create Hello World application on SAM MCUs",
    "title": "Create Hello World application on SAM MCUs",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_hello_world_sam_mcus/readme.html",
    "relUrl": "/source/basic/create_hello_world_sam_mcus/readme.html"
  },"38": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Creating an IAR or KEIL project using MHC",
    "content": "When creating projects for IAR or KEIL IDEs, MHC is launched as an application (as opposed to a plugin in MPLAB® X, when creating MPLAB® X projects). We refer to this mode of operation of MHC as “standalone” mode throughout this document. Follow the steps detailed below to create an project for IAR or KEIL using MHC . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-an-iar-or-keil-project-using-mhc",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-an-iar-or-keil-project-using-mhc"
  },"39": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Launching MHC in standalone mode",
    "content": "Navigate to the local clone of this repository and run the script that is appropriate for your operating system. That is . | For Windows, run the script runmhc.bat | For Linux/MacOS, run the script runmhc.sh | . This will launch the MHC as an application (see below): . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#launching-mhc-in-standalone-mode",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#launching-mhc-in-standalone-mode"
  },"40": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Setting user preferences",
    "content": "User preferences can be set by navigating to File -&gt; Preferences. MHC allows user to configure two preferences . | Diff - Allows user to configure a diff tool. This is an important configuration, and is explained further down in project generation section. We can configure any third party diff tool. To set diff tool, navigate to its installation directory using the browse button and select the executable. {0} and {1} are place holders for the files that need to diffed during project file generation. In this example, we are using WinMerge as the diff tool. | . | Log - Allows user to set the log level. There are three levels of logging available (ALL, DEBUG, USER). MHC displays the logs in the console window (seen at the bottom of the main window). It also saves them in the mhc.log file under .mh3 folder in user’s home directory. This log level decides the kind of messages that will get logged. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#setting-user-preferences",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#setting-user-preferences"
  },"41": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Creating a new configuration",
    "content": "To create a new mhc configuration, choose File -&gt; New configuration. A new configuration creation dialog will popup, where we can enter the details of the configuration that we are about to create. | Framework Path - This is not configurable. Framework path defaults to the parent folder of the MHC repository. This folder is should contain relevant harmony 3 repositories required for project creation. Recommend using content manager for downloading and setting up Harmony 3 repositories. Make sure that the “Convert to relative path for configuration” check box is unchecked. | Project information - Under project information, user can choose the location of the project, name of the project and the name of the configuration. | Location - Location where the project and configuration will be created | Project name -Used by MHC when creating projects for target IDEs. If you want a KEIL or IAR project with specific name, it should be entered in this field | Configuration name - Used by MHC when creating configuration data | Path - Shows the location where the new configuration will be created. Paths used by MHC for creating the project and configuration follows these rules . | configuration information will be created under &lt;location&gt;/firmware/source/config/&lt;configuration_name&gt; folder. In this example it will be “D:/Projects/My_Harmony_3/firmware/src/config/default” folder | IDE projects will be created under &lt;location&gt;/firmware/&lt;configuration_name&gt;.&lt;IDE name&gt; folder. In this example, if we choose to create an IAR project, it will be created under “D:/Projects/My_Harmony_3/firmware/default.IAR” folder | . | . | Configuration Options - Allows us to choose the target device of this confifuration. Device Family drop down limits the options to a specific family when choosing the target device, while Device Filter allows searching for a device by entering few characters. In this instance, ATSAMC21N18A MCU is chosen for creating the configuration. | . Clicking finish button will popup a confirmation dialog. We can change the default Device Family Pack (DFP) and CMSIS Pack used for creating the configuration from this dialog. Click on the launch button to create a new configuration. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-a-new-configuration",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#creating-a-new-configuration"
  },"42": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Making changes to the configuration",
    "content": "Refer to documentation on how to use the project graph for configuring Harmony 3 components using mplabx Harmony 3 configurator. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#making-changes-to-the-configuration",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#making-changes-to-the-configuration"
  },"43": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Generating code and project associated with a configuration",
    "content": ". | Select the target toolchain by clicking the system component in the project graph and choosing System -&gt; Project Configuration -&gt; Toolchain selections -&gt; Compilers in the configuration option window. Available options are XC32, IAR and KEIL. Some of these options might not be available for all targets. Choosing IAR or KEIL as the target compiler, will result in MHC creating IAR embedded workbench or Keil uVision IDE projects for the selected target. In this case, we have chosen KEIL as the toolchain. | Select Generate - &gt; Generate code option in menu bar to start project generation. In the generation window, we can choose the merge strategies. | . | Based on the choosen merge startegy, when MHC identifies that there is a diff in the files it generated (for eg: modification within the project IDE), it will launch the configured diff tool. We can bring in the changes that are relevant and ignore the rest. Once the diff tool is closed, the project generation sequence is continued until the entire configuration is generated. | If IAR or KEIL is chosen as the toolchain, MHC will also create a folder containing the relevant project files which can then be opened using the corresponding IDE. The path of this folder, follows the rules explained in the “configuration” section. In this example, it would be under \\\"D:/Projects/My_Harmony_3/firmware/default.KEIL\\\", since we choose keil as the the toolchain. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#generating-code-and-project-associated-with-a-configuration",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#generating-code-and-project-associated-with-a-configuration"
  },"44": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#note-1",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#note-1"
  },"45": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html#reference-links",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html#reference-links"
  },"46": {
    "doc": "Create IAR or Keil project using MHC",
    "title": "Create IAR or Keil project using MHC",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_iar_or_keil_project_using_mhc/readme.html",
    "relUrl": "/source/basic/create_iar_or_keil_project_using_mhc/readme.html"
  },"47": {
    "doc": "Create a new MPLAB Harmony v3 project using MCC",
    "title": "Create a new MPLAB Harmony v3 project using MCC",
    "content": "This tutorial shows you how to create a new MPLAB Harmony v3 project using MPLAB Code Configurator (MCC). This training module used SAM D5x/E5x MCUs to create an application that gets you started in developing applications using MCC on the MPLAB Harmony v3 software framework. The application makes use of SAM E51 Curiosity Nano Evaluation Kit. Note: Though this application uses the SAM E51 microcontroller as an example, the general description and steps to install, configure, and generate code using MCC applies to all 32-bit PIC and SAM microcontrollers. This application demonstrates an LED (LED0) toggle on a timeout basis and prints the LED toggling rate on the serial terminal. The periodicity of the timeout will change from 500 milliseconds to 1 second, 2 seconds, 4 seconds, and back to 500 milliseconds every time you press the switch SW0 on the SAM E51 Curiosity Nano Evaluation Kit. The applications you create will utilize: . | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data. | SERCOM (as USART), Direct Memory Access (DMA) PLIBS to print the temperature values on a COM (serial) port terminal application running on a PC. | PORT PLIB to toggle the LED. | Help develop your first MPLAB Harmony v3 application using MCC. In the process, the lab will also demonstrate the use of callback functions. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_harmony_3_project_using_mcc/readme.html#create-a-new-mplab-harmony-v3-project-using-mcc",
    "relUrl": "/source/basic/create_new_harmony_3_project_using_mcc/readme.html#create-a-new-mplab-harmony-v3-project-using-mcc"
  },"48": {
    "doc": "Create a new MPLAB Harmony v3 project using MCC",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_harmony_3_project_using_mcc/readme.html",
    "relUrl": "/source/basic/create_new_harmony_3_project_using_mcc/readme.html"
  },"49": {
    "doc": "Create a new MPLAB Harmony v3 project using MCC",
    "title": "Web Links",
    "content": ". | Create a new MPLAB Harmony v3 project using MCC | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_harmony_3_project_using_mcc/readme.html#web-links",
    "relUrl": "/source/basic/create_new_harmony_3_project_using_mcc/readme.html#web-links"
  },"50": {
    "doc": "Create a new MPLAB Harmony v3 project using MCC",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_harmony_3_project_using_mcc/readme.html#reference-links",
    "relUrl": "/source/basic/create_new_harmony_3_project_using_mcc/readme.html#reference-links"
  },"51": {
    "doc": "Create a new MPLAB Harmony v3 project using MCC",
    "title": "Create a new MPLAB Harmony v3 project using MCC",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_harmony_3_project_using_mcc/readme.html",
    "relUrl": "/source/basic/create_new_harmony_3_project_using_mcc/readme.html"
  },"52": {
    "doc": "Create new TrustZone Project",
    "title": "Creating a New TrustZone Project",
    "content": "To create a new TrustZone project, in MPLAB® X IDE, Select File &gt; New Project or click . The New Project wizard will open. Perform following steps: . | Choose Project: . | In the Choose Project pane, select the Microchip Embedded category. | In the Projects pane, select 32-bit MPLAB® Harmony 3 Project, then click Next. | | . Note: If the 32-Bit MPLAB® Harmony 3 Project type is not listed under the Microchip Embedded category, please download and install MPLAB® Harmony 3 Configurator before continuing with these steps. | Framework Selection: . | Provide the framework path where Harmony 3 repositorries have been downloaded, then click Next. | . | . | Project Settings: . | Location: Indicates the path to the root folder of the new project. All project files will be placed in this folder. | Folder: Indicates the name of the MPLAB® X IDE folder. | Name: Enter name of the project which you want to see in MPLAB® X IDE, click Next. | Path: The path information will be updated automatically as and when users make changes to other fields. | | . Note: Click the “Show Visual Help” button to open a contextual help window for a detailed description of various fields in the Project Settings. | Configuration Settings: . | Name: Enter the configuration name. | Target Device: Choose target device | Click Finish button to launch MPLAB® Harmony Configurator (MHC). After clicking the Finish button, MHC will create Secure and Non-secure MPLAB® X Projects. | . | Note: . | By default the TrustZone Enabled checkbox is selected by MHC for TrustZone devices, user can’t disable the TrustZone functionality for that specific device. | After clicking the Finish button, if MHC does not launch, user can launch it by selecting Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator from the MPLAB® X IDE. | . | The MHC plug-in will open either inside MPLAB® X window (native mode) or in a new window (standalone mode). This setting can be done in MPLAB® X &gt; Tools &gt; Options &gt; Plugins &gt; MPLAB® 3 Harmony Launcher &gt; Window Manager. | . | TrustZone Project uses two projects viz., Secure and Non-Secure Project that work together on the same MCU and offering security isolation between the Trusted and the Non-trusted resources in the device. | Secure Project: . | Secure project contains harmony project file harmony.prj. And this project also contains a configuration file for both Secure and Non-secure project. | Secure project must be selected as Main Project to launch MHC. | Once the Harmony code is generated, Secure user application should be developed in secure “main.c”. And “veneer.c” and “veneer.h” files should be used for the Non-secure to Secure function calls and vice versa. | Secure project is a loadable project from the Non-secure project. When Secure Project builds it generates Secure Gateway (SG) library ([configuration name]_Secure_sg_veneer.lib) which will be used by the Non-secure project while building the Non-secure project. | . | Non-secure Project: . | Once the Harmony code is generated, Non-secure user application should be developed in Non-secure “main.c”. | When Non-secure Project builds, it first builds Secure Project and then Non-secure project and generates target binaries to be executed on the device. | . | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#creating-a-new-trustzone-project",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#creating-a-new-trustzone-project"
  },"53": {
    "doc": "Create new TrustZone Project",
    "title": "Runing TrustZone Project",
    "content": "Following steps need to be done to run TrustZone project: . | In MPLAB® X Non-secure Project properties, appropriate compiler, hardware tools and DFP should be selected as shown in the figure below. | . | Select Non-secure Project as Main Project, Non-secure Project can be then build and programmed using MPLAB® X “Make and Program Device Main Project” option. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#runing-trustzone-project",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#runing-trustzone-project"
  },"54": {
    "doc": "Create new TrustZone Project",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#note-1",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#note-1"
  },"55": {
    "doc": "Create new TrustZone Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html#reference-links",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html#reference-links"
  },"56": {
    "doc": "Create new TrustZone Project",
    "title": "Create new TrustZone Project",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/create_new_trust_zone_project/readme.html",
    "relUrl": "/source/basic/create_new_trust_zone_project/readme.html"
  },"57": {
    "doc": "Harmony 3 Packages",
    "title": "Harmony 3 Packages",
    "content": "This page describes the packages that make up the MPLAB® Harmony software development framework. These packages are foundin the MPLAB Harmony GitHub repository and can be downloaded using the MPLAB Harmony 3 Content Manager. | Package Name | Descriptions | Example Function Names | . | contentmanager | Contains the MPLAB® Harmony 3 Content Manager | – | . | mhc | Contains the implementation of the MPLAB Harmony Configurator (MHC) tool. | – | . | dev_packs | Describes all peripherals, memory, etc. of each supported 32-bit device. | – | . | csp | Chip Support Package (CSP) supports initialization of Microchip 32-bit SAM and PIC® microcontroller and microprocessor devices. The peripheral libraries (PLIB) allow the development of simple applications that directly control the SAM and PIC peripherals. | UARTx_Initialize, UARTx_Read, TMRx_Start, TMRx_Stop, TCx_TimerStart, TCx_TimerStop, PORT_PinSet, PORT_PinRead | . | csp_apps_pic32mk | Contains the Harmony 3 peripheral library application examples for PIC32MK family | – | . | csp_apps_pic32mx | Contains the Harmony 3 peripheral library application examples for PIC32MX family | – | . | csp_apps_pic32mm | Contains the Harmony 3 peripheral library application examples for PIC32MM family | – | . | csp_apps_pic32mz_da | Contains the Harmony 3 peripheral library application examples for PIC32MZ DA family | – | . | csp_apps_pic32mz_ef | Contains the Harmony 3 peripheral library application examples for PIC32MZ EF family | – | . | csp_apps_pic32mz_w1 | Contains the Harmony 3 peripheral library application examples for PIC32MZ W1 family | – | . | csp_apps_pic32cm_mc00 | Contains the Harmony 3 peripheral library application examples for PIC32CM MC00 family | – | . | csp_apps_sam_9x60 | Contains the Harmony 3 peripheral library application examples for SAM 9X60 family | – | . | csp_apps_sam_a5d2 | Contains the Harmony 3 peripheral library application examples for SAM A5D2 family | – | . | csp_apps_sam_c20_c21 | Contains the Harmony 3 peripheral library application examples for SAM C20/C21 family | – | . | csp_apps_sam_d10 | Contains the Harmony 3 peripheral library application examples for SAM D10 family | – | . | csp_apps_sam_d11 | Contains the Harmony 3 peripheral library application examples for SAM D11 family | – | . | csp_apps_sam_d20 | Contains the Harmony 3 peripheral library application examples for SAM D20 family | – | . | csp_apps_sam_d21_da1 | Contains the Harmony 3 peripheral library application examples for SAM D21/DA1 family | – | . | csp_apps_sam_d5x_e5x | Contains the Harmony 3 peripheral library application examples for SAM D5X/E5X family | – | . | csp_apps_sam_e70_s70_v70_v71 | Contains the Harmony 3 peripheral library application examples for SAM E70/S70/V70/V71 family | – | . | csp_apps_sam_g55 | Contains the Harmony 3 peripheral library application examples for SAM G55 family | – | . | csp_apps_sam_ha1 | Contains the Harmony 3 peripheral library application examples for SAM HA1 family | – | . | csp_apps_sam_l10_l11 | Contains the Harmony 3 peripheral library application examples for SAM L10/L11 family | – | . | csp_apps_sam_l21 | Contains the Harmony 3 peripheral library application examples for SAM L21 family | – | . | csp_apps_sam_l22 | Contains the Harmony 3 peripheral library application examples for SAM L22 family | – | . | csp_apps_sam_rh71 | Contains the Harmony 3 peripheral library application examples for SAM RH71 family | – | . | bsp | Board Support Package (BSP) defines the name of the evaluation board and the name of switches and LEDs on the board. It also defines the attributes of the pins connected to the switches and LEDs (e.g.: data direction). | – | . | core | Provides drivers and system services that have advanced capabilities and a higher level of abstraction that gives better hardware independence. The drivers and services provide abstracted interfaces that do not change from device to device. Peripheral Library (PLIB) interfaces, while providing lower overhead and more direct control, give no such guarantee. Applications written using driver and service APIs do not usually need to be modified if the device configuration is changed or even if a new Microchip MCU or MPU device is selected. This package also implements the Operating System Abstraction Layer (OSAL). | DRV_USART_Initialize, DRV_USART_ReadBuffer, DRV_I2C_Initialize, DRV_I2C_ReadTransfer, SYS_TIME_TimerCreate, SYS_TIME_TimerCounterGet, OSAL_Malloc | . | crypto | The Cryptographic Library includes functions to perform encryption, decryption, hashing, authentication, and compression within the embedded application. Random number generation (RNG) functions are also provided. The library provides DES, 3DES, and AES for block cipher needs. Depending on the algorithm in use, CBC and CTR modes are supported. | CRYPT_RNG_Initialize, CRYPT_RNG_Get, CRYPT_ECC_KeySizeGet, CRYPT_SHA256_DataAdd | . | crypto_apps_encrypt_decrypt | Contains the Harmony 3 Encrypt/Decrypt Crypto Application Examples | – | . | crypto_apps_speed_test | Contains the Harmony 3 Crypto SpeedTest Application Examples | – | . | crypto_apps_large_hash | Contains the Harmony 3 Large Hash Crypto Application Examples | – | . | core_apps_pic32mk | Contains the Harmony 3 driver and system service application examples for PIC32MK family | – | . | core_apps_pic32mm | Contains the Harmony 3 driver and system service application examples for PIC32MM family | – | . | core_apps_pic32mx | Contains the Harmony 3 driver and system service application examples for PIC32MX family | – | . | core_apps_pic32mz_da | Contains the Harmony 3 driver and system service application examples for PIC32MZ DA family | – | . | core_apps_pic32mz_ef | Contains the Harmony 3 driver and system service application examples for PIC32MZ EF family | – | . | core_apps_pic32mz_w1 | Contains the Harmony 3 driver and system service application examples for PIC32MZ W1 family | – | . | core_apps_pic32cm_mc00 | Contains the Harmony 3 driver and system service application examples for PIC32CM MC00 family | – | . | core_apps_sam_9x60 | Contains the Harmony 3 driver and system service application examples for SAM 9X60 family | – | . | core_apps_sam_a5d2 | Contains the Harmony 3 driver and system service application examples for SAM A5D2 family | – | . | core_apps_sam_c20_c21 | Contains the Harmony 3 driver and system service application examples for SAM C20/C21 family | – | . | core_apps_sam_d20 | Contains the Harmony 3 driver and system service application examples for SAM D20 family | – | . | core_apps_sam_d21_da1 | Contains the Harmony 3 driver and system service application examples for SAM D21/DA1 family | – | . | core_apps_sam_d5x_e5x | Contains the Harmony 3 driver and system service application examples for SAM D5X/E5X family | – | . | core_apps_sam_e70_s70_v70_v71 | Contains the Harmony 3 driver and system service application examples for SAM E70/S70/V70/V71 family | – | . | core_apps_sam_g55 | Contains the Harmony 3 driver and system service application examples for SAM G55 family | – | . | core_apps_sam_ha1 | Contains the Harmony 3 driver and system service application examples for SAM HA1 family | – | . | core_apps_sam_l10_l11 | Contains the Harmony 3 driver and system service application examples for SAM L10/L11 family | – | . | core_apps_sam_l21 | Contains the Harmony 3 driver and system service application examples for SAM L21 family | – | . | core_apps_sam_l22 | Contains the Harmony 3 driver and system service application examples for SAM L22 family | – | . | core_apps_sam_rh71 | Contains the Harmony 3 driver and system service application examples for SAM RH71 family | – | . | gfx | Contains the Aria Graphics library, the MPLAB Harmony Graphics Composer (MHGC) plug-in, the Display Manager plug-in. It also includes a simple quickstart application (Aria Quickstart) that provides a touch-enabled starting point for Aria Graphics development. | GFX_ActiveContext, GFX_Set, GFXU_StringFontIndexLookup | . | gfx_apps | Contains MPLAB® Harmony 3 Graphics Support Package (Aria Archive) | – | . | gfx_aria | Contains MPLAB® Harmony 3 Graphics Apps Support Package | – | . | gfx_apps_pic32mz_da | Contains MPLAB® Harmony 3 Graphics Application Examples for PIC32MZ DA Family | – | . | gfx_apps_sam_a5d2 | Contains MPLAB® Harmony 3 Graphics application examples for SAM A5D2 Family | – | . | gfx_apps_pic32mz_ef | Contains MPLAB® Harmony 3 Graphics application examples for PIC32MZ EF Family | – | . | gfx_apps_sam_c20_c21 | Contains MPLAB® Harmony 3 Graphics application examples for SAM C20 C21 Family | – | . | gfx_apps_sam_9x60 | Contains MPLAB® Harmony 3 Graphics Application Examples for SAM 9x60 Family | – | . | gfx_apps_sam_d5x_e5x | Contains MPLAB® Harmony 3 Graphics application examples for SAM D5x/E5x Family | – | . | gfx_apps_sam_e70_s70_v70_v71 | Contains MPLAB® Harmony 3 Graphics Application Examples for SAM E70/S70/V70/V71 Family | – | . | gfx_apps_sam_l22 | Contains MPLAB® Harmony 3 Graphics Application Examples for SAM L22 Family | – | . | net | Contains the MPLAB Harmony 3 Network Package (Net). The Net repo provides a free fast to market TCP/IP stack for Microchip 32-bit SAM and PIC microprocessor devices. The following net_apps_XXXX repository contains multiple applications that demonstrate communication over TCP/IP using well-known protocols like TCP, UDP, HTTP, SMTP, etc. | TCPIP_STACK_Status, TCPIP_STACK_NetIsReady, TCPIP_TCP_ArrayPut | . | net_10base_t1s | This repository contains the MPLAB® Harmony 3 10BASE-T1S. | – | . | net_apps_pic32mx | Contains the MPLAB Harmony 3 Network Package (Net) application examples for PIC32MX family | – | . | net_apps_pic32mz | Contains the MPLAB Harmony 3 Network Package (Net) application examples for PIC32MZ family | – | . | net_apps_sam_rh71 | Contains the MPLAB Harmony 3 Network Package (Net) application examples for SAM RH71 family | – | . | net_apps_sam_e5x | Contains the MPLAB Harmony 3 Network Package (Net) application examples for SAM E5X family | – | . | net_apps_sam_a5d2 | Contains the MPLAB Harmony 3 Network Package (Net) application examples for SAM A5D2 family | – | . | net_apps_sam_e70_v71 | Contains the MPLAB Harmony 3 Network Package (Net) application examples for SAM E70/S70/V70/V71 family | – | . | net_apps_sam_9x60 | Contains the MPLAB Harmony 3 Network Package (Net) application examples for SAM 9x60 family | – | . | usb | The USB module components provide USB middleware and drivers. It also includes a variety of USB-related firmware projects that demonstrate the capabilities of the MPLAB Harmony USB stack. | USB_DEVICE_Attach, USB_DEVICE_EventHandlerSet, USB_HOST_CDC_AttachEventHandlerSet | . | usb_apps_multi_controller | Contains the MPLAB® Harmony 3 USB Multi-Controller application examples. | – | . | usb_apps_dual_role | Contains the MPLAB® Harmony 3 USB Dual Role application examples. | – | . | usb_apps_host | Contains the MPLAB® Harmony 3 USB Host application examples. | – | . | usb_apps_device | Contains the MPLAB® Harmony 3 USB Device application examples. | – | . | audio | Contains a variety of audio-related firmware projects that demonstrate the capabilities of the MPLAB Harmony audio offerings, drivers for hardware codecs that can be connected to development boards (e.g. WM8904 Codec Daughterboard), and a Board Support Package (BSP) Audio Template that can be used to make configuring a new audio project a matter of just a few mouse clicks. | DRV_WM8904_Initialize, DRV_WM8904_BufferAddRead, DRV_WM8904_VolumeSet | . | bt | Bluetooth-related firmware projects that demonstrate the capabilities of the MPLAB Harmony Bluetooth offerings, drivers for Bluetooth modules that can be connected to development boards (e.g. BM64 Bluetooth Module Daughterboard), and a BSP Bluetooth Template that can be used to make configuring a new Bluetooth project a matter of just a few mouse clicks. | DRV_BM64_Open, DRV_BM64_BufferAddRead, DRV_BM64_VolumeSet | . | motor_control | This module contains motor control demonstrations implemented on Microchip’s 32-bit SAM microcontrollers. You can use these demonstrations as a reference for developing your own motor control applications. It also includes the X2C-Scope plug-in for the MPLAB® X IDE. X2C-Scope enables you to read, write, and plot global variables (for motor control) in real time. It communicates with the target using the UART. | – | . | mc_apps_sam_rh71 | Contains the MPLAB® Harmony 3 Motor Control Application Examples for SAM RH71 family. | – | . | mc_apps_sam_e7x_s7x_v7x | Contains the MPLAB® Harmony 3 Motor Control Application Examples for SAM E7x/S7x/V7x family. | – | . | mc_apps_sam_d5x_e5x | Contains the MPLAB® Harmony 3 Motor Control Application Examples for SAM D5x/E5x family. | – | . | mc_apps_sam_c2x | Contains the MPLAB® Harmony 3 Motor Control Application Examples for SAM C2x family. | – | . | mc_apps_pic32mk | Contains the MPLAB® Harmony 3 Motor Control Application Examples for PIC32MK family. | – | . | mc_apps_pic32cm_mc | Contains the MPLAB® Harmony 3 Motor Control Application Examples for PIC32CM MC family. | – | . | x2c | Contains the MPLAB Harmony 3 X2C solutions which includes support for X2CScope and model based development using Scilab/Xcos + X2C Library. | – | . | micrium_ucos3 | This repository contains MPLAB Harmony configurations and applications for the Micrium OS-III. Micrium OS-III software is not included and must be downloaded separately. | – | . | azure-rtos-threadx | This repository contains MPLAB Harmony 3 Azure RTOS ThreadX configurations and application examples. | – | . | touch | The Touch Library is a royalty-free library for developing touch applications on 32-bit microcontrollers with a Peripheral Touch Controller peripheral. You can use it to integrate the touch-sensing capability into your applications. The library supports both self-capacitance and mutual-capacitance acquisition methods. | – | . | touch_apps | This repository contains the MPLAB® Harmony 3 Touch solutions and example applications. | – | . | wireless | This repository contains the MPLAB® Harmony 3 Wireless solutions and example applications. It helps quickly incorporate connectivity to designs with wireless ICs, modules, software and development kits that make connecting. | – | . | wireless_apps_winc3400 | This repository contains the MPLAB® Harmony 3 Wireless application examples for WINC3400. | – | . | wireless_apps_winc1500 | This repository contains the MPLAB® Harmony 3 Wireless application examples for WINC1500. | – | . | wireless_apps_pic32mzw1_wfi32e01 | This repository contains the MPLAB® Harmony 3 Wireless application examples for PIC32MZ W1 family. | – | . | wireless_wifi | This repository contains the MPLAB® Harmony 3 Wireless_wifi solutions and example applications. It helps quickly incorporate connectivity to designs with wireless ICs, modules, software and development kits that make connecting. | – | . | wireless_system_pic32mzw1_wfi32e01 | This repository contains the MPLAB® Harmony 3 PIC32MZW1/WFI32 wireless system services. | – | . | aws_cloud | MPLAB® Harmony 3 Configurations and Applications to securely connect IoT devices to the AWS cloud using Amazon FreeRTOS. | – | . | bootloader | This repository contains the MPLAB® Harmony 3 Bootloader. This can be used to upgrade the firmware on a target device without the need for an external programmer or debugger. | bootloader_Trigger, bootloader_Start, run_Application | . | bootloader_apps_uart | Contains the Harmony 3 UART Bootloader Application Examples | – | . | bootloader_apps_i2c | Contains the Harmony 3 I2C Bootloader Application Examples | – | . | bootloader_apps_usb | Contains the Harmony 3 USB Bootloader Application Examples | – | . | bootloader_apps_ethernet | Contains the Harmony 3 Ethernet Bootloader Application Examples | – | . | bootloader_apps_sdcard | Contains the Harmony 3 SDCARD Bootloader Application Examples | – | . | bootloader_apps_can | Contains the Harmony 3 CAN Bootloader Application Examples | – | . | bootloader_apps_serial_memory | Contains the Harmony 3 Serial Memory Bootloader Application Examples | – | . | aerospace | This repository contains the MPLAB® Harmony 3 Aerospace solutions and example applications. It helps quickly incorporate connectivity to designs with Aerospace ICs, modules, software and development kits that make connecting effortless. | – | . | cryptoauthlib | This repository contains the MPLAB® Harmony 3 CryptoAuthLib APIs required to communicate with Microchip Security device. | – | . | cryptoauthlib_apps | This repository contains the MPLAB® Harmony 3 CryptoAuthLib Applications solutions and example applications | – | . | helix_mp3 | This repository contains the MPLAB® Harmony 3 Helix MP3 Decoder Library. The source code is brought into a project automatically when the “Enable MP3 Decoder” checkbox is checked in the MHC Configuration Options for the Audio Decoder Libraries component of the Audio repository. | – | . | ethercat | This repository contains the MPLAB® Harmony 3 EtherCAT solutions and example applications. | – | . | quick_docs | This repository contains the MPLAB® Harmony 3 Quick Documentation Package. | – | . | reference_apps | This repository contains the MPLAB® Harmony 3 Reference Applications. | – | . | classb_sam_e5x_d5x | This repository contains the MPLAB® Harmony 3 Class B Library. | – | . | classb_pic32cm_mc | This repository contains the MPLAB® Harmony 3 Class B Library for PIC32CM MC00 devices. | – | . | classb_pic32mzw1_wfi32e01 | This repository contains the MPLAB® Harmony 3 Class B Library for PIC32MZW1 device. | – | . | ethercat | This repository contains the MPLAB® Harmony 3 EtherCAT solutions and example applications. | – | . | CMSIS-FreeRTOS | Cortex Microcontroller Software Interface Standard (CMSIS) FreeRTOS. By default, when Harmony 3 core or middleware libraries are used, the MPLAB Harmony Configurator (MHC) automatically includes FreeRTOS in order to provide more efficient use of the CPU. (RTOS use can still be disabled manually.) | – | . | zlib | A massively spiffy yet delicately unobtrusive compression library. | – | . | wolfssl | wolfSSL (formerly CyaSSL) is a small, fast, portable implementation of TLS/SSL for embedded devices to the cloud. wolfSSL supports up to TLS 1.3. | – | . | wolfssh | wolfSSH is a small, fast, portable SSH implementation, including support for SCP and SFTP. | – | . | wolfMQTT | This is an implementation of the MQTT Client written in C for embedded use, which supports SSL/TLS via the wolfSSL library. This library was built from the ground up to be multi-platform, space conscience and extensible. Integrates with wolfSSL to provide TLS support. | – | . | threadx | Azure RTOS ThreadX is an advanced real-time operating system (RTOS) designed specifically for deeply embedded applications. | – | . | azure_rtos | MPLAB® Harmony 3 Azure RTOS configurations and application examples. | – | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_packages/readme.html#harmony-3-packages",
    "relUrl": "/source/basic/harmony_3_packages/readme.html#harmony-3-packages"
  },"58": {
    "doc": "Harmony 3 Packages",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_packages/readme.html#reference-links",
    "relUrl": "/source/basic/harmony_3_packages/readme.html#reference-links"
  },"59": {
    "doc": "Harmony 3 Packages",
    "title": "Harmony 3 Packages",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_packages/readme.html",
    "relUrl": "/source/basic/harmony_3_packages/readme.html"
  },"60": {
    "doc": "MPLAB Harmony v3 Project Manifest Feature",
    "title": "MPLAB Harmony v3 Project Manifest Feature",
    "content": "The MPLAB® Harmony v3 software framework is distributed as packages on GitHub under the Microchip MPLAB Harmony project. MPLAB Harmony v3 provides several software packages (as GitHub repositories), including device setup repositories (csp, core, dev_packs, mhc, etc.), technology-specific repositories (usb, net, wireless, etc.), and reference application (reference_apps) repositories. In addition to the device or technology-specific libraries, these repositories also have application examples. The release tags identify the MPAB Harmony v3 packages released on GitHub. Microchip regularly updates the packages for new feature additions and issue fixes with a new release. Each new release has a dedicated release tag. An MPLAB Harmony v3 application is developed using these packages. At a minimum, the application would use device-specific repositories such as csp, dev_packs, and mhc. If the application is extensive and has feature-rich functionality, it could use several packages for development. An application example released in an MPLAB Harmony v3 package is developed on specific released versions of the dependent repositories. For example, the application Getting Started Application on Curiosity PIC32MZ EF 2.0 Development Board was developed using csp v3.8.3, dev_packs v3.8.0 and mhc v3.6.5 packages. As Microchip provides newer releases, the version number of the repositories used to develop this application are upgraded. There could be situations wherein the user would like to develop the project with the same dependent package version they initially created or received. This document explains how to develop an application with the same dependent packages used when it was created or received. Note:  In this document, the phrase code generation tool refers to any one of the two Microchip code generation tools: MPLAB Harmony Configurator (MHC) and MPLAB Code Configurator (MCC). At the time of publication of this guide, the MPLAB Harmony v3 library code can be generated using either of these tools, however, in the future, only MCC will support MPLAB Harmony v3 code generation. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_project_manifest/readme.html#mplab-harmony-v3-project-manifest-feature",
    "relUrl": "/source/basic/harmony_3_project_manifest/readme.html#mplab-harmony-v3-project-manifest-feature"
  },"61": {
    "doc": "MPLAB Harmony v3 Project Manifest Feature",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_project_manifest/readme.html",
    "relUrl": "/source/basic/harmony_3_project_manifest/readme.html"
  },"62": {
    "doc": "MPLAB Harmony v3 Project Manifest Feature",
    "title": "Web Links",
    "content": ". | How to Use the MPLAB Harmony v3 Project Manifest Feature | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_project_manifest/readme.html#web-links",
    "relUrl": "/source/basic/harmony_3_project_manifest/readme.html#web-links"
  },"63": {
    "doc": "MPLAB Harmony v3 Project Manifest Feature",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_project_manifest/readme.html#reference-links",
    "relUrl": "/source/basic/harmony_3_project_manifest/readme.html#reference-links"
  },"64": {
    "doc": "MPLAB Harmony v3 Project Manifest Feature",
    "title": "MPLAB Harmony v3 Project Manifest Feature",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_3_project_manifest/readme.html",
    "relUrl": "/source/basic/harmony_3_project_manifest/readme.html"
  },"65": {
    "doc": "Difference Between MPLAB Harmony v3 PLIBs and Drivers",
    "title": "Difference Between MPLAB Harmony v3 PLIBs and Drivers",
    "content": "MPLAB Harmony v3 provides layered and modular software libraries that support a flexible embedded software development model. The core libraries under MPLAB Harmony v3 includes Peripheral Libraries (PLIBs), drivers, and system services. The PLIBs provide low-level device-specific support. The drivers and system services provide hardware abstraction upon which a highly capable Middleware is built. This guide describes the differences between the MPLAB Harmony v3 PLIBs and drivers, and it also describes when to use them. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_drivers_plibs/readme.html#difference-between-mplab-harmony-v3-plibs-and-drivers",
    "relUrl": "/source/basic/harmony_drivers_plibs/readme.html#difference-between-mplab-harmony-v3-plibs-and-drivers"
  },"66": {
    "doc": "Difference Between MPLAB Harmony v3 PLIBs and Drivers",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_drivers_plibs/readme.html",
    "relUrl": "/source/basic/harmony_drivers_plibs/readme.html"
  },"67": {
    "doc": "Difference Between MPLAB Harmony v3 PLIBs and Drivers",
    "title": "Web Links",
    "content": ". | The Difference Between MPLAB Harmony v3 PLIBs and Drivers, and When to Use Them | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_drivers_plibs/readme.html#web-links",
    "relUrl": "/source/basic/harmony_drivers_plibs/readme.html#web-links"
  },"68": {
    "doc": "Difference Between MPLAB Harmony v3 PLIBs and Drivers",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_drivers_plibs/readme.html#reference-links",
    "relUrl": "/source/basic/harmony_drivers_plibs/readme.html#reference-links"
  },"69": {
    "doc": "Difference Between MPLAB Harmony v3 PLIBs and Drivers",
    "title": "Difference Between MPLAB Harmony v3 PLIBs and Drivers",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_drivers_plibs/readme.html",
    "relUrl": "/source/basic/harmony_drivers_plibs/readme.html"
  },"70": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers",
    "content": "MPLAB Harmony v3 drivers provide a simple and abstracted ‘C’ language interface to the peripherals and other system resources. Some functions are similar across on all the device drivers, while other functions are unique to a specific driver or peripheral. Driver interface functions are generally independent of the details of how a given peripheral is implemented on any specific hardware, or how many instances of that peripheral exist in each system. Applications can control and easily interact with the peripherals by calling the driver interface. MPLAB Harmony v3 allows users to configure the drivers in any one of these operating modes: Synchronous (Blocking) or Asynchronous (Non-Blocking). | Asynchronous Mode - Non-blocking Application Program Interfaces (APIs). - Allows queuing of multiple requests. Each instance of an Asynchronous driver has a dedicated queue. - Works seamlessly in bare-metal and RTOS environment. - Interrupt and thread-safe. | Synchronous Mode - Blocking APIs - Support only RTOS environment - Interrupt and thread-safe | . This guide describes Synchronous and Asynchronous operating modes and how to use them. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html#differences-between-mplab-harmony-v3-synchronous-and-asynchronous-drivers",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html#differences-between-mplab-harmony-v3-synchronous-and-asynchronous-drivers"
  },"71": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html"
  },"72": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Web Links",
    "content": ". | The Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers and When to Use Them | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html#web-links",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html#web-links"
  },"73": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html#reference-links",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html#reference-links"
  },"74": {
    "doc": "Differences Between Synchronous and Asynchronous Drivers",
    "title": "Differences Between Synchronous and Asynchronous Drivers",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_async_drivers/readme.html",
    "relUrl": "/source/basic/harmony_sync_async_drivers/readme.html"
  },"75": {
    "doc": "Synchronous drivers and their usage in FreeRTOS based applications",
    "title": "Synchronous drivers and their usage in FreeRTOS based applications",
    "content": "MPLAB Harmony v3 allows users to configure the MPLAB Harmony v3 drivers in one of the following two operating modes: Synchronous or Asynchronous. The Asynchronous drivers support a non-blocking implementation model for the data transfer operations, and the Synchronous drivers support a blocking implementation model. Asynchronous drivers can be used in both Real Time Operating System (RTOS) and non-RTOS based environments while the synchronous drivers are suitable for RTOS-based environments. Synchronous drivers are designed to adhere to the blocking need of applications using RTOS. This guide describes using MPLAB Harmony v3 synchronous drivers with FreeRTOS-based applications. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_drivers_freertos/readme.html#synchronous-drivers-and-their-usage-in-freertos-based-applications",
    "relUrl": "/source/basic/harmony_sync_drivers_freertos/readme.html#synchronous-drivers-and-their-usage-in-freertos-based-applications"
  },"76": {
    "doc": "Synchronous drivers and their usage in FreeRTOS based applications",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_drivers_freertos/readme.html",
    "relUrl": "/source/basic/harmony_sync_drivers_freertos/readme.html"
  },"77": {
    "doc": "Synchronous drivers and their usage in FreeRTOS based applications",
    "title": "Web Links",
    "content": ". | MPLAB Harmony v3 Synchronous Drivers and Their Usage in FreeRTOS-Based Applications | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_drivers_freertos/readme.html#web-links",
    "relUrl": "/source/basic/harmony_sync_drivers_freertos/readme.html#web-links"
  },"78": {
    "doc": "Synchronous drivers and their usage in FreeRTOS based applications",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_drivers_freertos/readme.html#reference-links",
    "relUrl": "/source/basic/harmony_sync_drivers_freertos/readme.html#reference-links"
  },"79": {
    "doc": "Synchronous drivers and their usage in FreeRTOS based applications",
    "title": "Synchronous drivers and their usage in FreeRTOS based applications",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/harmony_sync_drivers_freertos/readme.html",
    "relUrl": "/source/basic/harmony_sync_drivers_freertos/readme.html"
  },"80": {
    "doc": "MHC Clock Configuration",
    "title": "MHC Clock Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open Clock Configuration MHC plug-in, perform this action MHC → Tools then click Clock Configuration . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#mhc-clock-configuration",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#mhc-clock-configuration"
  },"81": {
    "doc": "MHC Clock Configuration",
    "title": "Clock Configuration",
    "content": "In the MHC, select the Clock Diagram Tab and verify that the clock is configured correctly for the selected target board. The Clock Diagram tab allows for easy setup of the master, system and peripheral clocks. See image below. Note: In the screenshot above, the MHC clock configuration for SAME70 MCU is shown as an example. The MHC clock configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#clock-configuration",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#clock-configuration"
  },"82": {
    "doc": "MHC Clock Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#note-1",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#note-1"
  },"83": {
    "doc": "MHC Clock Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html#reference-links"
  },"84": {
    "doc": "MHC Clock Configuration",
    "title": "MHC Clock Configuration",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_clock_configuration/readme.html",
    "relUrl": "/source/basic/mhc_clock_configuration/readme.html"
  },"85": {
    "doc": "MHC Code Generation",
    "title": "MHC Code Generation",
    "content": "The following covers the basic MHC operations and code generation process, which helps users to setup and configure MHC according to their needs. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#mhc-code-generation",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#mhc-code-generation"
  },"86": {
    "doc": "MHC Code Generation",
    "title": "Selecting and Configuring Modules",
    "content": "After opening the MHC, the peripheral and library modules can be added to the project by following these steps: . | In the Available Components Area, select the peripheral or library module which needs to be configured by clicking on the module’s name. See 2. below image. | Configure the peripheral as required for the application in the Configuration Options Area. | Configure the pins in the Pin Manager depending on the application requirements. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#selecting-and-configuring-modules",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#selecting-and-configuring-modules"
  },"87": {
    "doc": "MHC Code Generation",
    "title": "Code Generation",
    "content": "To perform the following actions, press MHC Generate button in the Project Resources window. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#code-generation",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#code-generation"
  },"88": {
    "doc": "MHC Code Generation",
    "title": "Saving and Loading the MHC Configuration",
    "content": "Saving and loading the MHC configuration is integrated into the MPLAB® X IDE Save and Load functions. The MHC configuration is saved whenever the Generate button is pressed. You can also save the MHC configuration by clicking on the MPLAB® X IDE Save tool or selecting Save from the File menu.The MHC configuration file is included in the MPLAB® X IDE project, under the Important Files folder. The configuration file uses the extension .xml. Double-clicking on the MHC configuration file will cause that MHC configuration to be loaded. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#saving-and-loading-the-mhc-configuration",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#saving-and-loading-the-mhc-configuration"
  },"89": {
    "doc": "MHC Code Generation",
    "title": "Merge Window",
    "content": "If any of the files generated by the MHC has been edited outside of MHC and saved to the disk, then the Merge [MHC] window will appear in the Configuration Options. The Merge [MHC] window allows you to decide whether to keep the edits, or to replace them with the MHC newly generated code. When the newly generated MHC content has been accepted, MHC makes the changes to the file. To the MPLAB® X IDE, these changes are the same as if you typed in the new content. The normal MPLAB® X IDE edit undo can be used in the MHC Merge operation. A list of all the files that need to be merged appear one after another after resolving the merge conflicts. You must resolve merge conflicts to ensure that all the newly generated code is incorporated into the project. At the top of the Merge [MHC] window, in the center margin, there is an arrow, as shown in the following Merge Window Figure. Clicking on the arrow will replace all your edits in the current file with the MHC updated code that the MHC has just generated. The numbers above the arrow indicate the current difference and the total number of differences. The individual lines of MHC Updated Code can be selected to replace the edited code. As shown in the following Merge Window Figure, clicking on the arrows in the right margin of the left window will copy the MHC Updated Code to the generated driver file. Once the changes are accepted, the Merge mechanism will remove the highlighted file and highlight the next file on the list. To insure all updates are completed, a warning will be generated if the Merge mechanism is closed before all the changes are accepted. Note: Your edits will never be overwritten by the MHC generated code, except by explicit action in the Merge [MHC] window. When changes have been made both to a generated file and in the corresponding MHC UI within the Configuration Options, the Merge [MHC] window shown in the following Merge Window Figure will be displayed. The Merge [MHC] window allows you to resolve the conflicts between the newly generated file and the edits you have made to the file. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#merge-window",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#merge-window"
  },"90": {
    "doc": "MHC Code Generation",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html",
    "relUrl": "/source/basic/mhc_code_generation/readme.html"
  },"91": {
    "doc": "MHC Code Generation",
    "title": "Merge Window Figure",
    "content": ". ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#merge-window-figure",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#merge-window-figure"
  },"92": {
    "doc": "MHC Code Generation",
    "title": "Generated Source and Header Files",
    "content": "The generated code will be included in the active MPLAB® X IDE Project as shown in the below image. The header files are shown on the top and source files are shown on the bottom. Note: In the image below, the icons are used to organize the project virtual organization of files, not an actual one. The following table provides the Header and Source files generated from the sample project: . | # | Source File | Descriptions | . | 1 | bsp.h | Provides Board Support Package | . | 2 | definitions.h | Provides all library headers and definitions needed for the application | . | 3 | Peripheral (libs) | Supports peripherals used by the project | . | 4 | exceptions.c | Implements all exception handlers | . | 5 | initialization.c | Initializes all libraries and applications | . | 6 | interrupts.c | Provides the interrupt vector table | . | 7 | libc_syscalls.c | Provides the Harmony specific system calls | . | 8 | startup.c | Startup code for the application | . | 9 | main.c | Applications Main source file | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#generated-source-and-header-files",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#generated-source-and-header-files"
  },"93": {
    "doc": "MHC Code Generation",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#note-1",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#note-1"
  },"94": {
    "doc": "MHC Code Generation",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_code_generation/readme.html#reference-links"
  },"95": {
    "doc": "MHC Code Generation",
    "title": "MHC Code Generation",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_code_generation/readme.html",
    "relUrl": "/source/basic/mhc_code_generation/readme.html"
  },"96": {
    "doc": "MHC DMA Configuration",
    "title": "MHC DMA Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open DMA Configuration MHC plug-in, perform this action MHC → Tools then click DMA Configuration . | Note: MHC plugins availability will vary depending on the device selection while creating the project. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#mhc-dma-configuration",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#mhc-dma-configuration"
  },"97": {
    "doc": "MHC DMA Configuration",
    "title": "DMA Configuration",
    "content": "Users can add a channel and perform the channel settings, such as setting up source and destination address mode, interface identifier, data width, chunk size, and memory burst size. See image below. | . Note: In the screenshot above, the MHC DMA configuration for SAME70 MCU is shown as an example. The MHC DMA configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#dma-configuration",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#dma-configuration"
  },"98": {
    "doc": "MHC DMA Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#note-1",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#note-1"
  },"99": {
    "doc": "MHC DMA Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html#reference-links"
  },"100": {
    "doc": "MHC DMA Configuration",
    "title": "MHC DMA Configuration",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_dma_configuration/readme.html",
    "relUrl": "/source/basic/mhc_dma_configuration/readme.html"
  },"101": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "MHC Memory protection Unit (MPU) Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open MPU Configuration MHC plug-in, perform this action MHC → Tools then click MPU Configuration . | . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#mhc-memory-protection-unit-mpu-configuration",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#mhc-memory-protection-unit-mpu-configuration"
  },"102": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "MPU Configuration",
    "content": "Users can configure MPU regions for memory spaces, such as ITCM, DTCM, Flash, SRAM, Peripherals, EBI, QSPI, USBHS and System. Users can also set the different attributes for these memory spaces. See image below: . | . Note: In the screenshot above, the MHC MPU configuration for SAME70 MCU is shown as an example. The MHC MPU configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#mpu-configuration",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#mpu-configuration"
  },"103": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#note-1",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#note-1"
  },"104": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html#reference-links"
  },"105": {
    "doc": "MHC Memory Protection Unit Configuration",
    "title": "MHC Memory Protection Unit Configuration",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_memory_protection_unit_configuration/readme.html",
    "relUrl": "/source/basic/mhc_memory_protection_unit_configuration/readme.html"
  },"106": {
    "doc": "MHC NVIC Configuration",
    "title": "MHC NVIC Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open NVIC Configuration MHC plug-in, perform this action MHC → Tools then click NVIC Configuration . | . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#mhc-nvic-configuration",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#mhc-nvic-configuration"
  },"107": {
    "doc": "MHC NVIC Configuration",
    "title": "NVIC Configuration",
    "content": "NVIC Manager allows users to enable or disable interrupts, change priority, and change names of interrupt handlers, see image below. | . Note: In the screenshot above, the MHC NVIC configuration for SAME70 MCU is shown as an example. The MHC NVIC configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#nvic-configuration",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#nvic-configuration"
  },"108": {
    "doc": "MHC NVIC Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#note-1",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#note-1"
  },"109": {
    "doc": "MHC NVIC Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html#reference-links"
  },"110": {
    "doc": "MHC NVIC Configuration",
    "title": "MHC NVIC Configuration",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_nvic_configuration/readme.html",
    "relUrl": "/source/basic/mhc_nvic_configuration/readme.html"
  },"111": {
    "doc": "MHC Pin Configuration",
    "title": "MHC Pin Configuration",
    "content": "MHC plug-in consists of following plug-ins/managers based on the device selection while creating the project. | Clock Configuration: Enables to configure Master, Generic, Peripheral and System Clocks | Pin Configuration: Enables to configure pins in the Pin Configuration area depending upon the application requirements | NVIC Configuration: Enables to configure enable/disable of interrupts, interrupt priority and name | DMA Configuration: Enables to configure DMA Channels | MPU Configuration: Enables to configure different zones of Memory Protection Unit | . To open Pin Configuration MHC plug-in, perform this action MHC → Tools then click Pin Configuration . | . Note: MHC plugins availability will vary depending on the device selection while creating the project. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#mhc-pin-configuration",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#mhc-pin-configuration"
  },"112": {
    "doc": "MHC Pin Configuration",
    "title": "Pin Configuration",
    "content": "The Pin Manager consists of Pin Settings, the Pin Diagram, and the Pin Table tabs, which enables users to configure (assign peripheral function, set pin direction, configure pull-up or pull-down and so on) and map the I/O pins. The following color combinations are associated with the pins in the graphical or table View: . | Gray: This pin is not usable in the selected configuration, and there is no enabled module which has any functionality on that pin. The grayed-out locks on a white background indicates the pins that are locked out by selected system functions. | Blue: This pin is available and can be allocated to a module. | Green (with a lock): This pin is allocated and selected for a module. The name displayed against the pin is either the name of the pin in the module’s context or a custom name entered. | . Pin Diagram . It is the pictorial representation of the available, assigned and not available pins of the Microcontroller. See image below. | . Pin Table . The pin table provides the Pin Manager Grid View. Using Pin Table users can perform these actions: . | The device package can be selected from the drop-down list. | The package can be selected from the upper left side of the Pin Manager Table View. The Package drop-down list shows the LQFP144 package is selected and the selected package details are displayed in the Package View. The pin numbers in the Table View provides the pin numbers for the selected package. The three leftmost columns in the Table View indicate the module’s name, functionality name, and the direction. | | . Pin Settings . Pin settings enables the user to configure the pins. Users can provide custom name for pin, change the pin function, direction, latch and other properties, see image below. | . Note: In the screenshots above, the MHC pin configuration for SAME70 MCU is shown as an example. The MHC pin configuration for other PIC or SAM MCUs may differ from the one shown above. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#pin-configuration",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#pin-configuration"
  },"113": {
    "doc": "MHC Pin Configuration",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#note-1",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#note-1"
  },"114": {
    "doc": "MHC Pin Configuration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html#reference-links"
  },"115": {
    "doc": "MHC Pin Configuration",
    "title": "MHC Pin Configuration",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_pin_configuration/readme.html",
    "relUrl": "/source/basic/mhc_pin_configuration/readme.html"
  },"116": {
    "doc": "MHC Project Graph",
    "title": "MHC Project Graph",
    "content": "The Project Graph displays all the instantiated component blocks. In Figure below BSP, USART and STDIO modules from Peripherals (CSP), I2C module from Harmony Core Driver, and FreeRTOS from Third-Party Software components are activated. MHC uses concept of Capability and Dependency for easy instantiation of modules. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#mhc-project-graph",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#mhc-project-graph"
  },"117": {
    "doc": "MHC Project Graph",
    "title": "Generic Capability and Dependency",
    "content": "A generic capability has a common name that identifies an interface that can be provided by a component but does not have an implementation of its own. One or more other components must implement the capability as shown in the following figure. | Point 1: Indicates the concept of Generic capabilities and dependency, i.e. FreeRTOS has exposed a generic capability on “RTOS” on which Harmony Core Service has created a generic dependency, up on satisfying these generic dependencies the color will turn to Green. Non-required dependencies are indicated as Yellow and indicate optional functionality that will not inhibit the operation of the component if absent. Required dependencies will display as Red, indicating that an error will likely occur during generation, compilation, or at runtime if the dependency is not satisfied. Similarly, Harmony Core Service has exposed a generic capability “Core Service” on which I2C driver has created a generic dependency. Generic dependencies connect automatically to generic capabilities and no connector line is required to bind the two. | Point 2: Indicates how I2C dependency is satisfied by binding with the capability TWIHS0. The left side block is a capability i.e. TWIHS0 and the right-side block is a dependency i.e. “Instance 0” I2C. | Point 3: Indicates how a new component can be generated at run-time by clicking button creates a new generator database component. A generator database component can create unique instances of itself as needed. This is for things like components like bit-bang drivers that are defined in software, and thus can be added several times to a project if desired. Similarly, by clicking button deletes a component instantly. | Point 4: Indicates the available capability of I2C driver. As mention above a non-required dependency is indicated as Yellow and indicates optional functionality that will not inhibit the operation of the component if absent. | Point 5: Options to create, disband, add selected, view selected and configure group or container respectively. This is explained in detail in Section 5.3.2 Project Group Creation. The following figure illustrates the unsatisfied direct dependency for I2C driver. User can see the list of satisfiers for a direct dependency by right-clicking on Red color diamond button. | . Click button to adjust the “Canvas Size” and button for “Toggle Minimap”. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#generic-capability-and-dependency",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#generic-capability-and-dependency"
  },"118": {
    "doc": "MHC Project Graph",
    "title": "Multi-Dependency and Multi-Capability",
    "content": "A component can have more than one dependency and capability respectively. The following figure illustrates the multi dependency and multi-capability feature of Harmony and shown with square block unlike a diamond block in single dependency. For example, in the below figure File System component is dependent on SD Card (SPI), SDHC and MEMORY components respectively whereas each of these exposes a DRV_MEDIA capability. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#multi-dependency-and-multi-capability",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#multi-dependency-and-multi-capability"
  },"119": {
    "doc": "MHC Project Graph",
    "title": "Container or Group Creation",
    "content": "The following are different group options. The Root is the default group. See the figure 5.9 below. | Create Group or click : Creates a group. If user selects any component and clicks , then a pop-up is shown asking to automatically add selected components to the new group. | Disband Group or click : Deletes a selected group. User can delete one group at a time. If user selects any component and clicks , then a pop-up is shown asking to delete selected group. | Add selected to Group/Container or click : Adds selected component in to a target container. On clicking a pop-up with drop down menu option is shown asking user to select the target container. | View selected Group/Container or click : Select a group and click or double click a group to view the components grouped together in a container. | Configure Group Node or click : Select a group then click to display the connections of the components if any. On clicking a pop-up window is displayed showing the tabular list of available nodes, select the nodes to display in the group. | Select Next Highest Group or click : Selects the next highest group available. Root is the default group. Select a group and click or double click a group to view the components grouped together in a container then to select next highest group click or to select a group under a drop down . Multiple components added to group or container. This helps in simplifying the Project Graph view. The following figure illustrates the grouping of SPI Driver and SPI PLIB components. Similarly, user can create any number of group or container based on the requirement. Say for example separate container for TCP/IP and USB and so on. or based on the application need. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#container-or-group-creation",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#container-or-group-creation"
  },"120": {
    "doc": "MHC Project Graph",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#note-1",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#note-1"
  },"121": {
    "doc": "MHC Project Graph",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_project_graph/readme.html#reference-links"
  },"122": {
    "doc": "MHC Project Graph",
    "title": "MHC Project Graph",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . &lt;/span&gt; . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_project_graph/readme.html",
    "relUrl": "/source/basic/mhc_project_graph/readme.html"
  },"123": {
    "doc": "MHC Window manager and log level",
    "title": "Configuring MHC Plugin to select Window manager and log level",
    "content": "Select MHC Plugin configuration using **Tools &gt; Options &gt; Plugins &gt; MPLAB® Harmony 3 Launcher ** . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#configuring-mhc-plugin-to-select-window-manager-and-log-level",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#configuring-mhc-plugin-to-select-window-manager-and-log-level"
  },"124": {
    "doc": "MHC Window manager and log level",
    "title": "Window manager selection",
    "content": "The MHC plug-in will open either in a new window (standalone mode) or inside MPLAB® X window (native mode). Select window manager mode . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#window-manager-selection",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#window-manager-selection"
  },"125": {
    "doc": "MHC Window manager and log level",
    "title": "Log Level selection",
    "content": "There are three levels of logging available (ALL, DEBUG, USER). MHC displays the logs in the console window (seen at the bottom of the main window). It also saves them in the mhc.log file under .mh3 folder in user’s home directory. This log level decides the kind of messages that will get logged. Select the log level . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#log-level-selection",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#log-level-selection"
  },"126": {
    "doc": "MHC Window manager and log level",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#note-1",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#note-1"
  },"127": {
    "doc": "MHC Window manager and log level",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html#reference-links",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html#reference-links"
  },"128": {
    "doc": "MHC Window manager and log level",
    "title": "MHC Window manager and log level",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mhc_window_manager_log_level/readme.html",
    "relUrl": "/source/basic/mhc_window_manager_log_level/readme.html"
  },"129": {
    "doc": "MPLAB Code Configurator (MCC) for Harmony 3 Projects",
    "title": "MPLAB Code Configurator (MCC) for Harmony 3 Projects",
    "content": "MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_code_configurator/readme.html#mplab-code-configurator-mcc-for-harmony-3-projects",
    "relUrl": "/source/basic/mplab_harmony_3_code_configurator/readme.html#mplab-code-configurator-mcc-for-harmony-3-projects"
  },"130": {
    "doc": "MPLAB Code Configurator (MCC) for Harmony 3 Projects",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_code_configurator/readme.html#reference-links",
    "relUrl": "/source/basic/mplab_harmony_3_code_configurator/readme.html#reference-links"
  },"131": {
    "doc": "MPLAB Code Configurator (MCC) for Harmony 3 Projects",
    "title": "MPLAB Code Configurator (MCC) for Harmony 3 Projects",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_code_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_code_configurator/readme.html"
  },"132": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "MPLAB Harmony 3 Configurator (MHC)",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#mplab-harmony-3-configurator-mhc",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#mplab-harmony-3-configurator-mhc"
  },"133": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Introduction",
    "content": "MPLAB Harmony 3 is a vital part of the MPLAB development tools ecosystem for working with Microchip 32-bit SAM® and PIC® micro controllers. It consists of a Graphical User Interface (GUI) called the MPLAB® Harmony Configurator (MHC) and an extensive set of interoperable firmware libraries that accelerate the process of developing embedded applications. The fundamental MHC GUI tools are the content manager and configurator tools. The content manager tool simplifies the process of downloading the firmware libraries, demonstration applications, and extensions to the MHC GUI. The configurator tool provides a convenient GUI for selecting libraries, initialization parameters, and optional features. It also makes it easy to connect everything together and generate C language code in a working configuration for your project. This section describes the following MHC specific topics to get started using MPLAB® Harmony to develop embedded applications designed with Microchip 32-bit micro controllers. | Installation . | Prerequisites for MHC use as an MPLAB® X IDE Plugin | Installing MPLAB® Harmony 3 Launcher from the Microchip Plugins Update Center | Updating the MPLAB® Harmony 3 Launcher | . | Using the MHC with the MPLAB® X IDE . | To Create a New Project | To Choose an Existing Project | Selecting MPLAB® Harmony 3 Packages | Content Manager | Project Settings | Configuration Settings | Launching MHC | . | Operating Areas . | Active Components, Project Graph and Configuration Options | Remove component | Available Components | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#introduction",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#introduction"
  },"134": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"135": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Installation",
    "content": "The MHC is available as a plugin extension to the MPLAB X IDE and as a standalone Java application for use with other tool suites (see here for details). Regardless which form you choose, there are some prerequisites that you must have installed first. Additionally, you will need to have a supported 32-bit MCU board on which to program, run, and debug your application. Prerequisites for MHC use as an MPLAB® X IDE Plugin . | Install the Microchip MPLAB X IDE. | Refer Installing MPLAB X IDE guide | . | Install the MPLAB XC32/32++ C Compiler compiler for support of all Microchip 32-bit MCUs. | Refer Installing MPLAB XC32 Compiler guide | . | . Installing MPLAB® Harmony 3 Launcher from the Microchip Plugins Update Center . The MHC is not automatically installed with MPLAB® X IDE. You will need to take additional steps to download and install it through Microchip Plugins Update Center: . Steps . | Open the MPLAB® X IDE. | In the top-level menu, select to Tools &gt; Plugins. | In the Plugins window, select the Available Plugins tab. | Select MPLAB® Harmony 3 Launcher from the list of available plugins and click the Install button. The Plugin Installer opens. | Click Next and review the License Agreement. | Click Install when you are ready for the Plugin Installer to begin downloading the MHC plugin. When the MHC plugin download is complete, MPLAB® X IDE will ask to be restarted. | Select Restart Now and click Finish. Upon restart, the plugin is installed. You can now open MHC on a new or already existing MPLAB® X IDE project. | . Updating the MPLAB® Harmony 3 Launcher . Whenever a new version of MHC plugin is available, the MPLAB® X IDE will display a notification on the IDE window. Clicking on it will launch the plugin update wizard. In the wizard, click on the Install button to download and install the latest MHC plugin version. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#installation",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#installation"
  },"136": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"137": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Using the MHC with the MPLAB® X IDE",
    "content": "To generate code using the MHC in MPLAB® X IDE, you must first choose to create a new project or use an existing one. Then, you must follow these steps. To Create a New Project . To create MPLAB® X IDE project, follow these steps: . | Select File &gt; New Project or click New Project button to create a new project. The New Project wizard will open. | In the Choose Project pane, select the Microchip Embedded category. | In the Projects pane, select 32-bit MPLAB® Harmony 3 Project, then click Next. | Continue by following the Selecting MPLAB® Harmony 3 Packages steps, below. | . Note: If the 32-Bit MPLAB® Harmony 3 Project type is not listed under the Microchip Embedded category, please download and install MPLAB® Harmony 3 Configurator before continuing with these steps. To Choose an Existing Project . To choose an existing project, follow these steps: . | Click he Open Project window will be displayed. | Navigate to the desired project’s .X folder and click Open Project. The selected project will open in the IDE. | . Note: If multiple projects are open in MPLAB® X IDE, set one as the main (active) project by Right-clicking on it and selecting “Set as Main Project”. Selecting MPLAB® Harmony 3 Packages . The Content Manager tool simplifies downloading of MPLAB® Harmony 3 packages. Packages contain source code, templates, documentation, MHC extensions, and other collateral for MPLAB® Harmony modules. Each package is maintained in a GIT repository that can be downloaded (or cloned) to your development system in a framework folder of your choice. The Content Manager tool can be launched using one of the following methods: . | Method 1: While creating a new project from the New Project window, click the Launch Content Manager button. | Method 2: From the Tools &gt; Embedded &gt; MPLAB® Harmony 3 Content Manager menu option. | . Content Manager . Content Manager GUI helps in managing packages. It displays locally downloaded packages and remote packages available for download in a easy to use graphical interface. User can checkout remote packages or update locally downloaded packages once remote version is updated. It helps in managing package dependencies. Please click on below link for detailed information . GitHub → MPLAB Harmony 3 Content Manager . Gitee → MPLAB Harmony 3 Content Manager . Project Settings . In the New Project window, perform these settings: . | Ensure that the Framework Path is correct. It it is not, navigate to the folder to which you previously downloaded the MPLAB® Harmony 3 packages. Note: You can leave Convert to Relative Path for Configuration selected. | Click Next to select the project Name and Location. | To choose the project location, navigate to the folder in which you wish to keep your MPLAB® Harmony 3 projects and create a top-level folder for this project. Note: Be sure to create a new top-level folder for this project as it will contain both the MPLAB® X IDE’s project folder (the “.X” folder) and the firmware folder into which the MHC will generate the selected source code. | In the Folder edit box, provide the name that will be used for the MPLAB® X IDE’s “.X” folder. Note: This must be a valid directory name for your operating system. | In the Name edit box, enter the project’s “Virtual” name. This is the name that will be shown from within the MPLAB® X IDE. Note: The Path box is not editable. It will update as you make changes to the other entries. | Click Next to proceed to configuration settings. | . Configuration Settings . Follow these steps to select the project’s configuration settings. | In the right pane, under Configuration Settings enter details for the configuration Name and choose the Target Device. Note: You can select the Device Family or enter a partial device name to filter the list if Target Devices in order to make it easier to locate the desired device. | After selecting the target device, Click Finish to launch the MHC. Note: The New Project Wizard will first open a Configuration Database Setup dialog window to allow you to review the packages that will be used by the current project. Click Launch to continue to the MHC Configurator tool. | . Launching MHC . Follow these steps to launch the MHC. | Open the MHC plugin tool. If the project has already been created, launch the MPLAB® Harmony 3 Configurator by selecting Tools → Embedded → MPLAB® Harmony 3 Configurator from the MPLAB® X IDE’s menu bar. The MPLAB® Harmony Launcher window will be displayed. | If necessary, reconfigure the MPLAB® X Harmony project and framework paths by clicking the Reconfigure Paths button. Otherwise, accept the default settings and then click Launch. The Configuration Database Setup window will be displayed, which shows the selected and configured Harmony packages. | Click Launch to open MHC plug-in. The MHC plugin’s main window for the project will be displayed. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#using-the-mhc-with-the-mplab-x-ide",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#using-the-mhc-with-the-mplab-x-ide"
  },"138": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"139": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Operating Areas:",
    "content": "The MHC Graphical User Interface consists of following six major operating areas. | Active Components: Displays activated/instantiated components. | Available Components: Displays the available components based on the project configuration. Displays Board Support Packages (BSPs), list of available Peripheral Libraries (PLIBs), Harmony Core which consists of Drivers and System Services, Middleware Software, Third-Party Software and Tools. | Project Graph: Shows the instantiated components. User can instantiate available components by double click on component. After successful component instantiation, you can see the instantiated components under Active Components panel. | MHC Plugins: Consists of AFEC, DMA, MPU, NVIC, Clock and Pin configuration plugins. To open any of these plugins go to MHC → Tools → select above mentioned available plugins. | Configuration Options: Displays the tree view of the selected component under Project Graph Area. User can do the component configuration from here. | Console: Displays the MHC operation results The following figure displays the MHC graphical user interface showing six operating areas. Note: The components shown under components are based on the Microcontroller selected while creating the project. All operating areas are dockable. Each can be dragged and dropped into another position, even out of the MPLAB® X IDE main window. However, closing the IDE however will close all MHC windows, including the ones moved outside the IDE. | . Active Components, Project Graph and Configuration Options . Active Component and Project Graph displays all the instantiated components. By default, the below essential components from the Chip Specific Package (CSP) repo will get auto instantiated. | System: The CSP System component is used for the device and project specific configurations. | CMSIS Pack: The Cortex Microcontroller Software Interface Standard (CMSIS) Pack is a vendor-independent hardware abstraction layer for the Cortex®-M processor series and defines generic tool interfaces. This pack is needed for 32-bit SAM MCU devices. | Device Family Pack (DFP): This is the Microchip Device Family Pack retrieves the device specific information and instantiates the same. The following figure displays Active Components and Project Graph Area. Along with above mentioned default components, it consists of other active components like BSP, Harmony Core, I2C Driver, TWIHS, USART, SDTIO and FreeRTOS which are activated/instantiated by user. The following figure displays the project configuration of selected active “System” component. User can modify/configure activated component by selecting a component under Active component or under Project Graph. This way user can do the configuration of selected component. | . Remove component . To remove a component available in Active component area, follow these steps: . | Select it (for example, FreeRTOS) in Active Component Area or in Project Graph Area then click on button . | A pop-up window will display asking whether to deactivate a component. The following figure deactivating the FreeRTOS component. | Click Yes to deactivate the FreeRTOS component. | . Note: As the “System” component is the main component in CSP, except “System” all other components can be deactivated. Available Components . This section displays the available components of the project. Available component list varies based on the Harmony Core repo synchronization and the Microcontroller selected while creating the project. To instantiate a component, from the available components, double click on any available component. After the component is instantiated, the instantiated component will be displayed in the Project Graph Area. The following sections cover available components and description, and for GUI see figure below. | Board Support Packages (BSPs): Includes default or board specific BSP. | Harmony Core: Includes Harmony Core Services i.e., Drivers and System Services. | Peripheral: Includes available peripherals like USART, TWIHS, TC and so on. | Third-Party Libraries: Lists the supported Third-Party software’s. Currently supported Real Time Operating System is “FreeRTOS”. | Tools: This lists the supported tools like Standard Input/Output (STDIO) which uses USART peripheral. | . Similarly, if users sync USB or TCP/IP repositories then the respective Middleware Software section shall be displayed under the available components section. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#operating-areas",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#operating-areas"
  },"140": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#note-1",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#note-1"
  },"141": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html#reference-links",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html#reference-links"
  },"142": {
    "doc": "MPLAB Harmony 3 Configurator (MHC)",
    "title": "MPLAB Harmony 3 Configurator (MHC)",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/mplab_harmony_3_configurator/readme.html",
    "relUrl": "/source/basic/mplab_harmony_3_configurator/readme.html"
  },"143": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Open an Existing Harmony 3 Project",
    "content": "This page shows you how to open one of the many demonstration application projects that are included in the MPLAB® Harmony framework. Before doing this, you’ll need to do the following: . | Install MPLAB X IDE | Install MPLAB XC32 Compiler | Install the MPLAB Harmony Configurator (MHC) | Download the MPLAB Harmony Framework | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#open-an-existing-harmony-3-project",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#open-an-existing-harmony-3-project"
  },"144": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Steps",
    "content": ". | In the MPLAB X IDE, select File &gt; Open Project. | Demonstration applications come with most of the libraries. These can be found in each library’s apps folder. Browse to the firmware folder (as shown below) to find all evaluation boards that support the application. Select your evaluation board and click Open Project. | After the project opens, start MHC. In the MPLAB X IDE, select Tools &gt; Embedded &gt; MPLAB® Harmony 3 Configurator. | Select the path to the folder containing the MPLAB Harmony framework and click Launch. | The Configuration Database Setup window opens. You shouldn’t have to change anything in this window. Click Launch.Please be patient while waiting for the last window to open. It will ask if you want to open the default saved state file. This file is used to save all selections made in MHC for the project you are opening. Click Open.You can now use the MPLAB Harmony Configurator. Please see the MHC Wiki for instructions on how to use it. | . Note: You can save or load an MHC configuration at any time. The default name of the MHC state file is: . &lt;MPLAB X project configuration name&gt;.xml . It can be found in the following folder: . …/&lt;project name&gt;/firmware/src/config/&lt;project configuration name&gt;/. If you are not using MPLAB X Project Configurations, the MHC state file can be found in the following folder: . …/&lt;project name&gt;/firmware/src/config/default/default.xml . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#steps",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#steps"
  },"145": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Note",
    "content": "This page has been verified with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | . Because Microchip regularly update tools, occasionally there could be minor differences with the newer versions of the tools. ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#note-1",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#note-1"
  },"146": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html#reference-links",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html#reference-links"
  },"147": {
    "doc": "Open an Existing Harmony 3 Project",
    "title": "Open an Existing Harmony 3 Project",
    "content": "                                                                                                      . Note: . MPLAB Harmony v3 is now configurable through MPLAB Code Configurator (MCC). Though the instructions in this guide are for the MPLAB Harmony Configurator (MHC), the flow and experience of creating a project, configuring peripherals, and generating code using MCC is similar. Refer to the below links for specific instructions to use MPLAB Harmony v3 with MCC. | Create a new MPLAB Harmony v3 project using MCC | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Getting Started with MPLAB Harmony v3 Using MPLAB Code Configurator | MPLAB® Code Configurator Content Manager for MPLAB Harmony v3 Projects | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/open_an_existing_harmony_3_project/readme.html",
    "relUrl": "/source/basic/open_an_existing_harmony_3_project/readme.html"
  },"148": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "Introduction",
    "content": "This document guides the user on how to configure boot configuration packet for first stage bootloader and how to ensure a valid code in second stage bootloader. The First stage bootloader (ROM code or Boot ROM or NVM bootloader) is a small piece of mask code, executed on power-on or reset, responsible for loading the second-stage bootloader(Harmony uses the at91Bootstrap as its second stage boot loader)/ User Application from an external NVM into the internal SRAM and execute it. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#introduction",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#introduction"
  },"149": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "First stage bootloader - Boot Sequence",
    "content": ". | The boot sequence is an ordered list of embedded memory controllers from which the ROM code tries to boot. User can modify the boot sequence by writing a valid Boot Configuration packet in the OTPC/Emulated OTPC. | When no Boot Configuration Packet is available, ROM code will try to boot from one of the external NVMs in the following order: . | SDMMC0 IOSET0 | SDMMC1 IOSET0 | QSPI0 IOSET0 | SPI0 IOSET0 | NAND0 IOSET0 | . | . If no bootable file/valid boot code is found in these memories, the ROM code goes to the SAM-BA monitor. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#first-stage-bootloader---boot-sequence",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#first-stage-bootloader---boot-sequence"
  },"150": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "First stage bootloader- Boot flow process",
    "content": ". | The ROM code boot flow process is shown below: . | The boot flow process is based on the values of the Boot Configuration Packet. | By default, the value of the Boot Configuration Packet is 0x0. | On a default boot, the following events occur: . | External NVM is initialized in a sequence to locate valid boot code and copied to internal SRAM. | DBGU is initialized and configured for serial communication. | JTAG port is enabled for debugging. | If no valid code is found in any On-board NVM, SAM-BA Monitor is enabled. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#first-stage-bootloader--boot-flow-process",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#first-stage-bootloader--boot-flow-process"
  },"151": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "Configure First stage bootloader",
    "content": ". | User can write the boot configuration packet either to the OTP matrix or emulation SRAM by setting emulation bit in the boot sequence controller configuration register (BSC_CR). | Boot configuration loading step is explained in the below flowchart: . | Using boot configuration packet, user can: . | Modify the boot sequence steps by enabling only the user preferred NVMs like QSPI, NAND, SDCARD etc. | Configure the console serial communications. | Enable/Disable JTAG port for debugging. | Enable/Disable SAM-BA Monitor. | . | User can write boot sequence controller configuration register(BSC_CR) and the boot configuration packet to OTP/Emulated SRAM using SAM-BA tool. | Go to this link to download and configure SAM-BA. | Refer this document for SAM-BA commands to configure BSC_CR and boot configuration packet | Note: . | Using Emulated OTP enables the user to test several boot configurations options without programming the OTP. | It is recommended to set Emulation bit and then write boot configuration packet to Emulated SRAM during development phase. | User can simply skip boot configurations if the focus is more on building application, in this case default boot configuration is applicable. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#configure-first-stage-bootloader",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#configure-first-stage-bootloader"
  },"152": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "How first stage bootloader ensures the presence of valid second stage bootloader",
    "content": ". | The Boot ROM reads and analyzes the first 28 bytes corresponding to the first seven Arm exception vectors of second Stage bootloader (at91bootstrap) to decide whether the AT91bootstrap can be considered as valid, or it should be skipped. | Except for the sixth vector, other exception vector bytes must implement the Arm instructions for either branch or load PC with PC-relative addressing. The ROM code fetches the 6th exception vector value to know exactly how many bytes it should transfer from the external NVM instead of reading the maximum size allowed to the user application, hence speeding up the boot process. | If the external NVM chosen is SD/eMMC card, then BootROM looks for boot.bin file in the FAT formatted SDCard/e.MMC in addition to the arm-exception vectors check. | The at91bootstrap code ensures the presence of the valid code by having the proper exception vector. It can be seen in crt0_gnu.s file in at91bootstrap source code. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#how-first-stage-bootloader-ensures-the-presence-of-valid-second-stage-bootloader",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#how-first-stage-bootloader-ensures-the-presence-of-valid-second-stage-bootloader"
  },"153": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "NOTE",
    "content": ". | Click here to learn how to configure/built and debug second stage bootloader(at91bootstrap) for SAM9X60 MPU | Click here to develop a harmony based application for SAM9X60 MPU using MPLAB® X IDE | Click here to flash the at91bootstrap and harmony application binaries using SAM-BA tool | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#note-1",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#note-1"
  },"154": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#reference-links",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html#reference-links"
  },"155": {
    "doc": "SAM9X60 Configure First Stage Bootloader",
    "title": "SAM9X60 Configure First Stage Bootloader",
    "content": "                                                                                                      . Note: . This guide will explain how to configure first stage bootloader for SAM9X60 family of microprocessors. | SAM9X60 boot process click here | SAM9X60 data sheet | SAM9X60 curiosity development board | SAM9X60 Evaluation kit | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_first_stage_bootloader/readme.html",
    "relUrl": "/source/basic/sam9x60_configure_first_stage_bootloader/readme.html"
  },"156": {
    "doc": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "title": "Introduction",
    "content": "This training module describes the following for at91bootstrap, a second-stage bootloader for Microchip Technology Arm®-based Microprocessor Units (MPU), where to get the source code, how to configure, compile and debug using MPLAB® X IDE on windows host. | The following solution is tested based on at91bootstrap version 4.0.5. | The at91bootstrap bootloader can be stored in external NVMs like (SD Memory Card), Multimedia Card (MMC), Embedded Multimedia Card (eMMC), NAND Flash, Serial Flash, QSPI Flash, Data Flash memory). The first-stage bootloader (ROM Boot Code) will load at91bootstrap from external NVM depending on the value of the Boot Configuration Packet. | Click here to learn how to configure Boot Configuration Packet for SAM9X60. | at91bootstrap if configured to do so, will initialize the following peripherals and memory controllers: . | Advanced Interrupt Controller (AIC) | Peripheral I/O Controller (PIO) | Power Management Controller (PMC) | Clock Generator (CKGR) | Static Memory Controller (HSMC) | NAND Flash Controller (NFC) | Multiport DDR-SDRAM Controller (MPDDRC) | Secure Digital Multimedia Card Controller (SDMMC) | . | at91bootstrap can be configured to load one of the following from external NVM into external volatile memory (DRAM) (main memory) and jump to: . | The third-stage bootloader(for example, Das U-Boot or BusyBox). | The Linux® kernel directly, thus it does not require a third-stage bootloader. | The Real Time Operating System (RTOS application). | Turn over control to the debugger (JTAG-Debugging alone). | The main program (Baremetal application). | . | at91bootstrap is written and maintained by Microchip Technology and hosted on GitHub. | NOTE . | If you want to simply debug the application and load it to SD card and test using prebuilt at91bootstrap, jump to develop harmony application examples section. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#introduction",
    "relUrl": "/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#introduction"
  },"157": {
    "doc": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "title": "Required software and hardware tools",
    "content": "Details . This document is written with the assumption that the user is aware of the external NVMS &amp; DDR memory available in the respective SAM9X60 boards (Like Evaluation Kits, Curiosity Boards, SIP or SOM) by reading the respective user guide. | To build/debug at91bootstrap using MPLAB® X IDE on windows host, the following tools should be installed properly: . | Download and install MPLAB® X IDE. | Download and install XC32 Compiler. | . | User can use below hardware tools: . | SAM9X60 Evaluation kit. (or) SAM9X60 Curiosity Development Board. | External J32 debugger if SAM9X60 Curiosity Development Board is used. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#required-software-and-hardware-tools",
    "relUrl": "/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#required-software-and-hardware-tools"
  },"158": {
    "doc": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "title": "Getting at91bootstrap Source Code",
    "content": "Details . | Create a Project Directory: Create a project directory to keep all the sources together for a given project. For the purpose of this tutorial topic, the created project directory is Harmony3. | Get at91bootstrap: Get the complete source code of at91bootstrap by either of the following ways: . | If you have git installed , clone the repo into the project directory by using the command: . $ git clone git@https://github.com/linux4sam/at91bootstrap . | If you don’t have git installed, then Download at91bootstrap and unzip into your project directory. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#getting-at91bootstrap-source-code",
    "relUrl": "/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#getting-at91bootstrap-source-code"
  },"159": {
    "doc": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "title": "Configure, build and debug at91bootstrap",
    "content": "Details . at91bootstrap can be configured to load the final application from any of the external NVMs available on the board like QSPI, NAND, SD CARD to DRAM and execute from it. User should follow the below steps to build the at91bootstrap as per their external NVM preference: . | Preparing the build Environment. | Configure the at91bootstrap. | Create a Custom Board Configuration. | Building the at91bootstrap. | Debugging the at91bootstrap. | . 1. Preparing the build Environment . Details . 1.1. Open at91Bootstrap project: To begin, launch MPLAB® X IDE and then go to File –&gt; Open Project –&gt;choose downloaded at91bootstrap project. Now set it as main project. &lt;img src = \\\"images/1_1a.png\\\" align=\\\"middle\\\"&gt; . 1.2. Compiler setting: User can use XC32 compiler to build at91bootstrap. Go to Project –&gt; Properties –&gt; Makefile —&gt; Copy the XC32 installation path and update it in the build/debug and clean command –&gt; Apply —&gt; ok . E.g. Build/Debug command: make CROSS_COMPILE=”C:/Program Files/Microchip/xc32/v4.10/bin/bin/pic32c-“ . Clean command: make mplabclean CROSS_COMPILE=\\\"C:/Program Files/Microchip/xc32/v4.10/bin/bin/pic32c-\\\" . 2. Configure the at91bootstrap . Details . The at91bootstrap can be configured to load from any one of the user-preferred NVMs by using KCONFIG. Depending on your hardware setup (sam9x60) and the preferred NVMs(Either QSPI or NAND or SD-Card) or to debug on MPLAB® X IDE, select one of the below options explained in the following sub-chapters. Legendry: board can be evaluation Kit (ek), Curiosity board (_curiosity), or SIP (sip). E.g., sam9x60ek. 2.1. Configure at91bootstrap for debug use with MPLAB® X IDE. 2.2. Configure at91bootstrap to load application from QSPI. 2.3. Configure at91bootstrap to load application from NAND. 2.4. Configure at91bootstrap to load application from SDCARD. In addition to the above configuration for the external NVMs, user can also customize the default configuration like external RAM size and type, external clock source etc. which is explained in section 2.5. 2.1 Configure at91bootstrap for debug use with MPLAB® X IDE . Details . The at91bootstrap built from sam9x60_bkptnone_defconfig can only be used for debugging the application using MPLAB® X IDE. Note: bkptnone_defconfig configures the at91bootstrap to continuously loops at the end of its execution, hence IDE can take over control (time-out message) and now continue to download the application in the user space. Therefore, this bkptnone_defconfig should be used only to debug the application using MPLAB X IDE. To do this, go to Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sam9x60(board)_bkptnone_defconfig –&gt; Open. This will do the kconfig for building at91bootstrap for debug use with MPLAB X IDE. After opening the configuration file, the Kconfig will be as shown below. Now Click Apply –&gt; OK. 2.2. Configure at91bootstrap to load application from QSPI . Details . at91bootstrap can be configured to load the harmony application from QSPI into external volatile memory (DRAM) as follows. To do this, go to Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sam9x60(board)df_qspi_linux_image_dt_defconfig or sam9x60(board)df_qspi_uboot_defconfig –&gt; Open. Legendry: df –&gt; Data Flash . Then perform the following changes: . | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup: . | Flash offset –&gt; QSPI offset where a user wants to flash the application. | Demo app image size –&gt; Size of the app image to be copied from QSPI to DRAM by at91bootstrap. | External RAM address to load Demo-App image –&gt; It should match the .text load address in your application linker script. External RAM address of SAM9X60 board starts from 0x20000000 – 0x3FFFFFFF. Please refer to the data sheet for more details. | . | . An example configuration for SAM9X60-EK is shown below. This completes the configuration for building at91bootstrap to load the harmony application from QSPI into external volatile memory (DRAM) and then execute it from DRAM. 2.3. Configure at91bootstrap to load application from NAND . Details . at91bootstrap can be configured to load the harmony application from NAND flash into external volatile memory (DRAM) as follows. Dependencies: at91bootstrap needs Python 3.x.y (python3). This is needed for the scripts generating the PMECC headers for NAND Flash memories. Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sam9x60(board)nf_linux_image_dt_defconfig or sam9x60(board)nf_uboot_defconfig –&gt; Open. Then perform the following changes: . | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup: . | Flash offset for Demo App –&gt; NAND flash offset where a user wants to flash the application. | Demo app image size –&gt; Size of the app image to be copied from NAND to DRAM by at91bootstrap. | External RAM address to load Demo-App image –&gt; It should match the .text load address in your application linker script. | . | . An example configuration for SAM9X60-EK is shown below. It completes the kconfig for building at91bootstrap to load the harmony application from NAND flash into external volatile memory (DRAM) and then execute it from DRAM. 2.4. Configure at91bootstrap to load application from SDCARD . Details . at91bootstrap can be configured to load the harmony application from SD card memory into external volatile memory (DRAM) as follows. Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sam9x60(board)sd_linux_image_dt_defconfig or sam9x60(board)sd_uboot_defconfi –&gt; Open. Then perform the following changes: . | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup. | External RAM address to load Demo-App image –&gt; It should match the .text load address of your application linker script. | Next Software Image File name –&gt; Name of your application binary. Eg:harmony.bin. | . | . An example configuration for SAM9X60-EK is shown below. It completes the kconfig for building at91bootstrap to load the harmony application from SD memory card into external volatile memory (DRAM) and then execute it from DRAM. 2.5. Customizing other default configuration . Details . User can customize the clock source, Display Banner (Display banner is the output string in the serial console when at91bootstrap begins running), external RAM-type and size, different SD card slot if SDCard is the user preferred NVM on the default configuration. To do this, go to Project –&gt; Properties –&gt; Kconfig. An example customization using SAM9X60-EK board is shown below: . 3. Create a Custom Board Configuration . Details . This section is for advanced developers who wish to create a custom board configuration (almost from scratch) for the at91bootstap bootloader for their custom board.  . | Dependencies . | Linux Host: It is recommended to do customization using Linux Host. | GIT: Install GIT and clone at91bootstrap by using the following command: . $ git clone https://github.com/linux4sam/at91bootstrap.git . | Then follow the steps in this link to do customization and contribution of your customized code to Microchip at91bootstrap. | . | . 4. Building the at91bootstrap . Details . To build the at91bootstrap go to project –&gt; Clean and build or simply click the build icon in the IDE. Note: When building using XC32 compiler, if a user doesn’t have XC32 pro compiler, a warning saying cannot optimize size will pop up in the compiler output window as follows. To avoid this either use XC32 pro compiler or just ignore this. Once the build is successful, you will get the build success message in the IDE as shown in the above Image. Now user will be able to see the boot.bin file in the project directory/build/binaries. boot.bin file is the at91bootstrap file. Now the user can use the boot.bin file to . | Flash it to the respective NVM. (or) | Use the at91bootstrap to debug the harmony application on MPLAB X IDE. (or) | Debug the at91bootstrap using MPLAB X IDE as explained in the next section. | . 5. Debugging the at91bootstrap . Details . To debug the at91bootstrap, go to project –&gt; Set as main project. Then click project –&gt; Debug or simply click the debug icon in the IDE. Now user can start debugging the at91bootstrp by clicking the debug symbols available in the IDE like Step into, Reset, Step over etc. When debugging the application, serial console outputs can be monitored by connecting windows host with the board (Eg: SAM9X60-EK) through a terminal emulation program. For example, refer to this link to download terminal emulation program and follow the steps to establish a serial communication with SAM9X60-EK. An example image showing the serial console output while debugging at91bootstrap is shown below. This completes the training module to configure, build &amp; debug at91bootstrap for different user preferred NVMs. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#configure-build-and-debug-at91bootstrap",
    "relUrl": "/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#configure-build-and-debug-at91bootstrap"
  },"160": {
    "doc": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "title": "Note",
    "content": ". | Click here to learn how to configure first stage bootloader for SAM9X60 MPU | Click here to develop a harmony based application for SAM9X60 MPU using MPLAB® X IDE | Click here to flash the at91bootstrap and harmony application binaries using SAM-BA tool | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#note-1",
    "relUrl": "/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#note-1"
  },"161": {
    "doc": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#reference-links",
    "relUrl": "/source/basic/sam9x60_configure_second_stage_bootloader/readme.html#reference-links"
  },"162": {
    "doc": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "title": "Configure the second stage bootloader for SAM9X60 based MPUs",
    "content": "                                                                                                      . Note: . This guide will teach you how to configure the second stage bootloader for SAM9X60 based MPUs. | SAM9X60 boot process click here | SAM9X60 data sheet | SAM9X60 curiosity development board | SAM9X60 Evaluation kit | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_configure_second_stage_bootloader/readme.html",
    "relUrl": "/source/basic/sam9x60_configure_second_stage_bootloader/readme.html"
  },"163": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "Introduction",
    "content": "This document will guide the user on how to, . | Write boot sequence controller configuration register(BSC_CR) &amp; boot configuration packet to configure first stage bootloader. | Flash boot.bin (at91bootstrap) &amp; harmony.bin (RTOS/Baremetal application) file to external NVMs like QSPI,NAND &amp; SD-Card. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#introduction",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#introduction"
  },"164": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "Prerequisites",
    "content": "Details . | Familiar with the features of the SAM9X60_board (board can be evaluation Kit or Curiosity board) and understanding about the jumpers &amp; Connectors in the board. | Install SAM-BA tool on your windows host PC. | To Download the latest version of SAM-BA tool for Windows click this link. | Download the ZIP file and unzip it into a working directory of your choice. | Add the SAM-BA directory path to the environment variables. | To do this from your PC –&gt; Open the Start Search, type in “env”. | Choose “Edit the system environment variables” –&gt; Click “Environment Variables” –&gt; “System Variables” –&gt; add SAM-BA directory path to path variables. | . | Once the SAM-BA Host program has been installed, the execution of the application is from the Windows command prompt. | Now open Windows command prompt and enter the below command to ensure sam-ba is installed properly. sam-ba -v | . | Refer this link to configure and build the at91bootstrap to load the application from the user preferred NVM like QSPI, NAND or SDCard. Note: This resultant at91bootstrap file (boot.bin) built with the preferred NVM configuration only to be used here. | Refer this link to build harmony application. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#prerequisites",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#prerequisites"
  },"165": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "Setup SAM-BA Host to Monitor Communications",
    "content": "Details . In this section you will establish SAM-BA Host Application communications with the target’s (SAM9X60) SAM-BA Monitor. Then you will use the SAM-BA Host Applet (qspiflash) to erase and then write the boot.bin (at91bootstrap) and harmony.bin (MPLAB Harmony 3 application) binary images to NOR Flash Memory. Step 1: To communicate with the SAM-BA Monitor on the target, you must have installed the SAM-BA Host on a Host Computer. Step 2: Ensure there is no SD memory card inserted. Step 3: Power the board by connecting a Micro-B USB cable to USBA port (J7) on the SAM9X60-EK or (J1) on the SAM9X60 Curiosity Development Board. Step 4: Establish UART serial communication with PC through J24 on SAM9X60 Evaluation Kit or J11 on SAM9X60 Curiosity Development Board. Step 5: Open Disable boot Jumper(J13) on SAM9X60 Evaluation Kit or Open the J4 NAND boot jumper on SAM9X60 Curiosity Development Board. Step 6: . | If you are using SAM9X60 Evaluation Kit follow these steps: . | 5.1. Push and hold the “DIS_BOOT” button.(This disables booting from the onboard memories - NAND and NOR(QSPI) flash Memory) | 5.2. Reset the board by pressing and then releasing the reset “nRST” button. | 5.3. Release the “DIS_BOOT” button. | . | If you are using SAM9X60 Curiosity Development Board follow these steps: . | 5.1. Open the J4 NAND boot jumper.(This disables booting from the NAND flash Memory) | 5.2. Reset the board by pressing and then releasing the reset “RESET” button. | 5.3. Close the J4 NAND boot jumper. | . | . Now, the SAM9X60_board will boot to the SAM-BA Monitor and start communications with the SAM-BA Host Application. Note: . | SAM-BA communication Port can be j-link, serial or secure. | If user want to program the SAM9X60 Evaluation Kit, using j-link instead of serial UART port, then connect J22 with PC via USB cable and replace “serial” in SAM-BA commands with “j-link”. | Eg: Replace sam-ba -p serial -b sam9x60-ek -a lowlevel with sam-ba -p j-link -b sam9x60-ek -a lowlevel | . | . ***The board variant for SAM9X60 Curiosity might not be available yet in SAM-BA, so you can choose the SAM9X60-EK with the -b parameter of SAM-BA.*** . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#setup-sam-ba-host-to-monitor-communications",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#setup-sam-ba-host-to-monitor-communications"
  },"166": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "1. Program external QSPI flash memory",
    "content": "Details . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#1-program-external-qspi-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#1-program-external-qspi-flash-memory"
  },"167": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "1.1. Erase QSPI flash memory",
    "content": "Erase the contents of the QSPI Flash memory on the SAM9X60board with the following command: . sam-ba -p serial -b sam9x60-ek -a qspiflash -c erase . Example: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#erase-qspi-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#erase-qspi-flash-memory"
  },"168": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "1.2. Program boot.bin to QSPI flash memory",
    "content": "Program the boot.bin file on the SAM9X60_board with the following command: . sam-ba -p serial -b sam9x60-ek -a qspiflash -c writeboot:boot.bin . | Note: Change directory to the location of boot.bin | . Example: . Note: Refer this link to configure and build the at91bootstrap to load the application from QSPI. The at91bootstrap file (boot.bin) built with QSPI configuration only to be used here. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-bootbin-to-qspi-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-bootbin-to-qspi-flash-memory"
  },"169": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "1.3. Program harmony.bin to QSPI flash memory",
    "content": "To program the application binary, harmony.bin file on the SAM9X60_board, use the following command: . sam-ba -p serial -b sam9x60-ek -a qspiflash -c write:harmony.bin:QSPI_OFFSET . Note: * The QSPI_OFFSET should be the same offset used in the KCONFIG, while configuring the at91bootstrap to load from external QSPI * Change directory to the location of harmony.bin. Example: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-harmonybin-to-qspi-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-harmonybin-to-qspi-flash-memory"
  },"170": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "Note:",
    "content": "To learn about more SAM-BA applet commands, refer your SAM-BA installation directory/doc/applet.html . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#note",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#note"
  },"171": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "2. Program External NAND Flash Memory",
    "content": "Details . Note:By default PMECC configuration for the NAND populated on the SAM9X60 Curiosity Development Board is not aligned with the one of the SAM9X60-EK board. The PMECC parameter for the SAM9X60 Curiosity board with MX30LF4G28AD-XKI NAND flash memory is 0xc2605007. User has to do the below two modification to use sam9x60-ek sam-ba applet on curiosity to program NAND flash memory. For information on NAND header values, please refer to SAM9X60 datasheet section \\\"12.4.7.1.1 Method 1 (recommended): NAND Flash Specific Header Detection\\\". | To modify the PMECC parameter in the SAM-BA Applet –&gt; open sam-ba installation directory/qml/SAMBA/Device/SAM9X60/SAM9X60EK.qml and modify the NAND Flash header to 0xc2605007 | . | Set the NAND header of the SAM9X60 Curiosity Development boadr using the below command. sam-ba -p serial -b sam9x60-ek -a nandflash:::0xc2605007 | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#2-program-external-nand-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#2-program-external-nand-flash-memory"
  },"172": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "2.1. Erase NAND flash memory",
    "content": "Erase the contents of the NAND Flash memory on the SAM9X60_board with the following command: . sam-ba -p serial -b sam9x60-ek -a nandflash -c erase . Example: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#erase-nand-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#erase-nand-flash-memory"
  },"173": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "2.2. Program boot.bin to NAND flash memory",
    "content": "Program the boot.bin file on the SAM9X60board with the following command: . sam-ba -p serial -b sam9x60-ek -a nandflash -c writeboot:boot.bin . | Note: Change directory to the location of boot.bin Example: | . Note: Refer this link to configure and build the at91bootstrap to load the application from NAND flash memory. The at91bootstrap file (boot.bin) built with NAND configuration only to be used here. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-bootbin-to-nand-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-bootbin-to-nand-flash-memory"
  },"174": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "2.3. Program harmony.bin to NAND flash memory",
    "content": "To program the application binary, harmony.bin file on the SAM9X60_board, use the following command: . sam-ba -p serial -b sam9x60-ek -a nandflash -c write:harmony.bin:NAND_OFFSET . Note: * The NAND_OFFSET should be same as the one used in the KCONFIG, while configuring the at91bootstrap to load from external NAND flash. * Change directory to the location of harmony.bin. Example: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-harmonybin-to-nand-flash-memory",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#program-harmonybin-to-nand-flash-memory"
  },"175": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "Note:",
    "content": "To learn about more SAM-BA applet commands, refer your SAM-BA installation directory/doc/applet.html . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#note-1",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#note-1"
  },"176": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "3. Program External SD CARD",
    "content": "Details . To program the at91bootstrap -boot.bin file and application binary -harmony.bin file on SD-card: . | (i) Format the SD card using your PC/Laptop. | (ii) Copy and paste boot.bin and harmony.bin into the SD card from your host PC. | . Note: Refer this link to configure and build the at91bootstrap to load the application from SD Card. The at91bootstrap file (boot.bin) built with SD card configuration should be used here. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#3-program-external-sd-card",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#3-program-external-sd-card"
  },"177": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "4. Program BSC_CR &amp; Boot Configuration Packet",
    "content": "Details . After a reset, The ROM code reads the Boot Configuration Packet from the SRAM dedicated to Emulation mode if the bit BSC_CR.EMUL_EN is set to 1 or from the OTP matrix and configure boot sequence, Enable/Disable Monitor, configure the serial console UART. Using Emulated OTP enables the user to test several boot configuration options, including secure boot mode without programming the OTP. Note: If Emulation mode is enabled, the emulation SRAM is not backed up. After a power off/on, the configuration and content are lost. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#4-program-bsc_cr--boot-configuration-packet",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#4-program-bsc_cr--boot-configuration-packet"
  },"178": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "4.1. Enable/Disable Emulation mode in BSC_CR",
    "content": "To Enable/Disable Emulation mode in Boot Sequence Controller Configuration Register (BSC_CR), the following SAM-BA command should be used: . //To Enable Emulation Mode: . sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg:bscr: EMULATION_ENABLED . //To Disable Emulation Mode: . sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg:bscr: EMULATION_DISABLED . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#enabledisable-emulation-mode-in-bsccr",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#enabledisable-emulation-mode-in-bsccr"
  },"179": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "4.2. Steps to write Boot Configuration Packet to emulated SRAM",
    "content": ". | Emulation enable : sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg:bscr:EMULATION_ENABLED | Reset : sam-ba -p serial -d sam9x60 -a bootconfig -c resetemul | Refresh config : sam-ba -p serial -d sam9x60 -a bootconfig -c refreshcfg:emul | Write Config : sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg:bcp-emul:NFC_IOSET1 // Refer section 4.4. for different configurations | Lock config : sam-ba -p serial -d sam9x60 -a bootconfig -c lockcfg:bcp-emul | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-emulated-sram",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-emulated-sram"
  },"180": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "4.3. Steps to write Boot Configuration Packet to OTP",
    "content": ". | Emulation disable: sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg:bscr:EMULATION_DISABLED | Refresh config : sam-ba -p serial -d sam9x60 -a bootconfig -c refreshcfg:otp | Write Config : sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg:bcp-otp:NFC_IOSET1 // Refer section 4.4. for different configurations | Lock config : sam-ba -p serial -d sam9x60 -a bootconfig -c lockcfg:bcp-otp | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-otp",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-otp"
  },"181": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "4.4. Boot Configuration Packet- different configurations available:",
    "content": "The writecfg command programs the Boot Configuration Packet (BCP) into the Emulated SRAM, if the emulation mode of the OTPC is enabled. Else BCP packets are stored inside the OTP matrix. User can use the below command to get the full list of boot configurations possible: . sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg:help . Example boot configurations: . // boot config with Serial Console on FLEXCOM0, boot from SDMMC1 (PA10 as card-detect pin) store in OTP matrix . sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg: bcp-otp:FLEXCOM0_USART_IOSET1,SDMMC1_IOSET1_PA10 . // Empty boot configuration packet in OTP matrix . sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg: bcp-otp: . // boot config with SAM-BA Monitor Disabled, boot from SDMMC1 (PA10 as card-detect pin) store in OTP-Emulation mode . sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg: bcp-emul:MONITOR_DISABLED,SDMMC1_IOSET1_PA10 . // Empty boot configuration packet in OTP-Emulation mode- Emulated SRAM . sam-ba -p serial -d sam9x60 -a bootconfig -c writecfg: bcp-emul: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#boot-configuration-packet--different-configurations-available",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#boot-configuration-packet--different-configurations-available"
  },"182": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "Note:",
    "content": "To learn about more bootconfig SAM-BA applet commands: Refer your SAM-BA installation directory/doc/bootconfig-otp.html . Links . | Click here to learn how to configure first stage bootloader for SAM9X60 MPU | Click here to learn how to configure/built and debug second stage bootloader(at91bootstrap) for SAM9X60 MPU | Click here to develop a harmony based application for SAM9X60 MPU using MPLAB® X IDE | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#note-2",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#note-2"
  },"183": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#reference-links",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html#reference-links"
  },"184": {
    "doc": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "title": "SAM9X60 Flash boot and harmony application binaries using SAMBA",
    "content": "                                                                                                      . Note: . This guide will explain how to use SAM-BA to Write Boot Configuration Packet &amp; Flash at91bootstrap, RTOS/Baremetal applications to external NVM for SAM9X60. | SAM9X60 boot process click here | SAM9X60 data sheet | SAM9X60 curiosity development board | SAM9X60 Evaluation kit | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_flash_boot_application_using_samba/readme.html",
    "relUrl": "/source/basic/sam9x60_flash_boot_application_using_samba/readme.html"
  },"185": {
    "doc": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "title": "Introduction",
    "content": "This document shows you how to create an MPLAB X IDE Harmony v3 project for a SAM9X60D1G MPU from scratch using the MPLAB Harmony v3 software framework. This document explains how to write and read from the onboard EEPROM on SAM9X60 Curiosity Development Board and display the data using serial debug interface. This project demonstrates below: . | Print serial console debug messages. | Write, Read and Compare the data from the EEPROM . | Print TEST PASS if write and read data from EEPROM matches and turn ON the blue LED on the board. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#introduction",
    "relUrl": "/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#introduction"
  },"186": {
    "doc": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "title": "Hardware Used:",
    "content": ". | SAM9X60 Curiosity development board | External JTAG | Micro SD Card | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#hardware-used",
    "relUrl": "/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#hardware-used"
  },"187": {
    "doc": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "title": "Software/Tools Used:",
    "content": ". | MPLAB® X IDE | MPLAB® XC32 Compiler | MPLAB® Code Configurator (MCC) | . This project has been verified to work with the following versions of software tools: . | mcc_version: v5.3.0 | mcc_core_version: v5.5.0 | mplabx_version: v6.05 | harmony_version: v1.2.0 | compiler: XC32 (v4.21) | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#softwaretools-used",
    "relUrl": "/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#softwaretools-used"
  },"188": {
    "doc": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "title": "Hardware Setup : ",
    "content": ". | Power up the board by connecting the USB cable to the USB port J1 on the SAM9X60 curiosity development board. | Connect external debugger to J12. | Ensure J14(1-2) and J15(1-2) jumpers on the board are closed towards DBGU to enable UART serial debug. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_getting_started_application_using_mcc/readme.html",
    "relUrl": "/source/basic/sam9x60_getting_started_application_using_mcc/readme.html"
  },"189": {
    "doc": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "title": "Create a new MPLAB Harmony v3 SAM9X60 Curiosity project Using MCC on MPLAB X IDE",
    "content": "Step 1: Create project and configure the MPU . Details . | 1.1. Select File –&gt; New Project from the main IDE menu. | 1.2. In the Categories pane of the New Project dialog, select Microchip Embedded. In the Projects pane, select 32-bit MCC Harmony Project, then click Next. | . Note: If 32-bit MCC Harmony Project is not displayed, install MCC. | 1.3. In the Framework Path edit box, browse to the folder where you downloaded the framework. Note: For more information on the content manager, see the Download MPLAB Harmony Framework section. | . | 1.4. In the Project Settings window, apply the following settings: . | Location: Indicates the path to the root folder of the new project. All project files will be placed inside this folder. The project location can be any valid path, for example: Folder of your choice/dev/sam9x60_getting_started. | Folder: Indicates the name of the MPLABX .X folder. Enter “sam9x60_cu” to create a sam9x60_cu.X folder. Note: This must be a valid directory name for your operating system. | Name: Enter the project’s logical name as “getting_started_sam9x60”. This is the name that will be shown from within MPLAB X IDE. Note: The Path box is read-only. It will update as you make changes to the other entries. | Click Next to proceed to Configuration Settings. | . | . Note: Clicking on the Show Visual Help button will open a help window providing a detailed description of the various fields in the Project Settings window. | 1.5. Follow the steps below to set the project’s Configuration Settings: . | Name: Enter the configuration name as “sam9x60_cu”. | Device Family: SAM. | Target Device: Select SAM9X60D1G as the target device. | After selecting the target device, click Finish to create and open MPLAB Harmony v3 Project. This creates an empty project. | . | . Step 2: Launch MCC and Project graph . Details . | 2.1. After the project is created, MCC will be automatically launched. To launch MCC manually, from main menu –&gt; click on “Tools” –&gt; “Embedded” –&gt; “MPLAB Code Configurator” or click simply MCC logo . It will launch Content manger Wizard. Then select MPLAB Harmony. | 2.2. In addition to the required packages (csp, dev_packs), download the optional packages bsp, core, gfx_apps_sam_9x60, csp_apps_sam_9x60,core_apps_sam_9x60 and then click Finish. Content download will take some time, please wait till all the contents are downloaded. | 2.3. Save the MCC configuration inside your project directory. | 2.4. Now, the MCC plugin’s main window for the project will be displayed. | Resource Manager has two sections one is Project Resources and another one is Device Resources. | Project Resources area displays all the peripherals currently configured for the project. For example (CMSIS and Device Family Packs (DFP)). | Device Resources area displays available peripherals for the device. Click on the peripheral you want to add to your project. The peripheral moves to the MCC Project Resources area and is ready to be figured to your project’s requirements. | . | 2.5. To autosave the MCC configuration, go to Tools –&gt; Option –&gt; Plugins –&gt; Editor Behavior –&gt; Autosave MCC Configuration File. | . Step 3: Configure the required peripheral libraries . Details . | 3.1. Observe the Project Graph pane in the top center of the window. The Device Family Pack (DFP) and System libraries have been automatically added to the project. | 3.2. Before proceeding to the next step refer SAM9X60 Curiosity user guide, SAM9X60 data sheet and find the pin details for the peripherals/modules used in this project. | Refer section 3.3.3 of the user guide and find that PA0 and PA1 are used to read/write data from/to EEPROM via I2C compatible 2-wire serial interface. | Refer SAM9X60 data sheet and find that PA0 and PA1 are flexcom0 , 2-wire serial interface peripherals. | . | Refer section 3.5.1 of the user guide and find that PA9 and PA10 are used to transmit and receive data for serial debug com port. | Refer section 3.5.4 of the user guide and find that PD21 is used to connect Blue LED. | . | 3.3. Now, add SAM9X60 Curiosity BSP to the project graph by clicking “+” symbol from Device Resource –&gt; Libraries –&gt; Board Support Packages(BSPs) –&gt; SAM9X60 curiosity BSP. This will configure LEDs and SWITCH (user push button). | 3.4. Add Flexcom0 to the project graph by clicking “+” symbol from Device Resource –&gt; Peripherals —&gt; Flexcom –&gt; Flexcom0. | 3.5. Add serial debug peripheral to the project graph by clicking “+” symbol from Device Resource –&gt; Peripherals –&gt; DBGU. This will add the serial debug com port to the project graph. | 3.6. Open the configuration option of debug peripheral, added by clicking on the DBGU peripheral in the project graph. | Ensure the com port settings of serial debug as follows: . | Ensure flexcom configurations are proper as shown below , by clicking flexcom. | Similarly check clock configurations for flexcom and debug unit are enabled by clicking system . | . | 3.7. From the Project Graph tab, select Plugins –&gt; Pin Configuration to launch the Pin Configuration windows. | 3.8. The Pin Configuration window provides three different views: . | Pin Settings (which can be ordered by Pins or Ports) | Pin Table | Pin Diagram | . | 3.9. In the Pin Settings view, select Ports from the Order drop-down menu. The view will be ordered by Port name (labeled as Pin ID). Ensure the pins mentioned in the above section 3.2. is configured as follows. &lt;img src = \\\"images/15.png\\\" align=\\\"middle\\\"&gt; . | 3.10. Save your configuration by clicking on the Save icon or selecting File –&gt; Save Configuration from the menu bar. This completes the configuration of the required peripheral libraries. | . Step 4: Generate Code . Details . | 4.1. Now, generate the code by using MCC. From the left side tab, Resource Management (MCC), go to Project Resources and click on the Generate button. | 4.2. As the code is generated, MCC displays the progress. | 4.3. Examine the generated code files. MCC will include all the MPLAB Harmony v3 library files and generate the code based on the MCC selections. The generated code will add files and folders to your Harmony project. Among the generated code, notice the library files generated for BSP and peripheral libraries Debug, Flexcom. MCC also generates a template main file main.c. | . Step 5: Add application Code to the Project and build the application . Details . | 5.1. Up to this point in the project creation process, MPLAB Code Configurator(MCC) generated code to initialize the device (SAM9X60D1G) and initialize the peripherals. All that is left is for the user to write the application code in main.c file. Documentation for each of the peripheral libraries or diver libraries can be accessed as follows: . | Peripheral libraries APIs can be accessed as a HTML file (*.html) from the Harmony 3 Framework path. (framework_path/csp/docs/index.html) | BSP libraries APIs can be found in bsp.h | Driver libraries APIs can be accessed as a HTML file (*.html) from the Harmony 3 Framework path. (framework_path/core/docs/index.html) | . | 5.2. User can see DBGU_Initialize(), BSP_Initialize(), FLEXCOM0_TWI_Initialize() getting called in SYS_Initialze() function called from main.c. | 5.3. This project demonstrates below: . | Print serial console debug messages. | Write, Read and Compare the data from the EEPROM . | Print TEST PASS if write and read data from EEPROM matches and turn ON the blue LED on the board. | . | 5.4. API used are as follows: . | bool DBGU_Write( void* buffer, const size_t size ); | bool DBGU_WriteIsBusy( void ); | bool FLEXCOMx_TWI_Write(uint16_t address, uint8_t *pdata, size_t length); | bool FLEXCOMx_TWI_WriteRead(uint16_t address, uint8_t *wdata, size_t wlength, uint8_t *rdata, size_t rlength); | bool FLEXCOMx_TWI_IsBusy(void); | LED_BLUE_On(); | . | . Note: Refer section 5.1. to get the detailed API informations. | 5.5. Sample code to do the functionality mentioned in 5.3. is given below. | Global definition snippet: . | Initialization snippet: . | Main code snippet: . | . | 5.6. Sample code to access EEPROM is available here. Note: Modify the code as per the requirement. | 5.7. Click on the Clean and Build Project icon from the tools bar or select Project –&gt; Clean and Build Project from the menu bar. Observe that the build was completed successfully from the Output pane. | . Step 6: Console Serial Communications . Details . Console Serial communications between the Host PC and the SAM9X60 Curiosity Development Board take place through UART debug port J11. A terminal emulation program running on the Host PC communicates with the SAM9X60 Curiosity DBGU UART port. Ensure the terminal emulation program(Eg: PUTTY) is configured to the COM port and settings are: . | Speed: 115200 | Data: 8 | Parity: None | Stop Bits: 1 | . Step 7: Building/Downloading the at19Bootstrap . Details . The boot process of SAM9X60 begins with the MPU’s power-ON reset and progresses in stages reading binary files from external Non-Volatile Memory (NVM) and loading them into volatile memory (internal Static RAM (SRAM) and external Dynamic RAM (DRAM)). | 7.1. User can build the at91bootstrap file required to debug the application on MPLAB X IDE by following the steps mentioned here . or . | 7.2. User can get the pre-built at91bootstrap libraries by downloading the project from here as shown below. | . Unzip the downloaded project, at91bootstrap.elf can be found in the project folder(sam9x60_cu_graphics_getting_started/firmware/sam9x60_cu.X) . Step 8: Debugging the Project . Details . Ensure external JTAG debugger is connected to J12. | 8.1. Now, check debugger settings are proper . To do that right click on project –&gt; project properties –&gt; In the Categories pane (on left), select Conf: –&gt; J-Link –&gt; choose the connected external JTAG. Ensure, the device chosen is SAM9X60D1G. Choose the latest compiler version and latest Device Family Pack(DFP) as shown below. | 8.2. Click Apply. | 8.3. Now, load at91bootstrap. From Project properties –&gt; Config –&gt; Bootstrap –&gt; load bootstrap File(Use boot file from section 7) –&gt; Apply –&gt; Ok. | 8.4. By default, MPLAB X only produces ELF and Hex format output files. To generate binary files for SAM-BA programming, a post build step needs to be added to the project properties. To do this project properties –&gt; Building –&gt; Click the check box “Execute this line after build” –&gt; Enter the below command. \${MP_CC_DIR}/xc32-objcopy -O binary \${DISTDIR}/\${PROJECTNAME}.\${IMAGE_TYPE}.elf \${DISTDIR}/harmony.bin . Click Apply and ok. | 8.5. Observe debug reset and startup options. | To do this, In MPLAB X IDE, click on Tools –&gt; Options. An Options window opens. | Click on the Embedded icon at the top and the Generic Settings tab. | Observe the settings for: . | Debug Reset – Main | Debug startup – Halt at Main | . | . | . In the next step, when you debug the project, MPLAB X IDE will compile the project and download it to the target. With the debug settings listed above, the IDE will reset and halt at the beginning of main.c. | 8.6. Click on the Debug Main Project by left clicking the Debug icon on the toolbar. The project will build with debugging parameters and load the application binary to the SAM9X60 Curiosity Development Board(otherwise known as the target). Once the build is complete and the application binary is loaded into the target, the toolbar expands to show additional debugging icons. | 8.7. Click on the Continue button. The application binary runs within the target. User can observe the following output in the serial console terminal emulation application as shown below. | . Congratulations! You have opened, configured, built, and debugged an application program for MPLAB Harmony 3 Software Framework in MPLAB X IDE on SAM9X60 Curiosity Development Board. | NOTE . | Click here to learn how to configure first stage bootloader for SAM9X60 MPU | Click here to learn how to configure/built and debug second stage bootloader(at91bootstrap) for SAM9X60 MPU | Click here to flash the at91bootstrap and harmony application binaries using SAM-BA tool to NVMs like QSPI External Flash, NAND Flash or to SD Card | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#create-a-new-mplab-harmony-v3-sam9x60-curiosity-project-using-mcc-on-mplab-x-ide",
    "relUrl": "/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#create-a-new-mplab-harmony-v3-sam9x60-curiosity-project-using-mcc-on-mplab-x-ide"
  },"190": {
    "doc": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#reference-links",
    "relUrl": "/source/basic/sam9x60_getting_started_application_using_mcc/readme.html#reference-links"
  },"191": {
    "doc": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "title": "Getting started with SAM9X60 Curiosity Development Board using MPLAB Harmony 3",
    "content": "                                                                                                      . Note: . This document shows you how to create an MPLAB X IDE Harmony v3 project for a SAM9X60 Curiosity Development Board from scratch using the MPLAB Harmony v3 software framework. | SAM9X60 data sheet | SAM9X60 curiosity development board | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sam9x60_getting_started_application_using_mcc/readme.html",
    "relUrl": "/source/basic/sam9x60_getting_started_application_using_mcc/readme.html"
  },"192": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "Introduction",
    "content": "This document guides the user on how to configure boot configuration packet for first stage bootloader and how to ensure a valid code is available in second stage bootloader. The first stage bootloader (ROM code or Boot ROM or NVM bootloader) is a small piece of mask code, executed on power-on or reset. The first stage bootloader is responsible for loading the second-stage bootloader (User Application) from an external NVM into internal SRAM and execute it (Harmony uses the at91Bootstrap as its second stage boot loader). ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#introduction",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#introduction"
  },"193": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "First stage bootloader - Boot Sequence",
    "content": ". | The boot sequence is an ordered list of embedded memory controllers from which the ROM code tries to boot. User can modify the boot sequence by writing a valid Boot Configuration packet into the OTPC (One Time Programmable Memory controller) or Emulated OTPC (One Time Programmable Memory controller). | When no Boot Configuration Packet is available, ROM code will try to boot from one of the external NVMs in the following order: . | SDMMC1 IOSET1 | . | . If no bootable file or no valid boot code is found in memory, the ROM code goes to the SAM-BA monitor. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#first-stage-bootloader---boot-sequence",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#first-stage-bootloader---boot-sequence"
  },"194": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "First stage bootloader- Boot flow process",
    "content": ". | The ROM code boot flow process is shown below: . | The boot flow process is based on the values of the Boot Configuration Packet. | By default, the value of the Boot Configuration Packet is 0x0. | When no Boot Configuration Packet is available in the OTP User area, the ROM code uses the following settings: . | FLEXCOM3 IOSET 5 is used as a console. | Boot from SDMMC1 IOSET1 (uses card detect pin). | . | If no valid code is found in the SD Card or e.MMC, the ROM code goes to the standard monitor. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#first-stage-bootloader--boot-flow-process",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#first-stage-bootloader--boot-flow-process"
  },"195": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "Configure First stage bootloader",
    "content": ". | User can write the boot configuration packet either into the OTP matrix or emulation SRAM by setting emulation bit in the boot sequence controller configuration register (BSC_CR). | Boot configuration loading step is explained in the below flowchart: . | Using boot configuration packet, user can: . | Modify the boot sequence steps by enabling only the user preferred NVMs as below: 1. QSPI 2. e.MMC &lt;/b&gt; 3. SDCARD &lt;/b&gt; | Configure the console serial communications. | Disable SAM-BA Monitor. | . | User can write boot sequence controller configuration register (BSC_CR) and the boot configuration packet into OTPC or OTPC Emulated SRAM using SAM-BA tool. | Go to this link to download and configure SAM-BA. | Refer this document to install and setup SAM-BA. | . Note: . | Boot configuration using Emulation SRAM must be set every power cycle. Boot configuration using OTPC is one time. | It is recommended to write boot configuration packet (BCP) into Emulation SRAM in development phase and to OTPC (One Time Programmable Memory Controller) in the production phase. | . WARNING: once any user area packet has been programmed into the OTP matrix (OTPC), the emulation mode can never be enabled again. Be careful before writing a packet in the OTPC matrix ! . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#configure-first-stage-bootloader",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#configure-first-stage-bootloader"
  },"196": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "1. Configure First Stage Bootloader To Boot From QSPI Flash Memory",
    "content": "Use the below SAM-BA commands to configure the first stage bootloader to load the at91bootstrap from QSPI flash memory into SRAM and execute from SRAM. To learn about the boot process and first stage boot configuration, refer to section 19-Boot Strategies of the SAMA7G5 series data sheet. Note: It is mandatory to enable boot configuration packet to boot from QSPI for SAMA7G5 series. Steps to program Boot Configuration packet into Emulation SRAM: . | Enable Emulation sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_ENABLED | Read bscr and verify emulation is enabled sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bscr | Emulation SRAM Reset sam-ba -p j-link -b sama7g5-ek -a bootconfig -c resetemul | Refresh Emulation SRAM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:emul | Enable debug, QSPI0 as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-emul:DBGU,QSPI0_IOSET1 | Read bcp_emul and verify whether QSPI is set as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bcp-emul Now reset the board by pressing reset(nRST) button. | . Steps to program Boot Configuration packet into OTPC: . | Disable Emulation sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_DISABLED | Read bscr and verify emulation is disabled sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bscr | Refresh otp sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:otp | Enable debug, QSPI0 as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-otp:DBGU,QSPI0_IOSET1 | Read bcp_otp and verify whether QSPI is set as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bcp-otp Now reset the board by pressing the reset(nRST) button. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#1-configure-first-stage-bootloader-to-boot-from-qspi-flash-memory",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#1-configure-first-stage-bootloader-to-boot-from-qspi-flash-memory"
  },"197": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "2. Configure First Stage Bootloader to Boot From e.MMC Flash Memory",
    "content": "Use the below SAM-BA commands to configure the first stage bootloader to load the at91bootstrap from e.MMC flash memory into SRAM and execute from SRAM. To learn about the boot process and first stage boot configuration, refer to section 19-Boot Strategies of the SAMA7G5 series data sheet. Note: It is mandatory to enable boot configuration packet to boot from e.MMC for SAMA7G5 series. Steps to program Boot Configuration packet into Emulation SRAM: . | Enable Emulation sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_ENABLED | Read bscr and verify emulation is enabled sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bscr | Emulation SRAM Reset sam-ba -p j-link -b sama7g5-ek -a bootconfig -c resetemul | Refresh Emulation SRAM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:emul | Enable debug, SDMMC0 as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-emul:DBGU,SDMMC0_IOSET1 | Read bcp_emul and verify whether SDMMC0 is set as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bcp-emul Now reset the board by pressing reset(nRST) button. | . Steps to program Boot Configuration packet into OTPC: . | Disable Emulation sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_DISABLED | Read bscr and verify emulation is disabled sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bscr | Refresh otp sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:otp | Enable debug, SDMMC0 as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-otp:DBGU,SDMMC0_IOSET1 | Read bcp_otp and verify whether SDMMC0 is set as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bcp-otp Now reset the board by pressing the reset(nRST) button. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#2-configure-first-stage-bootloader-to-boot-from-emmc-flash-memory",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#2-configure-first-stage-bootloader-to-boot-from-emmc-flash-memory"
  },"198": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "3. Configure First Stage Bootloader to Boot From SDCARD Memory",
    "content": "Use the below SAM-BA commands to configure the first stage bootloader to load the at91bootstrap from SDCARD memory into SRAM and execute from SRAM. To learn about the boot process and first stage boot configuration, refer section 19-Boot Strategies of the SAMA7G5 series data sheet. Note: By default boot from SDCARD will be enabled in boot configuration packet for SAMA7G5 series. Steps to program Boot Configuration packet into Emulation SRAM: . | Enable Emulation sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_ENABLED | Read bscr and verify emulation is enabled sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bscr | Emulation SRAM Reset sam-ba -p j-link -b sama7g5-ek -a bootconfig -c resetemul | Refresh Emulation SRAM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:emul | Enable debug, SDMMC1 as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-emul:DBGU,SDMMC1_IOSET1 | Read bcp_emul and verify whether SDMMC1 is set as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bcp-emul Now reset the board by pressing reset(nRST) button. | . Steps to program Boot Configuration packet into OTPC: . | Disable Emulation sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_DISABLED | Read bscr and verify emulation is disabled sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bscr | Refresh otp sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:otp | Enable debug, SDMMC1 as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-otp:DBGU,SDMMC1_IOSET1 | Read bcp_otp and verify whether SDMMC1 is set as external NVM sam-ba -p j-link -b sama7g5-ek -a bootconfig -c readcfg:bcp-otp Now reset the board by pressing the reset(nRST) button. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#3-configure-first-stage-bootloader-to-boot-from-sdcard-memory",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#3-configure-first-stage-bootloader-to-boot-from-sdcard-memory"
  },"199": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "4. SAM-BA command to invalidate the Boot Configuration packet.",
    "content": "Use below command to remove last set configuration in boot configuration packet. | To invalidate bcp-emul. sam-ba -p j-link -b sama7g5-ek -a bootconfig -c invalidatecfg:bcp-emul | To invalidate bcp-otp. sam-ba -p j-link -b sama7g5-ek -a bootconfig -c invalidatecfg:bcp-otp | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#4-sam-ba-command-to-invalidate-the-boot-configuration-packet",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#4-sam-ba-command-to-invalidate-the-boot-configuration-packet"
  },"200": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "How first stage bootloader ensures the presence of valid second stage bootloader",
    "content": ". | The Boot ROM reads and analyzes the first 28 bytes corresponding to the first seven ARM exception vectors of second Stage bootloader (at91bootstrap) to decide whether the AT91bootstrap can be considered as valid, or it should be skipped. | Except for the sixth vector, other exception vector bytes must implement the ARM instructions for either branch or load PC with PC-relative addressing. The ROM code fetches the 6th exception vector value to know exactly how many bytes it should transfer from the external NVM instead of reading the maximum size allowed to the user application, hence speeding up the boot process. | If the external NVM chosen is SDCard/e.MMC, then BootROM looks for boot.bin file in the FAT formatted SDCard/e.MMC in addition to the ARM-exception vectors check. | The at91bootstrap code ensures the presence of the valid code by having the proper exception vector. It can be seen in crt0_gnu.s file in at91bootstrap source code. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#how-first-stage-bootloader-ensures-the-presence-of-valid-second-stage-bootloader",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#how-first-stage-bootloader-ensures-the-presence-of-valid-second-stage-bootloader"
  },"201": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#reference-links",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html#reference-links"
  },"202": {
    "doc": "SAMA7G54 Configure First Stage Bootloader",
    "title": "SAMA7G54 Configure First Stage Bootloader",
    "content": "                                                                                                      . Note: . This guide will explain how to configure first stage bootloader for SAMA7G54 family of microprocessors. | SAMA7G54 data sheet | SAMA7G54 Evaluation kit | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_first_stage_bootloader/readme.html",
    "relUrl": "/source/basic/sama7g54_configure_first_stage_bootloader/readme.html"
  },"203": {
    "doc": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "title": "Introduction",
    "content": "This training module describes the following for at91bootstrap, a second-stage bootloader for Microchip Technology Arm®-based Microprocessor Units (MPU), where to get the source code, how to configure, compile and debug using MPLAB® X IDE on windows host. | The following solution is tested based on at91bootstrap version 4.0.5. | The at91bootstrap bootloader can be stored in external NVMs like (SD Memory Card, Embedded Multimedia Card (eMMC), QSPI Flash). The first-stage bootloader (ROM Boot Code) will load at91bootstrap from external NVM depending on the value of the Boot Configuration Packet. | Click here to learn how to configure Boot Configuration Packet for SAMA7G54. | at91bootstrap if configured to do so, will initialize the following peripherals and memory controllers: . | Advanced Interrupt Controller (AIC) | Peripheral I/O Controller (PIO) | Power Management Controller (PMC) | Clock Generator (CKGR) | Static Memory Controller (HSMC) | NAND Flash Controller (NFC) | Multiport DDR-SDRAM Controller (MPDDRC) | Secure Digital Multimedia Card Controller (SDMMC) | . | at91bootstrap can be configured to load one of the following from external NVM into external volatile memory (DRAM) (main memory) and jump to: . | The third-stage bootloader (for example, Das U-Boot or BusyBox). | The Linux® kernel directly, thus it does not require a third-stage bootloader. | The Real Time Operating System (RTOS application). | Turn over control to the debugger (JTAG-Debugging alone). | The main program (Baremetal application). | . | at91bootstrap is written and maintained by Microchip Technology and hosted on GitHub. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#introduction",
    "relUrl": "/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#introduction"
  },"204": {
    "doc": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "title": "Required software and hardware tools",
    "content": "Details . This document is written with the assumption that the user is aware of the external NVMS &amp; DDR memory available in the respective SAMA7G54 boards (Like Evaluation Kits, SIP or SOM) by reading the respective user guide. | To build/debug at91bootstrap using MPLAB® X IDE on windows host, the following tools should be installed properly: . | Download and install MPLAB® X IDE. | Download and install XC32 Compiler. | . | User can use below hardware tools: . | SAMA7G54 Evaluation kit. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#required-software-and-hardware-tools",
    "relUrl": "/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#required-software-and-hardware-tools"
  },"205": {
    "doc": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "title": "Getting at91bootstrap Source Code",
    "content": "Details . | Create a Project Directory: Create a project directory to keep all the sources together for a given project. For the purpose of this tutorial topic, the created project directory is Harmony3. | Get at91bootstrap: Get the complete source code of at91bootstrap by either of the following ways: . | If you have git installed, clone the repo into the project directory by using the command: . $ git clone git@https://github.com/linux4sam/at91bootstrap . | If you don’t have git installed, then Download at91bootstrap and unzip into your project directory. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#getting-at91bootstrap-source-code",
    "relUrl": "/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#getting-at91bootstrap-source-code"
  },"206": {
    "doc": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "title": "Configure, build and debug at91bootstrap",
    "content": "Details . at91bootstrap can be configured to load the final application from any of the external NVMs available on the board like QSPI, e.MMC, SD CARD to DRAM and execute from it. User should follow the below steps to build the at91bootstrap as per their external NVM preference: . | Preparing the build Environment. | Configure the at91bootstrap. | Create a Custom Board Configuration. | Building the at91bootstrap. | Debugging the at91bootstrap. | . 1. Preparing the build Environment . Details . 1.1. Open at91Bootstrap project: To begin, launch MPLAB® X IDE and then go to File –&gt; Open Project –&gt;choose downloaded at91bootstrap project. Now set it as main project. &lt;img src = \\\"images/1_1a.png\\\" align=\\\"middle\\\"&gt; . 1.2. Compiler setting: User can use XC32 compiler to build at91bootstrap. Go to Project –&gt; Properties –&gt; Makefile —&gt; Copy the XC32 installation path and update it in the build/debug and clean command –&gt; Apply —&gt; ok. E.g. Build/Debug command: make CROSS_COMPILE=”C:/Program Files/Microchip/xc32/v4.30/bin/bin/pic32c-“ . Clean command: make mplabclean CROSS_COMPILE=\\\"C:/Program Files/Microchip/xc32/v4.30/bin/bin/pic32c-\\\" . 2. Configure the at91bootstrap . Details . The at91bootstrap can be configured to load from any one of the user-preferred NVMs by using KCONFIG. Depending on your hardware setup (sama7g54) and the preferred NVMs (Either QSPI or e.MMC or SD-Card) or to debug on MPLAB® X IDE, select one of the below options explained in the following sub-chapters. Legendry: board can be evaluation Kit (ek). E.g., sama7g54-ek. 2.1. Configure at91bootstrap for debug use with MPLAB® X IDE. 2.2. Configure at91bootstrap to load application from QSPI. 2.3. Configure at91bootstrap to load application from e.MMC. 2.4. Configure at91bootstrap to load application from SDCARD. In addition to the above configuration for the external NVMs, user can also customize the default configuration like external RAM size and type, external clock source etc. which is explained in section 2.5. 2.1 Configure at91bootstrap for debug use with MPLAB® X IDE . Details . The at91bootstrap built from sama7g54_bkptnone_defconfig can only be used for debugging the application using MPLAB® X IDE. Note: bkptnone_defconfig configures the at91bootstrap to continuously loops at the end of its execution, hence IDE can take over control (time-out message) and now continue to download the application in the user space. Therefore, this bkptnone_defconfig should be used only to debug the application using MPLAB X IDE. To do this, go to Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sama7g5ek_bkptnone_defconfig –&gt; Open. This will do the kconfig for building at91bootstrap for debug use with MPLAB X IDE. After opening the configuration file, the Kconfig will be as shown below. Now Click Apply –&gt; OK. 2.2. Configure at91bootstrap to load application from QSPI . Details . at91bootstrap can be configured to load the harmony application from QSPI into external volatile memory (DRAM) as follows. To do this, go to Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sama7g5ekdf_qspi_uboot_defconfig –&gt; Open . Legendry: df –&gt; Data Flash . Then perform the following changes: . | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup: . | Flash offset for Demo App –&gt; QSPI offset where a user wants to flash the application.: Eg: 0x200000. | Demo app image size –&gt; Size of the app image to be copied from QSPI to DRAM by at91bootstrap. | External RAM address to load Demo-App image –&gt; It should match the .text load address in your application linker script. Eg:0x6ff00000. | . | . An example configuration for SAMA7G54-EK is shown below. This completes the configuration for building at91bootstrap to load the harmony application from QSPI into external volatile memory (DRAM) and then execute it from DRAM. 2.3. Configure at91bootstrap to load application from e.MMC . Details . at91bootstrap can be configured to load the harmony application from NAND flash into external volatile memory (DRAM) as follows. Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sama7g5ekemmc_uboot_defconfig –&gt; Open. Then perform the following changes: . | Select SD Card Host Controller as On SDHC0. | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup: . | External RAM address to load Demo-App image –&gt; It should match the .text load address in your application linker script. Eg:0x6ff00000. | Next Software Image File name –&gt; Name of your application binary. Eg:harmony.bin. | . | . An example configuration for SAMA7G54-EK is shown below. It completes the kconfig for building at91bootstrap to load the harmony application from e.MMC flash into external volatile memory (DRAM) and then execute it from DRAM. 2.4. Configure at91bootstrap to load application from SDCARD . Details . at91bootstrap can be configured to load the harmony application from SD card memory into external volatile memory (DRAM) as follows. Project –&gt; Properties –&gt; Kconfig –&gt; load –&gt; project directory –&gt; configs –&gt; sama7g5eksd_uboot_defconfig –&gt; Open. Then perform the following changes: . | Select SD Card Host Controller as On SDHC1. | Next software type –&gt; Load 4MB into the start of SDRAM. | Demo application image storage setup. | External RAM address to load Demo-App image –&gt; It should match the .text load address in your application linker script. Eg:0x6ff00000. | Next Software Image File name –&gt; Name of your application binary. Eg:harmony.bin. | . | . An example configuration for SAMA7G54-EK is shown below. It completes the kconfig for building at91bootstrap to load the harmony application from SD card memory into external volatile memory (DRAM) and then execute it from DRAM. 2.5. Customizing other default configuration . Details . User can customize the clock source, Display Banner (Display banner is the output string in the serial console when at91bootstrap begins running), external RAM-type and size, different SD card slot if SDCard is the user preferred NVM on the default configuration. To do this, go to Project –&gt; Properties –&gt; Kconfig. An example customization using SAMA7G54-EK board is shown below: . 3. Create a Custom Board Configuration . Details . This section is for advanced developers who wish to create a custom board configuration (almost from scratch) for the at91bootstap bootloader for their custom board. | Dependencies . | Linux Host: It is recommended to do customization using Linux Host. | GIT: Install GIT and clone at91bootstrap by using the following command: . $ git clone https://github.com/linux4sam/at91bootstrap.git . | Then follow the steps in this link to do customization and contribution of your customized code to Microchip at91bootstrap. | . | . 4. Building the at91bootstrap . Details . To build the at91bootstrap go to project –&gt; Clean and build or simply click the build icon in the IDE. Note: When building using XC32 compiler, if a user doesn’t have XC32 pro compiler, a warning saying cannot optimize size will pop up in the compiler output window as follows. To avoid this either use XC32 pro compiler or just ignore this. Once the build is successful, you will get the build success message in the IDE as shown in the above Image. Now user will be able to see the boot.bin file in the project directory/build/binaries. boot.bin file is the at91bootstrap file. Now the user can use the boot.bin file to . | Flash it to the respective NVM. (or) | Debug the at91bootstrap using MPLAB X IDE as explained in the next section. | . 5. Debugging the at91bootstrap . Details . To debug the at91bootstrap, go to project –&gt; Set as main project. Then click project –&gt; Debug or simply click the debug icon in the IDE. Now user can start debugging the at91bootstrp by clicking the debug symbols available in the IDE like Step into, Reset, Step over etc. When debugging the application, serial console outputs can be monitored by connecting windows host with the board (Eg: SAMA7G54-EK) through a terminal emulation program. An example image showing the serial console output while debugging at91bootstrap is shown below. This completes the training module to configure, build &amp; debug at91bootstrap for different user preferred NVMs. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#configure-build-and-debug-at91bootstrap",
    "relUrl": "/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#configure-build-and-debug-at91bootstrap"
  },"207": {
    "doc": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "title": "Note",
    "content": ". | Click here to learn how to configure first stage bootloader for SAMA7G54 MPU | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#note-1",
    "relUrl": "/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#note-1"
  },"208": {
    "doc": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#reference-links",
    "relUrl": "/source/basic/sama7g54_configure_second_stage_bootloader/readme.html#reference-links"
  },"209": {
    "doc": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "title": "Configure the second stage bootloader for SAMA7G54 based MPUs",
    "content": "                                                                                                      . Note: . This guide will teach you how to configure the second stage bootloader for SAMA7G54 based MPUs. | SAMA7G54 data sheet | SAMA7G54 Evaluation kit | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_configure_second_stage_bootloader/readme.html",
    "relUrl": "/source/basic/sama7g54_configure_second_stage_bootloader/readme.html"
  },"210": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "Introduction",
    "content": "This document will guide the user on how to, . | Write boot sequence controller configuration register (BSC_CR) &amp; boot configuration packet to configure first stage bootloader. | Flash boot.bin (at91bootstrap) &amp; harmony.bin (RTOS/Baremetal application) file to external NVMs like QSPI flash, e.MMC &amp; SD-Card. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#introduction",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#introduction"
  },"211": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "Prerequisites",
    "content": "Details . | Familiar with the features of the SAM7G54-EK (board can be evaluation Kit) and understanding about the jumpers &amp; Connectors on the board. | Install SAM-BA tool on your windows host PC. | To Download the latest version of SAM-BA tool for Windows click this link. | Download the ZIP file and unzip it into a working directory of your choice. | Add the SAM-BA directory path to the environment variables. | To do this from your PC –&gt; Open the Start Search, type in “env”. | Choose “Edit the system environment variables” –&gt; Click “Environment Variables” –&gt; “System Variables” –&gt; add SAM-BA directory path to path variables. | . | Once the SAM-BA Host program has been installed, the execution of the application is from the Windows command prompt. | . | Refer this link to configure and build the at91bootstrap to load the application from the user preferred NVM like QSPI flash, e.MMC &amp; SDCard. Note: This resultant at91bootstrap file (boot.bin) built with the preferred NVM configuration only to be used here. | Refer this link to build harmony application. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#prerequisites",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#prerequisites"
  },"212": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "Setup SAM-BA Host to Monitor Communications",
    "content": "Details . In this section you will establish SAM-BA Host Application communications with the target’s (SAMA7G54) SAM-BA Monitor. Then you will use the SAM-BA Host Applet (qspiflash) to erase and then write the boot.bin (at91bootstrap) and harmony.bin (MPLAB Harmony 3 application) binary images to NOR Flash Memory. Step 1: To communicate with the SAM-BA Monitor on the target, you must have installed the SAM-BA Host on a Host Computer. Step 2: Ensure there is no SD memory card inserted. Step 3: Power the board by connecting a Micro-B USB cable to USBA port (J7) on the SAMA7G54-EK. Step 4: Establish UART serial communication with PC through J24 on SAMA7G54 Evaluation Kit. Step 5: Open Disable boot Jumper(J22) on SAMA7G54 Evaluation Kit. Step 6: Follow below steps for SAMA7G54 Evaluation Kit: . | Push and hold the “DISABLE BOOT” button. (This disables booting from the onboard memories - e.MMC Flash, SDCARD and QSPI flash Memory). | Reset the board by pressing and then releasing the reset “nRST” button. | Release the “DISABLE BOOT” button. | . Now, the SAMA7G54-EK will boot to the SAM-BA Monitor and start communications with the SAM-BA Host Application. Note: . | SAM-BA communication Port can be j-link, serial or secure. | If user wants to program the SAMA7G54 Evaluation Kit, using j-link instead of serial UART port, then connect J24 with PC via USB cable and replace “serial” in SAM-BA commands with “j-link”. | Eg: Replace sam-ba -p serial -b sama7g5-ek -a lowlevel with sam-ba -p j-link -b sama7g5-ek -a lowlevel | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#setup-sam-ba-host-to-monitor-communications",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#setup-sam-ba-host-to-monitor-communications"
  },"213": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "1. Program External QSPI flash memory",
    "content": "Details . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#1-program-external-qspi-flash-memory",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#1-program-external-qspi-flash-memory"
  },"214": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "1.1. Erase QSPI flash memory",
    "content": "Erase the contents of the QSPI Flash memory on the SAMA7G54-EK with the following command: . sam-ba -p j-link -b sama7g5-ek -a qspiflash -c erase . Example: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#erase-qspi-flash-memory",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#erase-qspi-flash-memory"
  },"215": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "1.2. Program boot.bin to QSPI flash memory",
    "content": "Program the boot.bin file on the SAMA7G54-EK with the following command: . sam-ba -p j-link -b sama7g5-ek -a qspiflash -c writeboot:boot.bin . | Note: Change directory to the location of boot.bin | . Example: . Note: Refer this link to configure and build the at91bootstrap to load the application from QSPI. The at91bootstrap file (boot.bin) built with QSPI configuration only to be used here. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#program-bootbin-to-qspi-flash-memory",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#program-bootbin-to-qspi-flash-memory"
  },"216": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "1.3. Program harmony.bin to QSPI flash memory",
    "content": "To program the application binary, harmony.bin file on the SAMA7G54-EK, use the following command: . sam-ba -p j-link -b sama7g5-ek -a qspiflash -c write:harmony.bin:&lt;QSPI_OFFSET&gt; . Note: * The &lt;QSPI_OFFSET&gt; should be the same offset used in the KCONFIG, while configuring the at91bootstrap to load from external QSPI * Change directory to the location of harmony.bin. Example: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#program-harmonybin-to-qspi-flash-memory",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#program-harmonybin-to-qspi-flash-memory"
  },"217": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "Note:",
    "content": "To learn about more SAM-BA applet commands, refer your SAM-BA installation directory/doc/applet.html . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#note",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#note"
  },"218": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "2. Program External e.MMC Flash Memory",
    "content": "Details . To boot from e.MMC flash memory, we need to flash sdcard.img file in user partition area in e.MMC flash memory. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#2-program-external-emmc-flash-memory",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#2-program-external-emmc-flash-memory"
  },"219": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "2.1. Create sdcard.img file for boot.bin and harmony.bin.",
    "content": "To create .img file we need an SDCARD and a windows tool named Win32DiskImager. Click here to download the tool. | First Partition the SDCARD with size of 4MB and format SDCARD with FAT or FAT32 file system. | Now place the boot.in and harmony.bin in SDCARD. | Install Win32DiskImager Tool and open the tool. | In Device tab, select the drive for which the image file needs to be created. | In ImageFile tab, enter the path and file name with extention(.img) to store the generated image file. | Now select the check box next to Read Only Allocated Partitions and click on Read button. | When reading is completed, a pop-up window will be displayed with status as Read Successful. | Now the generated image(.img) file will be available in above mentioned location. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#create-sdcardimg-file-for-bootbin-and-harmonybin",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#create-sdcardimg-file-for-bootbin-and-harmonybin"
  },"220": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "2.2. Program sdcard.img file to e.MMC flash memory",
    "content": "To program the sdcard.img file on the SAMA7G54-EK with the following command: . sam-ba -p j-link -b sama7g5-ek -a sdmmc -c write:sdcard.img . Example: . Note: Refer this link to configure and build the at91bootstrap to load the application from e.MMC flash memory. The at91bootstrap file (boot.bin) built with e.MMC configuration only to be used here. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#program-sdcardimg-file-to-emmc-flash-memory",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#program-sdcardimg-file-to-emmc-flash-memory"
  },"221": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "Note:",
    "content": "To learn about more SAM-BA applet commands, refer your SAM-BA installation directory/doc/applet.html . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#note-1",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#note-1"
  },"222": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "3. Program External SD CARD",
    "content": "Details . To program the at91bootstrap -boot.bin file and application binary -harmony.bin file on SD-card: . | (i) Format the SD card using your PC/Laptop. | (ii) Copy and paste boot.bin and harmony.bin into the SD card from your host PC. | . Note: Refer this link to configure and build the at91bootstrap to load the application from SD Card. The at91bootstrap file (boot.bin) built with SD card configuration should be used here. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#3-program-external-sd-card",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#3-program-external-sd-card"
  },"223": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "4. Program BSC_CR &amp; Boot Configuration Packet",
    "content": "Details . After a reset, The ROM code reads the Boot Configuration Packet from the SRAM dedicated to Emulation mode if the bit BSC_CR.EMUL_EN is set to 1 or from the OTP matrix and configure boot sequence, Enable/Disable Monitor, configure the serial console UART. Using Emulated OTP enables the user to test several boot configuration options, including secure boot mode without programming the OTP. Note: If Emulation mode is enabled, the emulation SRAM is not backed up. After a power off/on, the configuration and content are lost. ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#4-program-bsc_cr--boot-configuration-packet",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#4-program-bsc_cr--boot-configuration-packet"
  },"224": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "4.1. Enable/Disable Emulation mode in BSC_CR",
    "content": "To Enable/Disable Emulation mode in Boot Sequence Controller Configuration Register (BSC_CR), the following SAM-BA command should be used: . To Enable Emulation Mode: . sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr: EMULATION_ENABLED . To Disable Emulation Mode: . sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr: EMULATION_DISABLED . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#enabledisable-emulation-mode-in-bsccr",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#enabledisable-emulation-mode-in-bsccr"
  },"225": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "4.2. Steps to write Boot Configuration Packet to emulated SRAM",
    "content": ". | Emulation enable : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_ENABLED | Reset : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c resetemul | Refresh config : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:emul | Write Config : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-emul:DBGU,SDMMC0_IOSET1 | Lock config : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c lockcfg:bcp-emul | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-emulated-sram",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-emulated-sram"
  },"226": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "4.3. Steps to write Boot Configuration Packet to OTP",
    "content": ". | Emulation disable: sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bscr:EMULATION_DISABLED | Refresh config : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c refreshcfg:otp | Write Config : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:bcp-otp:DBGU,SDMMC0_IOSET1 | Lock config : sam-ba -p j-link -b sama7g5-ek -a bootconfig -c lockcfg:bcp-otp | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-otp",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#steps-to-write-boot-configuration-packet-to-otp"
  },"227": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "4.4. Boot Configuration Packet different configurations available",
    "content": "The writecfg command programs the Boot Configuration Packet (BCP) into the Emulated SRAM, if the emulation mode of the OTPC is enabled. Else BCP packets are stored inside the OTP matrix. User can use the below command to get the full list of boot configurations possible: . sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg:help . Example boot configurations: . boot config with Serial Console on FLEXCOM0, boot from SDMMC1 store in OTP matrix . sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg: bcp-otp:FLEXCOM0_USART_IOSET1,SDMMC1_IOSET1 . Empty boot configuration packet in OTP matrix . sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg: bcp-otp: . Boot config with SAM-BA Monitor Disabled, boot from SDMMC1 store in OTP-Emulation mode . sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg: bcp-emul:MONITOR_DISABLED,SDMMC1_IOSET1 . Empty boot configuration packet in OTP-Emulation mode- Emulated SRAM . sam-ba -p j-link -b sama7g5-ek -a bootconfig -c writecfg: bcp-emul: . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#boot-configuration-packet-different-configurations-available",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#boot-configuration-packet-different-configurations-available"
  },"228": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "Note:",
    "content": "To learn about more bootconfig SAM-BA applet commands: Refer your SAM-BA installation directory/doc/bootconfig-otp.html . Links . | Click here to learn how to configure first stage bootloader for SAMA7G54 MPU | Click here to learn how to configure/built and debug second stage bootloader(at91bootstrap) for SAMA7G54 MPU | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#note-2",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#note-2"
  },"229": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#reference-links",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html#reference-links"
  },"230": {
    "doc": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "title": "SAMA7G54 Flash boot and harmony application binaries using SAM BA",
    "content": "                                                                                                      . Note: . This guide will explain how to use SAM-BA to Write Boot Configuration Packet &amp; Flash at91bootstrap, RTOS/Baremetal applications to external NVM for SAMA7G54. | SAMA7G54 data sheet | SAMA7G54 Evaluation kit | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_flash_boot_application_using_samba/readme.html",
    "relUrl": "/source/basic/sama7g54_flash_boot_application_using_samba/readme.html"
  },"231": {
    "doc": "SAMBA installation and setup for SAMA7G54 EK",
    "title": "SAM-BA Installation and Setup:",
    "content": "Install SAM-BA tool on your windows host PC. | To Download the latest version of SAM-BA tool for Windows click this link. | Download the ZIP file and unzip it into a working directory of your choice. | Add the SAM-BA directory path to the environment variables. | To do this from your PC –&gt; Open the Start Search, type in “env”. | Choose “Edit the system environment variables”. | In System Properties window, Click on “Environment Variables” in Advanced tab. | In Environment Variables window, double click on “path” in System Variables section. | Add SAM-BA directory path to path variables. | . | Once the SAM-BA Host program has been installed, the execution of the application is from the Windows command prompt. | Now open Windows command prompt and enter the below command to ensure sam-ba is installed properly. sam-ba -v | . Setup to flash using SAM-BA: . | Open Disable boot Jumper(J22) on SAMA7G54-EK Evaluation Kit. | Ensure there is no SD memory card inserted. | Power up the SAMA7G54-EK Evaluation Kit by connecting 5V/2A power adapter to J1 connector or by connecting a micro-usb cable to J7 connector. | Connect micro-usb cable to J24. J24 will work as CDC COM Port as well as Onboard debugger. | Press and release start(nSTART) button. | Push and hold the “DISABLE_BOOT” button. (This disables booting from the onboard memories - QSPI, e.MMC and SDCARD) | Reset the board by pressing and then releasing the reset “nRST” button. | Release the “DISABLE_BOOT” button. | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_samba_installation_setup/readme.html#sam-ba-installation-and-setup",
    "relUrl": "/source/basic/sama7g54_samba_installation_setup/readme.html#sam-ba-installation-and-setup"
  },"232": {
    "doc": "SAMBA installation and setup for SAMA7G54 EK",
    "title": "SAMBA installation and setup for SAMA7G54 EK",
    "content": "                                                                                                      . Note: . This guide will teach you how to install and setup SAM-BA tool for SAMA7G54-EK. | SAMA7G54 Evaluation kit | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/sama7g54_samba_installation_setup/readme.html",
    "relUrl": "/source/basic/sama7g54_samba_installation_setup/readme.html"
  },"233": {
    "doc": "Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project",
    "title": "Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project",
    "content": "This tutorial shows you how to update and configure an existing MPLAB Harmony Configurator (MHC)-based MPLAB Harmony v3 project to MPLAB Code Configurator (MCC)-based project. This training module uses the Getting Started Extended Application on Curiosity PIC32MZ EF 2.0 Development Board to update and configure an existing project. The application makes use of Curiosity PIC32MZEF v2 Development Board and I/O1 Xplained Pro Kit (optional if you intend to exercise the extended functionality described below). Note: Though this application uses the PIC32MZEF microcontroller as an example, the general description and steps to install, configure, and generate code using MCC applies to all 32-bit PIC and SAM microcontrollers. This application demonstrates an LED toggle (LED1 toggles when the switch SW1 is pressed and LED3 toggles when switch SW3 is pressed) on a timeout basis and prints the LED toggling rate on the serial terminal. The periodicity of the timeout will change from 500 milliseconds to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch SW1 or SW3 on the Curiosity PIC32MZ EF 2.0 Development Board. The periodicity will not change while switching between SW1 to SW3 or vice versa. The demo application has extended functionality to print the current room temperature periodically when switch SW2 is pressed (the Xplained pro extension connector on the Curiosity PIC32MZ EF 2.0 Development Board must be plugged with I/O1 Xplained Pro Extension Kit). This application will utilize: . | Timer Peripheral Library to periodically sample temperature sensor data and to toggle LED. | I2C Peripheral Library to read the temperature from a temperature sensor. | Universal Asynchronous Receiver Transmitter (UART), Direct Memory Access (DMA) Peripheral Libraries to print the temperature values on a COM (serial) port terminal application running on a PC. | GPIO Peripheral Library to toggle the LED. | Help develop your first MPLAB Harmony v3 application using MCC. In the process, the lab will also demonstrate the use of callback functions. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html#update-and-configure-an-existing-mhc-based-mplab-harmony-v3-project-to-mcc-based-project",
    "relUrl": "/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html#update-and-configure-an-existing-mhc-based-mplab-harmony-v3-project-to-mcc-based-project"
  },"234": {
    "doc": "Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html",
    "relUrl": "/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html"
  },"235": {
    "doc": "Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project",
    "title": "Web Links",
    "content": ". | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html#web-links",
    "relUrl": "/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html#web-links"
  },"236": {
    "doc": "Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html#reference-links",
    "relUrl": "/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html#reference-links"
  },"237": {
    "doc": "Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project",
    "title": "Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html",
    "relUrl": "/source/basic/update_mhc_harmony_3_project_to_mcc/readme.html"
  },"238": {
    "doc": "Harmony Basics",
    "title": "MPLAB Harmony Basics Documentation",
    "content": "This page contains quick documentation for MPLAB® Harmony 3 Basics. | MPLAB Code Configurator (MCC) for Harmony 3 Projects . | MPLAB Harmony 3 Configurator (MHC) . | MHC Project Graph . | MHC Clock Configuration . | MHC Pin Configuration . | MHC NVIC Configuration . | MHC DMA Configuration . | MHC Memory protection Unit Configuration . | MHC Code Generation . | MHC Window Manager and Log Level . | Create First MPLAB Harmony 3 Project . | Create “Hello World” application on SAM MCUs . | Create “Hello World” application on PIC MCUs . | Open an Existing Harmony 3 Project . | Harmony 3 Packages . | Create IAR or Keil project using MHC . | Create new TrustZone Project . | Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers . | Difference Between MPLAB Harmony v3 PLIBs and Drivers . | MPLAB Harmony v3 Synchronous drivers and their usage in FreeRTOS based applications . | Create a new MPLAB Harmony v3 project using MCC . | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project . | Add a New Configuration to an Existing MPLAB Harmony v3 Project . | MPLAB Harmony v3 Project Manifest Feature . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#mplab-harmony-basics-documentation",
    "relUrl": "/source/basic/readme.html#mplab-harmony-basics-documentation"
  },"239": {
    "doc": "Harmony Basics",
    "title": "Microprocessor units (MPUs)",
    "content": ". | Configure first stage bootloader for SAM9X60 MPU . | Configure/built and debug second stage bootloader(at91bootstrap) for SAM9X60 MPU . | Develop a harmony based application for SAM9X60 MPU using MPLAB® X IDE . | Flash the at91bootstrap and harmony application binaries of SAM9X60 MPU using SAM-BA tool . | Configure at91bootstrap to enable QSPI-XIP on MPUs . | Develop a harmony based application executed from QSPI for SAM9X60 MPU using MPLAB® X IDE . | Configure first stage bootloader for SAMA7G5 MPU . | Configure/built and debug second stage bootloader(at91bootstrap) for SAMA7G5 MPU . | SAM-BA installation and initialization for SAMA7G5 MPU . | Flash the at91bootstrap and harmony application binaries of SAMA7G5 MPU using SAM-BA tool . | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#microprocessor-units-mpus",
    "relUrl": "/source/basic/readme.html#microprocessor-units-mpus"
  },"240": {
    "doc": "Harmony Basics",
    "title": "Web Links",
    "content": ". | How to Get Started with MPLAB Harmony v3 | Create a New MPLAB Harmony v3 Project | How to Set Up MPLAB Harmony v3 Software Development Framework | MPLAB Harmony Content Manager | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#web-links",
    "relUrl": "/source/basic/readme.html#web-links"
  },"241": {
    "doc": "Harmony Basics",
    "title": "Videos",
    "content": ". Note: . This page provides a quick reference covering the Basic features of MPLAB Harmony 3. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#videos",
    "relUrl": "/source/basic/readme.html#videos"
  },"242": {
    "doc": "Harmony Basics",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html#reference-links",
    "relUrl": "/source/basic/readme.html#reference-links"
  },"243": {
    "doc": "Harmony Basics",
    "title": "Harmony Basics",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/basic/readme.html",
    "relUrl": "/source/basic/readme.html"
  },"244": {
    "doc": "Create a Touch Project",
    "title": "Generate a Touch Project with MPLAB® Harmony",
    "content": "This guide shows you how to create a Touch project with the MPLAB® Harmony platform where you can graphically add sensors and configure QTouch® parameters. This project uses the SAMC21N Xplained Pro Evaluation Kit board along with the QT1 Mutual Capacitance Xplained Pro Extension Kit. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html#generate-a-touch-project-with-mplab-harmony",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html#generate-a-touch-project-with-mplab-harmony"
  },"245": {
    "doc": "Create a Touch Project",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html"
  },"246": {
    "doc": "Create a Touch Project",
    "title": "Web Links",
    "content": ". | Generate a Touch Project with MPLAB® Harmony | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html#web-links",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html#web-links"
  },"247": {
    "doc": "Create a Touch Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html#reference-links",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html#reference-links"
  },"248": {
    "doc": "Create a Touch Project",
    "title": "Create a Touch Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_a_touch_project/readme.html",
    "relUrl": "/source/middleware/create_a_touch_project/readme.html"
  },"249": {
    "doc": "Create first Audio Application",
    "title": "Creating Your First Audio Application from Scratch",
    "content": "This tutorial provides information on how to create an audio project using MPLAB Harmony 3 and the SAM E70 Xplained Ultra board. It starts with a blank MPLAB® project and finishes with an audio application that is a subset of the audio_tone application. To keep the application as simple as possible, no graphics or other UI are included. It simply outputs a 1000 Hz sine wave over the I2S interface at 48,000 samples/sec. The sine tone is generated internally using math functions (no audio inputs). For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html#creating-your-first-audio-application-from-scratch",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html#creating-your-first-audio-application-from-scratch"
  },"250": {
    "doc": "Create first Audio Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html"
  },"251": {
    "doc": "Create first Audio Application",
    "title": "Web Links",
    "content": ". | Creating Your First Audio Application from Scratch | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html#web-links"
  },"252": {
    "doc": "Create first Audio Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html#reference-links"
  },"253": {
    "doc": "Create first Audio Application",
    "title": "Create first Audio Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_application/readme.html"
  },"254": {
    "doc": "Create first Audio Decoder Application",
    "title": "Creating Your First Audio Decoder Application from Scratch",
    "content": "This tutorial provides information on how to create an audio decoder project using MPLAB Harmony 3 and the SAM E70 Xplained Ultra board. It starts with a blank MPLAB® project and finishes with an audio decoder capable of playback of a WAV encoded file located on a USB flash drive, very similar to the audio_player_basic app in the audio . To keep the application as simple as possible, no graphics or other program controls are included. It simply reads the statically specified file from the USB flash drive, sets up the codec sample rate, and outputs the data from the WAV file over the I2S interface at the sample rate specified in the WAV file. The WAV file for this project will be created externally as dual channel, 16 bit data, at 16,000 Hz sample rate and will say “Hello World”. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html#creating-your-first-audio-decoder-application-from-scratch",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html#creating-your-first-audio-decoder-application-from-scratch"
  },"255": {
    "doc": "Create first Audio Decoder Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html"
  },"256": {
    "doc": "Create first Audio Decoder Application",
    "title": "Web Links",
    "content": ". | Creating Your First Audio Decoder Application from Scratch | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html#web-links"
  },"257": {
    "doc": "Create first Audio Decoder Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html#reference-links"
  },"258": {
    "doc": "Create first Audio Decoder Application",
    "title": "Create first Audio Decoder Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_audio_decoder_application/readme.html",
    "relUrl": "/source/middleware/create_first_audio_decoder_application/readme.html"
  },"259": {
    "doc": "Create first Bluetooth Application",
    "title": "Creating Your First Bluetooth Application from Scratch",
    "content": "This page provides a user a quick start guide for building their first Bluetooth project in Harmony 3. This tutorial provides information on how to create a Bluetooth project using MPLAB Harmony 3. To keep the application as simple as possible, a very minimal UI is included (one button and one LED). It connects to a smartphone (iPhone or Android) using BLE (Bluetooth Low Energy), and sends a string of characters to the smartphone when a button is pressed. The following hardware setup is supported: . | SAM E70 Xplained Ultra board | BM64 Bluetooth Radio Daughter Board | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html#creating-your-first-bluetooth-application-from-scratch",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html#creating-your-first-bluetooth-application-from-scratch"
  },"260": {
    "doc": "Create first Bluetooth Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html"
  },"261": {
    "doc": "Create first Bluetooth Application",
    "title": "Web Links",
    "content": ". | Creating Your First Bluetooth Application from Scratch | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html#web-links"
  },"262": {
    "doc": "Create first Bluetooth Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html#reference-links"
  },"263": {
    "doc": "Create first Bluetooth Application",
    "title": "Create first Bluetooth Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_bluetooth_application/readme.html",
    "relUrl": "/source/middleware/create_first_bluetooth_application/readme.html"
  },"264": {
    "doc": "Create first Motor Control Application",
    "title": "Create your first Motor Control Application",
    "content": "This page shows you how to use MHC to create a motor control application Brushless DC (BLDC) block commutation using a hall sensor on a SAM E54 microcontroller. This application reads the pattern from the hall sensor mounted on the motor shaft. Based on the hall pattern, the corresponding commutation is forced to the motor windings through three-phase inverters. The motor speed can be increased or decreased using the reference potentiometer in the MCLV-2 board. Two momentary switches are used, one for Start/Stop operation and the other for direction control (Forward/Reverse). The application will utilize: . | Position Decoder (PDEC) Peripheral Library (PLIB) to read the hall pattern from the hall sensor. | Timer/Counter for Control Applications (TCC0) PLIB to create three pairs of Pulse Width Modulation (PWM) frequency for three-phase inverters and to trigger the ADC0 periodically. | Analog-to-Digital Converter (ADC0) PLIB to read the output voltage of potentiometer to determine the speed. | Timer/Counter (TC0) PLIB used as an internal 1 mS timer counter. | Timer/Counter (TC1) PLIB used as a timer to measure the time elapsed between two consecutive hall edges. | Event System (EVSYS) PLIB used as a traffic controller between TCC0 (event generator) and ADC0 (event user). | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html#create-your-first-motor-control-application",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html#create-your-first-motor-control-application"
  },"265": {
    "doc": "Create first Motor Control Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html"
  },"266": {
    "doc": "Create first Motor Control Application",
    "title": "Web Links",
    "content": ". | Create your first Motor Control Application using MPLAB Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html#web-links"
  },"267": {
    "doc": "Create first Motor Control Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html#reference-links"
  },"268": {
    "doc": "Create first Motor Control Application",
    "title": "Create first Motor Control Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_motor_control_application/readme.html",
    "relUrl": "/source/middleware/create_first_motor_control_application/readme.html"
  },"269": {
    "doc": "Create first TCPIP Application",
    "title": "Create your first TCP/IP Application",
    "content": "This tutorial is a getting-started guide to demonstrate how to create a MPLAB® Harmony 3 based TCP/IP application project. This tutorial implements a simple TCP/IP Client application on a microcontroller development board. This will guide you through the steps required to create a new TCP/IP application using MPLAB® Harmony 3 modules. Note : The getting-started guide demonstrates the creation of a TCP/IP demo on the SAM E70 Xplained Ultra board with the LAN8740 PHY Daughter board. These steps can be applied for other development boards applying the device/board specific configuration changes. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html#create-your-first-tcpip-application",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html#create-your-first-tcpip-application"
  },"270": {
    "doc": "Create first TCPIP Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html"
  },"271": {
    "doc": "Create first TCPIP Application",
    "title": "Web Links",
    "content": ". | Create your first TCP/IP Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html#web-links"
  },"272": {
    "doc": "Create first TCPIP Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html#reference-links"
  },"273": {
    "doc": "Create first TCPIP Application",
    "title": "Create first TCPIP Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_tcpip_application/readme.html",
    "relUrl": "/source/middleware/create_first_tcpip_application/readme.html"
  },"274": {
    "doc": "Create first USB device application",
    "title": "Create your first USB Device Application",
    "content": "The purpose of this tutorial is to show you how to create an MPLAB® Harmony 3 project that enumerates as a USB CDC Device. The application demonstrates two-way communication between the USB Device and the USB Host PC. This tutorial focuses on using the interoperable MPLAB® Harmony USB Device stack and CDC Function driver in your application. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html#create-your-first-usb-device-application",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html#create-your-first-usb-device-application"
  },"275": {
    "doc": "Create first USB device application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html"
  },"276": {
    "doc": "Create first USB device application",
    "title": "Web Links",
    "content": ". | Create your first USB Device Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html#web-links"
  },"277": {
    "doc": "Create first USB device application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html#reference-links"
  },"278": {
    "doc": "Create first USB device application",
    "title": "Create first USB device application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_device_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_device_application/readme.html"
  },"279": {
    "doc": "Create first USB Host application",
    "title": "Create your first USB Host Application",
    "content": "The purpose of this tutorial is to show you how to create a MPLAB® Harmony 3 project that uses the MPLAB® Harmony File System to create a file on a USB Mass Storage Device (eg: USB Pen Drive). The application will provide a LED indication when the file create process has completed. This tutorial focuses on using the interoperable MPLAB® Harmony USB Host stack and Harmony File System service in your application. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html#create-your-first-usb-host-application",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html#create-your-first-usb-host-application"
  },"280": {
    "doc": "Create first USB Host application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html"
  },"281": {
    "doc": "Create first USB Host application",
    "title": "Web Links",
    "content": ". | Create your first USB Host Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html#web-links"
  },"282": {
    "doc": "Create first USB Host application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html#reference-links"
  },"283": {
    "doc": "Create first USB Host application",
    "title": "Create first USB Host application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_usb_host_application/readme.html",
    "relUrl": "/source/middleware/create_first_usb_host_application/readme.html"
  },"284": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Create your first WIN1500 Bypass mode example using Harmony TCP/IP stack",
    "content": "This tutorial is a getting-started guide to demonstrate how to create a WINC1500 Bypass (Ethernet) mode example using MPLAB® Harmony v3 TCP/IP stack. This tutorial implements a simple STA Client application on a microcontroller development board. This will guide you through the steps required to create a new TCP/IP application using MPLAB® Harmony 3 modules. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html#create-your-first-win1500-bypass-mode-example-using-harmony-tcpip-stack",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html#create-your-first-win1500-bypass-mode-example-using-harmony-tcpip-stack"
  },"285": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html"
  },"286": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Web Links",
    "content": ". | Create your first WIN1500 Bypass mode example using Harmony TCP/IP stack | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html#web-links",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html#web-links"
  },"287": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html#reference-links",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html#reference-links"
  },"288": {
    "doc": "Create Your First WINC Bypass Mode Example",
    "title": "Create Your First WINC Bypass Mode Example",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_first_winc_bypass_mode_example/readme.html",
    "relUrl": "/source/middleware/create_first_winc_bypass_mode_example/readme.html"
  },"289": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Configure Surface and Gesture Harmony v3 Touch Project",
    "content": "This article provides information on creating a Touch Surface and Gesture project in Microchip’s MPLAB® Harmony v3 platform as well as configuring surface and gesture parameters. This project uses the SAMC21N Xplained Pro Evaluation Kit board along with the QT1 Mutual Capacitance Xplained Pro Extension Kit . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html#configure-surface-and-gesture-harmony-v3-touch-project",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html#configure-surface-and-gesture-harmony-v3-touch-project"
  },"290": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html"
  },"291": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Web Links",
    "content": ". | Configure Surface and Gesture Harmony v3 Touch Project | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html#web-links",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html#web-links"
  },"292": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html#reference-links",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html#reference-links"
  },"293": {
    "doc": "Create Touch Surface and Gesture Project",
    "title": "Create Touch Surface and Gesture Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/create_touch_surface_gesture_project/readme.html",
    "relUrl": "/source/middleware/create_touch_surface_gesture_project/readme.html"
  },"294": {
    "doc": "Creating a new Graphics Application",
    "title": "Creating a New Graphics Application",
    "content": "This topic describes the basic steps to create a graphics-enabled application from scratch using SAM E70 Xplained Ultra board. It starts with a blank MPLAB® project and finishes with a graphics application equivalent to aria_quickstart. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html#creating-a-new-graphics-application",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html#creating-a-new-graphics-application"
  },"295": {
    "doc": "Creating a new Graphics Application",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html"
  },"296": {
    "doc": "Creating a new Graphics Application",
    "title": "Web Links",
    "content": ". | Creating a New Graphics Application | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html#web-links",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html#web-links"
  },"297": {
    "doc": "Creating a new Graphics Application",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html#reference-links",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html#reference-links"
  },"298": {
    "doc": "Creating a new Graphics Application",
    "title": "Creating a new Graphics Application",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/creating_a_new_graphics_application/readme.html",
    "relUrl": "/source/middleware/creating_a_new_graphics_application/readme.html"
  },"299": {
    "doc": "Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3",
    "title": "Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3",
    "content": "This tutorial shows you how to create an Artificial Intelligence/Machine Learning (AI/ML) application using TensorFlow Lite for Microcontroller (TFLM) to recognize handwritten digits on a SAM E51 Integrated Graphics and Touch (IGAT) Curiosity Evaluation Kit with the help of MPLAB® Code Configurator (MCC) and the MPLAB Harmony v3 software framework. The application reads the touchpoints drawn by the user on the touch display, evaluates whether the outlined touchpoints are numeric digits (0 to 9) or not by using the convolution neural network, then displays the digit recognized on the same display screen. This training module guides you in training an ML model using TensorFlow and converts it to TensorFlow Lite interpreter format compatible with microcontrollers (MCUs). The neural network model is created, trained and converted to Tensorflow Lite format for inferencing on a microcontroller using TFLM runtime engine. The converted model is integrated with the application developed using MPLAB® Harmony v3 and MCC. The application uses the MPLAB Harmony v3 TFLM and CMSIS NN (Common Microcontroller Software Interface Standard Neural Network) Application Programming Interfaces (APIs) to use the model and demonstrate the end functionality. The development of this application can be classified into two parts: . | Development of the model | Development of the embedded project and integration of the model | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/digit_recognition_ai_ml/readme.html#digit-recognition-aiml-application-on-sam-e51-igat-curiosity-evaluation-kit-using-mplab-harmony-v3",
    "relUrl": "/source/middleware/digit_recognition_ai_ml/readme.html#digit-recognition-aiml-application-on-sam-e51-igat-curiosity-evaluation-kit-using-mplab-harmony-v3"
  },"300": {
    "doc": "Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/digit_recognition_ai_ml/readme.html",
    "relUrl": "/source/middleware/digit_recognition_ai_ml/readme.html"
  },"301": {
    "doc": "Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3",
    "title": "Web Links",
    "content": ". | Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/digit_recognition_ai_ml/readme.html#web-links",
    "relUrl": "/source/middleware/digit_recognition_ai_ml/readme.html#web-links"
  },"302": {
    "doc": "Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/digit_recognition_ai_ml/readme.html#reference-links",
    "relUrl": "/source/middleware/digit_recognition_ai_ml/readme.html#reference-links"
  },"303": {
    "doc": "Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3",
    "title": "Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/digit_recognition_ai_ml/readme.html",
    "relUrl": "/source/middleware/digit_recognition_ai_ml/readme.html"
  },"304": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Graphics Quick Start Application Guides",
    "content": "A collection of application quickstart tutorials are provided with MPLAB Harmony Graphics Suite to help users understand and create applications quickly. These guides were created using Microchip supported development boards. Although these guides run on Microchip boards, customers are free to reference our solutions to enable their custom designs. Note: Complete applications are part of each MPLAB Harmony distribution. Visit the quickstart apps and feature apps for more information. QuickStart Applications Demonstrate . | Preferred Harmony Practices | Example Board Support Package (BSP) | Detailed Pin Configuration | Recommended Peripheral and external device communication | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html#graphics-quick-start-application-guides",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html#graphics-quick-start-application-guides"
  },"305": {
    "doc": "Graphics Quick Start Application Guides",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html"
  },"306": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Web Links",
    "content": ". | Graphics Quick Start Application Guides | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html#web-links",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html#web-links"
  },"307": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html#reference-links",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html#reference-links"
  },"308": {
    "doc": "Graphics Quick Start Application Guides",
    "title": "Graphics Quick Start Application Guides",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/graphics_quick_start_application_guides/readme.html",
    "relUrl": "/source/middleware/graphics_quick_start_application_guides/readme.html"
  },"309": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "MPLAB Harmony 3 Audio Overview",
    "content": "This page provides a brief overview of audio and Harmony support for audio. The Audio repository contains a variety of audio-related firmware projects that demonstrate the capabilities of the MPLAB Harmony 3 audio offerings. Each example application project describes its hardware setup, block diagram, requirements, hardware compatibility and operation. Many of these applications can be used as the basis for fully featured products. They may contain integration with other technologies including USB, graphics or RTOS. It also contains drivers for hardware codecs that can be connected to development boards, such as the WM8904 Codec Daughter Card. Finally, it contains BSP Audio Templates that can be used to make configuring a new audio project a matter of just a few mouse clicks. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html#mplab-harmony-3-audio-overview",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html#mplab-harmony-3-audio-overview"
  },"310": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html"
  },"311": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "Web Links",
    "content": ". | MPLAB Harmony 3 Audio Overview | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html#web-links"
  },"312": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html#reference-links"
  },"313": {
    "doc": "MPLAB Harmony 3 Audio Overview",
    "title": "MPLAB Harmony 3 Audio Overview",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_3_audio_overview/readme.html",
    "relUrl": "/source/middleware/harmony_3_audio_overview/readme.html"
  },"314": {
    "doc": "Harmony Crypto Overview",
    "title": "Crypto Overview",
    "content": "The Cryptographic Library includes functions to perform encryption, decryption, hashing, authentication, and compression within the embedded application. Random number generation (RNG) functions are also provided. This page provides a brief overview of MPLAB Harmony support for cryptography. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html#crypto-overview",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html#crypto-overview"
  },"315": {
    "doc": "Harmony Crypto Overview",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html"
  },"316": {
    "doc": "Harmony Crypto Overview",
    "title": "Web Links",
    "content": ". | Crypto Overview | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html#web-links"
  },"317": {
    "doc": "Harmony Crypto Overview",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html#reference-links"
  },"318": {
    "doc": "Harmony Crypto Overview",
    "title": "Harmony Crypto Overview",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_crypto_overview/readme.html",
    "relUrl": "/source/middleware/harmony_crypto_overview/readme.html"
  },"319": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "MPLAB® Harmony Graphics Suite",
    "content": "MPLAB® Harmony Graphics Suite is an extension of the MPLAB ecosystem for creating embedded graphic firmware solutions on Microchip 32-bit microcontroller and microprocessor products . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html#mplab-harmony-graphics-suite",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html#mplab-harmony-graphics-suite"
  },"320": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html"
  },"321": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony Graphics Suite | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html#web-links"
  },"322": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html#reference-links"
  },"323": {
    "doc": "Harmony Graphics Suite User Guide",
    "title": "Harmony Graphics Suite User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_graphics_suite_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_graphics_suite_user_guide/readme.html"
  },"324": {
    "doc": "Harmony QTouch User Guide",
    "title": "QTouch® Modular Library Peripheral Touch Controller User’s Guide",
    "content": "The Microchip QTouch® Peripheral Touch Controller (PTC) offers built-in hardware for capacitive touch measurement on sensors that function as buttons, sliders, and wheels. The PTC supports both mutual and self-capacitance measurement without the need for any external component. It offers superb sensitivity and noise tolerance, as well as self-calibration, and minimizes the sensitivity tuning effort by the user. It also extends the support for capacitive touch surface and gesture functionality. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html#qtouch-modular-library-peripheral-touch-controller-users-guide",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html#qtouch-modular-library-peripheral-touch-controller-users-guide"
  },"325": {
    "doc": "Harmony QTouch User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html"
  },"326": {
    "doc": "Harmony QTouch User Guide",
    "title": "Web Links",
    "content": ". | QTouch Modular Library Peripheral Touch Controller User’s Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html#web-links"
  },"327": {
    "doc": "Harmony QTouch User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html#reference-links"
  },"328": {
    "doc": "Harmony QTouch User Guide",
    "title": "Harmony QTouch User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_qtouch_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_qtouch_user_guide/readme.html"
  },"329": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Harmony TCPIP User Guide",
    "content": "This distribution package contains a variety of TCP/IP firmware projects that demonstrate the capabilities of the MPLAB Harmony TCP/IP Stack. Each project describes its hardware setup and requirements. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html#harmony-tcpip-user-guide",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html#harmony-tcpip-user-guide"
  },"330": {
    "doc": "Harmony TCP/IP User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html"
  },"331": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Web Links",
    "content": ". | Harmony TCPIP User Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html#web-links"
  },"332": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html#reference-links"
  },"333": {
    "doc": "Harmony TCP/IP User Guide",
    "title": "Harmony TCP/IP User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_tcpip_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_tcpip_user_guide/readme.html"
  },"334": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Harmony USB Stack User Guide",
    "content": "This distribution package contains a variety of USB-related firmware projects that demonstrate the capabilities of the MPLAB Harmony USB stack. This section describes the hardware requirement and procedures to run these firmware projects on Microchip demonstration and development boards. It also provide information about the MPLAB Harmony USB stack, USB Stack Configuration and the USB Stack APIs. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html#harmony-usb-stack-user-guide",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html#harmony-usb-stack-user-guide"
  },"335": {
    "doc": "Harmony USB Stack User Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html"
  },"336": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Web Links",
    "content": ". | Harmony USB Stack User Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html#web-links"
  },"337": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html#reference-links"
  },"338": {
    "doc": "Harmony USB Stack User Guide",
    "title": "Harmony USB Stack User Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_usb_stack_user_guide/readme.html",
    "relUrl": "/source/middleware/harmony_usb_stack_user_guide/readme.html"
  },"339": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "WINC Driver Architecture",
    "content": "This section describes the WINC Driver Library. This Driver supports both ATWINC1500 and ATWINC3400. The MPLAB Harmony WINC Driver provides a high-level interface to the ATWINC1500 and ATWINC3400 Wi-Fi network controller modules. The WINC Driver Library, in conjunction with the ATWINC1500 or ATWINC3400 module, allows an application to: . | Join an existing 802.11 b/g/n 2.4GHz Wi-Fi Infrastructure network. | Create an 802.11 Wi-Fi Ad Hoc of Soft AP network. | Scan for other W-Fi devices in an area | Supports BLE 4.0 provisioning and profiles in central and peripheral mode (ATWINC3400 only) | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html#winc-driver-architecture",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html#winc-driver-architecture"
  },"340": {
    "doc": "Harmony WINC Driver Architecture",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html"
  },"341": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "Web Links",
    "content": ". | WINC Driver Architecture | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html#web-links",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html#web-links"
  },"342": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html#reference-links",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html#reference-links"
  },"343": {
    "doc": "Harmony WINC Driver Architecture",
    "title": "Harmony WINC Driver Architecture",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/harmony_winc_driver_architecture/readme.html",
    "relUrl": "/source/middleware/harmony_winc_driver_architecture/readme.html"
  },"344": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Getting Started with Harmony v3 Drivers and Middleware on PIC32MZ EF MCUs using FreeRTOS",
    "content": "This tutorial shows you how to use the MHC to create an application that gets you started in developing applications on PIC32MZ EF MCUs using MPLAB Harmony v3 software framework with FreeRTOS™. Harmony v3 drivers support Asynchronous and Synchronous modes of operation. | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs) | Works seamlessly in bare-metal and RTOS environment | Interrupt and thread-safe | . | Synchronous Mode . | Blocking APIs | Suitable for use in RTOS environment | Interrupt and thread-safe | . | . In this tutorial, you will use Harmony drivers in Synchronous mode of operation and Harmony middleware libraries with FreeRTOS. The application makes use of Curiosity PIC32MZ EF 2.0 Development Board and I/O1 Xplained Pro Extension Kit. The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM and to a file in a USB thumb drive whenever the USB thumb drive is connected. Also, an LED (LED1) is toggled every time the temperature is displayed on the serial console and an LED (LED2) is in ON state when a USB thumb drive is connected. The application you create will utilize: . | I²C Synchronous Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | Universal Synchronous Asynchronous Receiver Transmitter (USART) Synchronous Driver to print the temperature values on a COM (serial) port terminal application running on a PC. | USB High-Speed Driver, USB Host Middleware, and File System Service libraries to write the temperature readings to a file in a USB thumb drive whenever a USB thumb drive is connected. | GPIO Peripheral Library to toggle an LED. | FreeRTOS library to create middleware, application threads, and intercommunicate between these threads. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html#getting-started-with-harmony-v3-drivers-and-middleware-on-pic32mz-ef-mcus-using-freertos",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html#getting-started-with-harmony-v3-drivers-and-middleware-on-pic32mz-ef-mcus-using-freertos"
  },"345": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html"
  },"346": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers and Middleware on PIC32MZ EF MCUs using FreeRTOS | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html#web-links",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html#web-links"
  },"347": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html#reference-links",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html#reference-links"
  },"348": {
    "doc": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "title": "Getting Started with Middleware on PIC32MZ EF MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/pic32mz_getting_started_middleware/readme.html",
    "relUrl": "/source/middleware/pic32mz_getting_started_middleware/readme.html"
  },"349": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Quickstart Prebuilt Graphics Applications",
    "content": "Quickstart prebuilt graphis applications lets you get started with MPLAB Harmony Graphics Suite in about 30 seconds. These applications should give you a ready-made starting point for writing your own graphics apps with MPLAB Harmony Graphics Suite. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#quickstart-prebuilt-graphics-applications",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#quickstart-prebuilt-graphics-applications"
  },"350": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html"
  },"351": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Web Links",
    "content": ". | Quickstart Prebuilt Graphics Applications | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#web-links",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#web-links"
  },"352": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#reference-links",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html#reference-links"
  },"353": {
    "doc": "Quickstart Prebuilt Graphics Applications",
    "title": "Quickstart Prebuilt Graphics Applications",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/quickstart_prebuilt_graphics_applications/readme.html",
    "relUrl": "/source/middleware/quickstart_prebuilt_graphics_applications/readme.html"
  },"354": {
    "doc": "Rapid Prototyping with Curiosity Nano Using MPLAB Harmony v3",
    "title": "Rapid prototyping with Curiosity Nano Evaluation Kit using MPLAB Harmony v3",
    "content": "This tutorial shows you how to develop an application prototype from a concept without designing a PCB using 32-bit MCU-based Curiosity Nano Evaluation Kits and Nano baseboard. The problem statement you would address is implementing a smart appliance control application on the PIC32CM MC00 Curiosity Nano Evaluation Kit using MPLAB® Harmony v3 software framework. The application makes use of the PIC32CM MC00 Curiosity Nano Evaluation Kit, the BM71-XPRO Bluetooth Low energy board, and the following MikroElektronika Click boards: WEATHER CLICK, Fan Click, EINK CLICK BUNDLE. The application is developed on the MPLAB Harmony v3 software framework. MPLAB Harmony v3 is a modular framework that provides interoperable firmware libraries for application development on 32-bit MCUs and MPUs. It includes an easy-to-use Graphical User Interface (GUI) (MPLAB Harmony Configurator (MHC)) for selecting, configuring, and generating starter codes, peripheral libraries, and middleware (USB, TCP/IP, Graphics, and so on). This application demonstrates smart control of an appliance (fan) through an Android-based smartphone over a Bluetooth Low Energy (BLE) connection. The application enables BLE transfers by connecting the BM71 XPRO to the Microchip Bluetooth Data (MBD) Android smartphone application. The BM71 XPRO uses a transparent service for data exchange with the Android MBD mobile application. The BM71 XPRO interfaces to the MCU over SERCOM - USART interface. The fan connected to Fan Click via the I²C interface is controlled based on the mobile application’s commands. The application supports two types of commands received over BLE. Environment temperature-based Fan Control mode command . | When the application receives a command TEMP_CTRL from the Android smartphone, the fan is run based on the environmental temperature. The application reads the temperature values from a weather sensor and displays them on the eINK display and controls a DC fan as mentioned below. | The fan rotates at LOW speed at a temperature between 18 (64°F) to 25 (77°F) degrees Celsius. | The fan rotates at MEDIUM speed at a temperature between 26 (78°F) to 30 (86°F) degrees Celsius. | Temperature is greater than 30 degrees Celsius (86°F), the fan rotates at HIGH speed. | Temperature is less than 18 (64°F), the fan is switched OFF. | . | . Fan operation control based on the commands received from the Android smartphone. | You can control the fan by sending specific commands to the MBD app running on the connected smartphone. | BLE_CTRL: FAN_ON - Turns the fan “On” and runs at LOW speed. | BLE_CTRL: FAN_OFF - Turns “Off” the fan. | BLE_CTRL: FAN_LOW - Runs the fan at LOW speed. | BLE_CTRL: FAN_MID - Runs the fan at MEDIUM speed. | BLE_CTRL: FAN_HIGH - Runs the fan at HIGH speed. | . | . The application you create will utilize the following peripherals: . | SERCOM0 (as I²C) peripheral library to read the temperature from the Weather Click sensor and control the speed of the 5 V DC fan using the Fan Click. | SERCOM1 (as SPI) peripheral library to display the temperature and fan speed status on the eINK display | SERCOM3 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to communicate with the BM71-XPRO using the BM71 Driver | SysTick and Timer (TC0) peripheral libraries are used for MikroElektronika board and BM71 driver timing requirements | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/rapid_prototyping/readme.html#rapid-prototyping-with-curiosity-nano-evaluation-kit-using-mplab-harmony-v3",
    "relUrl": "/source/middleware/rapid_prototyping/readme.html#rapid-prototyping-with-curiosity-nano-evaluation-kit-using-mplab-harmony-v3"
  },"355": {
    "doc": "Rapid Prototyping with Curiosity Nano Using MPLAB Harmony v3",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/rapid_prototyping/readme.html",
    "relUrl": "/source/middleware/rapid_prototyping/readme.html"
  },"356": {
    "doc": "Rapid Prototyping with Curiosity Nano Using MPLAB Harmony v3",
    "title": "Web Links",
    "content": ". | Rapid prototyping with 32-bit MCU-based Curiosity Nano Evaluation Kit using MPLAB Harmony v3 Software Framework | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/rapid_prototyping/readme.html#web-links",
    "relUrl": "/source/middleware/rapid_prototyping/readme.html#web-links"
  },"357": {
    "doc": "Rapid Prototyping with Curiosity Nano Using MPLAB Harmony v3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/rapid_prototyping/readme.html#reference-links",
    "relUrl": "/source/middleware/rapid_prototyping/readme.html#reference-links"
  },"358": {
    "doc": "Rapid Prototyping with Curiosity Nano Using MPLAB Harmony v3",
    "title": "Rapid Prototyping with Curiosity Nano Using MPLAB Harmony v3",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/rapid_prototyping/readme.html",
    "relUrl": "/source/middleware/rapid_prototyping/readme.html"
  },"359": {
    "doc": "Getting Started with USB on SAM MCUs Using MPLAB Harmony v3",
    "title": "Getting Started with USB on SAM MCUs Using MPLAB Harmony v3",
    "content": "This tutorial shows you how to use MHC to create a simple USB CDC class serial terminal menu application and will help you get started on developing USB based applications for SAM MCUs using the MPLAB Harmony v3 software framework. The training module application makes use of the SAM E70 Xplained Evaluation Kit and the I/O1 Xplained Pro Extension Kit (sold separately). This application reads the current room temperature from the AT30TSE758A temperature sensor chip on the I/O1 Xplained Pro every second using I²C. This is indicated by a blinking orange LED on the I/O1 Xplained Pro. Further, it also writes these temperature values into the sensor chip’s own integrated EEPROM using the same I²C peripheral instance. The application also uses an ADC channel to read the output voltage of the TEMT6000 ambient light sensor on the I/O1 Xplained Pro Extension Kit and displays it as a percentage of the sensor’s full-scale output when requested through the serial terminal menu. This serial terminal menu is made available through the SAM E70 Xplained Evaluation Kit’s Target USB port by configuring it as a USB CDC class device. This menu allows you to fetch temperature, light sensor data, and even toggle the LED on the SAME70 Xplained Evaluation Kit. The application you create will utilize the following Harmony v3 components: . | I²C Driver (TWIHS) to fetch the temperature and access the EEPROM on the AT30TSE758A. | Timer System Service (TC) to periodically sample temperature sensor data every second. | CDC Function Driver of the USB Device Stack (USBHS) for the serial terminal menu accessible via PC. | ADC Peripheral Library (AFEC) to read the TEMT6000 ambient light sensor output voltage. | PIO Peripheral Library (PIO) to toggle some LEDs and multiplex pin functions. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/same70_getting_started_middleware/readme.html#getting-started-with-usb-on-sam-mcus-using-mplab-harmony-v3",
    "relUrl": "/source/middleware/same70_getting_started_middleware/readme.html#getting-started-with-usb-on-sam-mcus-using-mplab-harmony-v3"
  },"360": {
    "doc": "Getting Started with USB on SAM MCUs Using MPLAB Harmony v3",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/same70_getting_started_middleware/readme.html",
    "relUrl": "/source/middleware/same70_getting_started_middleware/readme.html"
  },"361": {
    "doc": "Getting Started with USB on SAM MCUs Using MPLAB Harmony v3",
    "title": "Web Links",
    "content": ". | Getting Started with USB on SAM MCUs Using MPLAB® Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/same70_getting_started_middleware/readme.html#web-links",
    "relUrl": "/source/middleware/same70_getting_started_middleware/readme.html#web-links"
  },"362": {
    "doc": "Getting Started with USB on SAM MCUs Using MPLAB Harmony v3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/same70_getting_started_middleware/readme.html#reference-links",
    "relUrl": "/source/middleware/same70_getting_started_middleware/readme.html#reference-links"
  },"363": {
    "doc": "Getting Started with USB on SAM MCUs Using MPLAB Harmony v3",
    "title": "Getting Started with USB on SAM MCUs Using MPLAB Harmony v3",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/same70_getting_started_middleware/readme.html",
    "relUrl": "/source/middleware/same70_getting_started_middleware/readme.html"
  },"364": {
    "doc": "Audio Tone using a lookup table",
    "title": "Lab 1: Audio-Tone Generation Using a Lookup Table with Harmony v3",
    "content": "In this lab, you will create a simple MPLAB Harmony project from scratch. You will use the MHC to configure the codec on the PIC32 Multimedia Expansion Board II. The application streams an audio tone (stored in the form of a lookup table in memory) over the I²S interface which gets played on the audio codec. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#lab-1-audio-tone-generation-using-a-lookup-table-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#lab-1-audio-tone-generation-using-a-lookup-table-with-harmony-v3"
  },"365": {
    "doc": "Audio Tone using a lookup table",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html"
  },"366": {
    "doc": "Audio Tone using a lookup table",
    "title": "Web Links",
    "content": ". | Lab 1: Audio-Tone Generation Using a Lookup Table with Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#web-links"
  },"367": {
    "doc": "Audio Tone using a lookup table",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html#reference-links"
  },"368": {
    "doc": "Audio Tone using a lookup table",
    "title": "Audio Tone using a lookup table",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_a_lookup_table/readme.html"
  },"369": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Lab 2: Audio-Tone Generation from a Text File Stored in an SD Card with Harmony v3",
    "content": "This lab adds to the previous one. The audio_player_lab2 application reads an audio text file from the PIC32 Multimedia Expansion Board II SD card and streams it over the PIC32 I²S interface to the audio CODEC. The audio file is saved as a .txt file with comma-separated left and right channel audio data. The audio_player_lab2 application demonstrates the configuration and integration of the additional modules to audio_player_lab1 using MHC, thereby extending its functionality. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#lab-2-audio-tone-generation-from-a-text-file-stored-in-an-sd-card-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#lab-2-audio-tone-generation-from-a-text-file-stored-in-an-sd-card-with-harmony-v3"
  },"370": {
    "doc": "Audio Tone using text fil in SD card",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html"
  },"371": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Web Links",
    "content": ". | Lab 2: Audio-Tone Generation from a Text File Stored in an SD Card with Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#web-links"
  },"372": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html#reference-links"
  },"373": {
    "doc": "Audio Tone using text fil in SD card",
    "title": "Audio Tone using text fil in SD card",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/audio_tone_using_text_file_in_sd_card/readme.html"
  },"374": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Lab 5: Display Graphics Support to Select and Play Audio File",
    "content": "In this lab, you will add to the previous one, a graphics display UI on the PIC32 Multimedia Expansion Board II. The audio_player_lab5 application displays audio tracks from the SD card in a list box. You can navigate the list to select and play a track. It also provides a volume increase/decrease scroll bar and a mute on/off button. This lab will demonstrate the configuration and integration of additional modules to audio_player_lab4 using the MPLAB Harmony 3 Configurator (MHC), thereby extending its functionality. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#lab-5-display-graphics-support-to-select-and-play-audio-file",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#lab-5-display-graphics-support-to-select-and-play-audio-file"
  },"375": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html"
  },"376": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Web Links",
    "content": ". | Lab 5: Display Graphics Support to Select and Play Audio File | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#web-links"
  },"377": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html#reference-links"
  },"378": {
    "doc": "Display Graphics to Select and Play Audio File",
    "title": "Display Graphics to Select and Play Audio File",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/display_graphics_to_select_and_play_audio_file/readme.html"
  },"379": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Lab 4: Play a WAV Audio File from an SD Card with Harmony v3",
    "content": "This lab extends previous one and add new functionality to it. This application reads a WAV audio file from the SD card on the PIC32 Multimedia Expansion Board II and streams it over the PIC32 I²S interface through the audio CODEC. Here, we implement the functionality of an audio player (for WAV files only). The application switches to the next track when the current track playing is completed (assuming that there is more than one track on the SD card). This application also demonstrates the configuration and integration of the additional modules using MHC, thereby extending its functionality. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#lab-4-play-a-wav-audio-file-from-an-sd-card-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#lab-4-play-a-wav-audio-file-from-an-sd-card-with-harmony-v3"
  },"380": {
    "doc": "Play WAV Audio File from SD Card",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html"
  },"381": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Web Links",
    "content": ". | Lab 4: Play a WAV Audio File from an SD Card with Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#web-links"
  },"382": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html#reference-links"
  },"383": {
    "doc": "Play WAV Audio File from SD Card",
    "title": "Play WAV Audio File from SD Card",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/play_wav_audio_file_from_sd_card/readme.html"
  },"384": {
    "doc": "SD card Reader to load Audio Files",
    "title": "Lab3: SD Card Reader Support to Load Audio Files with Harmony v3",
    "content": "This lab extends previous one by adding Secure Digital (SD) card reader functionality. The audio_player_lab3 application shows how to edit the contents of an SD card. The PIC32 Multimedia Expansion Board II is connected to a USB host, (typically a PC) and after a successful enumeration, the SD card is presented as a mass storage drive on the PC allowing you to add or delete contents. Note: This tutorial is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#lab3-sd-card-reader-support-to-load-audio-files-with-harmony-v3",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#lab3-sd-card-reader-support-to-load-audio-files-with-harmony-v3"
  },"385": {
    "doc": "SD card Reader to load Audio Files",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html"
  },"386": {
    "doc": "SD card Reader to load Audio Files",
    "title": "Web Links",
    "content": ". | https://microchipdeveloper.com/harmony3:audio-player-lab3 | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#web-links"
  },"387": {
    "doc": "SD card Reader to load Audio Files",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html#reference-links"
  },"388": {
    "doc": "SD card Reader to load Audio Files",
    "title": "SD card Reader to load Audio Files",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/sd_card_reader_to_load_audio_files/readme.html"
  },"389": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "MPLAB® Harmony v3 SD Card Audio Player/Reader Tutorial",
    "content": "The rapid prototyping ability of MPLAB Harmony is due to the availability of software modules (Drivers, System Services and Middleware Libraries) and tools (MPLAB Harmony 3 Configurator (MHC) and MPLAB Harmony Graphics Composer (MHGC)) that are designed to allow maximum reuse of code and rapid development. The following exercises demonstrate the quick prototyping capability of MPLAB Harmony. These exercises should be completed sequentially to understand how the following exercise enhances and adds new functionality to the earlier exercise. | Lab 1: Audio-Tone Generation Using a Lookup Table | Lab 2: Audio-Tone Generation Using Text File Stored in SD Card | Lab 3: SD Card Reader Support to Load Audio Files | Lab 4: Play WAV Audio File from SD Card | Lab 5: Display Graphics Support to Select and Play an Audio File | . This tutorial series makes makes use of PIC32MZ Embedded Connectivity with FPU and PIC32 Multimedia Expansion Board II (sold separately). Note: This tutorial series is a reference only to the existing users of Multimedia Expansion Board II (MEB II) to port/develop their application(s) using MPLAB Harmony v3 as the Multimedia Expansion Board II (MEB II) is now a matured product and the same is not available for purchase from Microchip Direct. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#mplab-harmony-v3-sd-card-audio-playerreader-tutorial",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#mplab-harmony-v3-sd-card-audio-playerreader-tutorial"
  },"390": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html"
  },"391": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "Web Links",
    "content": ". | MPLAB Harmony v3 SD Card Audio Player/Reader Tutorial | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#web-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#web-links"
  },"392": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#reference-links",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html#reference-links"
  },"393": {
    "doc": "SD Card Audio Player Reader Tutorial",
    "title": "SD Card Audio Player Reader Tutorial",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/sdcard_audio_player_reader_tutorial/readme.html",
    "relUrl": "/source/middleware/sdcard_audio_player_reader_tutorial/readme.html"
  },"394": {
    "doc": "Middleware Examples",
    "title": "MPLAB Harmony Middleware Example Documentation",
    "content": "This page contains quick documentation for MPLAB® Harmony 3 Middleware Libraries usage. | Getting Started with Harmony v3 Drivers and Middleware on PIC32MZ EF MCUs using FreeRTOS . | Getting Started with USB on SAM MCUs Using MPLAB Harmony v3 . | Rapid prototyping with Curiosity Nano Evaluation Kit using MPLAB Harmony v3 . | Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3 . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#mplab-harmony-middleware-example-documentation",
    "relUrl": "/source/middleware/readme.html#mplab-harmony-middleware-example-documentation"
  },"395": {
    "doc": "Middleware Examples",
    "title": "Audio",
    "content": ". | MPLAB Harmony 3 Audio Overview . | Creating your first Audio Application . | Creating Your first Audio Decoder Application . | SD Card Audio Player/Reader Tutorial . | Audio-Tone Generation Using a Lookup Table . | Audio-Tone Generation from a Text File Stored in an SD Card . | SD Card Reader Support to Load Audio Files . | Play a WAV Audio File from an SD Card . | Display Graphics Support to Select and Play Audio File . | . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#audio",
    "relUrl": "/source/middleware/readme.html#audio"
  },"396": {
    "doc": "Middleware Examples",
    "title": "Graphics",
    "content": ". | Quickstart Prebuilt Graphics Applications . | Creating a new Graphics Application . | Graphics Quick Start Application Guides . | Harmony Graphics Suite User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#graphics",
    "relUrl": "/source/middleware/readme.html#graphics"
  },"397": {
    "doc": "Middleware Examples",
    "title": "USB",
    "content": ". | Create your first USB Device Application . | Create Your First USB Host Application . | Harmony USB Stack User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#usb",
    "relUrl": "/source/middleware/readme.html#usb"
  },"398": {
    "doc": "Middleware Examples",
    "title": "TCP/IP",
    "content": ". | Create your first TCP/IP Application . | Harmony TCP/IP User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#tcpip",
    "relUrl": "/source/middleware/readme.html#tcpip"
  },"399": {
    "doc": "Middleware Examples",
    "title": "Touch",
    "content": ". | Create a Touch Project in Harmony . | Create Touch Surface &amp; Gesture Project in Harmony . | Harmony QTouch User Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#touch",
    "relUrl": "/source/middleware/readme.html#touch"
  },"400": {
    "doc": "Middleware Examples",
    "title": "Crypto",
    "content": ". | Harmony Crypto Overview - Board Examples . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#crypto",
    "relUrl": "/source/middleware/readme.html#crypto"
  },"401": {
    "doc": "Middleware Examples",
    "title": "Wireless",
    "content": ". | Create Your First WINC Bypass Mode Example . | Harmony WINC Driver Architecture . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#wireless",
    "relUrl": "/source/middleware/readme.html#wireless"
  },"402": {
    "doc": "Middleware Examples",
    "title": "Bluetooth",
    "content": ". | Create your First Bluetooth Application in Harmony . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#bluetooth",
    "relUrl": "/source/middleware/readme.html#bluetooth"
  },"403": {
    "doc": "Middleware Examples",
    "title": "Motor control",
    "content": ". | Create your first Motor Control Application . | . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#motor-control",
    "relUrl": "/source/middleware/readme.html#motor-control"
  },"404": {
    "doc": "Middleware Examples",
    "title": "Web Links",
    "content": ". | How to Use the MPLAB Harmony v3 Debug System Service | Rapid Prototyping Webinar Series | . Note: . This page provides a quick reference covering the MPLAB Harmony 3 Middleware Libraries usage. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#web-links",
    "relUrl": "/source/middleware/readme.html#web-links"
  },"405": {
    "doc": "Middleware Examples",
    "title": "Videos",
    "content": ". Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#videos",
    "relUrl": "/source/middleware/readme.html#videos"
  },"406": {
    "doc": "Middleware Examples",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html#reference-links",
    "relUrl": "/source/middleware/readme.html#reference-links"
  },"407": {
    "doc": "Middleware Examples",
    "title": "Middleware Examples",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/middleware/readme.html",
    "relUrl": "/source/middleware/readme.html"
  },"408": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Migrate aria_quickstart v2.06 to 3.04 pic32mz_ef_sk_meb2",
    "content": "This guide is to help migrate the graphics application configuration pic32mz_ef_sk_meb2 from MPLAB Harmony v2.06 to MPLAB Harmony v3.04. MPLAB Harmony v3 introduces new features and APIs of which aria_quickstart pic32mz_ef_sk_meb2 application and configuration can take advantage. This page guides you to an overview of the steps to migrate your graphics apps to MPLAB Harmony v3. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#migrate-aria_quickstart-v206-to-304-pic32mz_ef_sk_meb2",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#migrate-aria_quickstart-v206-to-304-pic32mz_ef_sk_meb2"
  },"409": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html"
  },"410": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | Migrate aria_quickstart v2.06 to 3.04 pic32mz_ef_sk_meb2 | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#web-links"
  },"411": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html#reference-links"
  },"412": {
    "doc": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "title": "Aria Graphis Application Harmony2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/aria_graphics_harmoy2_to_harmony_3/readme.html"
  },"413": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Porting Application from ASF3 to MPLAB Harmony 3 Framework",
    "content": "This page guides to the different steps to consider when porting an embedded application from Microchip Advance Software Framework 3 (ASF3) to MPLAB® Harmony 3 framework. It covers the following migration aspects: . | How to create a MPLAB Harmony 3 project under MPLAB X IDE and navigate through MPLAB Harmony 3 Configurator (MHC) | How to identify and get the configuration of the different elements that compose the ASF3 project | How to port the System, Driver, or Middleware configuration using MPLAB Harmony 3 Configurator | Important aspects to consider when porting the project Application Layer | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html#porting-application-from-asf3-to-mplab-harmony-3-framework",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html#porting-application-from-asf3-to-mplab-harmony-3-framework"
  },"414": {
    "doc": "Porting ASF to Harmony 3",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html"
  },"415": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Web Links",
    "content": ". | Porting Application from ASF3 to MPLAB Harmony 3 Framework | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html#web-links"
  },"416": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html#reference-links"
  },"417": {
    "doc": "Porting ASF to Harmony 3",
    "title": "Porting ASF to Harmony 3",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/asf_to_harmony_3/readme.html",
    "relUrl": "/source/migration/asf_to_harmony_3/readme.html"
  },"418": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Application migration from 8-bit AVR to 32-bit SAM D21 MCU",
    "content": "This page acts as a reference for migrating applications from 8-bit AVR Microcontroller (MCU) to 32-bit SAM MCU. This page shows how to migrate an application from ATMega4809 MCU to SAMD21G17D MCU with the help of an example. For the migration to a 32-bit MCU, the application uses SAM D21 Curiosity Nano Evaluation Kit and is developed on MPLAB® Harmony v3 software framework. The SAM D21 Curiosity Nano Evaluation Kit is a hardware platform to evaluate the SAMD21G17D microcontroller (MCU). It is supported by the MPLAB® X Integrated Development Environment (IDE) and MPLAB Harmony v3 software development framework. The evaluation kit provides easy access to the features of the SAM D21 MCU to integrate the device into a custom design. Because the evaluation kit contains an On-Board Nano Debugger for programming and debugging, no external tools are necessary to program the SAMD21G17D device. The evaluation kit is compatible with Curiosity Nano Base board (Part Number - AC164162) which allows you to quickly scale and prototype your next innovative design using the SAMD21G17D MCU. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. This migration guide refers an existing application “Getting Started with UART on ATmega4809” developed on ATmega4809 Curiosity Nano Evaluation Kit using MPLAB® Code Configurator (MCC) and discuss steps to migrate the existing application to SAM D21 Curiosity Nano Evaluation Kit which using MPLAB® Harmony Configurator (MHC). The application is further extended by adding more peripheral specific functionality. The application developed on SAM D21 MCU will utilize: . | PORT PLIB to control the LED. | External Interrupt Controller (EIC) PLIB and Systick PLIB to toggle the LED on SWITCH press event | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), STDIO Library and Direct Memory Access (DMA) PLIBs to print the Info messages on a COM (serial) port terminal application running on a PC and to receive command from serial terminal. | SERCOM (as SPI) to run a self-loopback test. | . Two ways to use this guide: . | Create the project from scratch: . | Follow step-by-step instructions below. | . | Use the solution project as an example: . | Build the solution project and program it to the SAM D21 Curiosity Nano Evaluation Kit to observe the expected behavior. | . | . This following bullet points provides links to the topics: . | Hardware Used | Software/Tools Used | Hardware Setup | Description . | Overview | Install MHC | Create MPLAB Harmony v3 Project | Configure Clock | Add SERCOM (USART) Peripheral | Generate Code | Add Code | Build and Program | Verify “Hello World” output | Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality | Verify Formatted STDIO, USART Receive and SWITCH/LED functionality | Extend application to configure SPI loopback using DMA based Transfers | Verify extended functionality - SPI loopback | . | Results | Analysis | Conclusions | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#application-migration-from-8-bit-avr-to-32-bit-sam-d21-mcu",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#application-migration-from-8-bit-avr-to-32-bit-sam-d21-mcu"
  },"419": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"420": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Hardware Used:",
    "content": ". | SAM D21 Curiosity Nano Evaluation Kit | Connection wires | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-used",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-used"
  },"421": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"422": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Software/Tools Used:",
    "content": "This project has been verified to work with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | Any Serial Terminal application like Tera Term terminal application. | . Because Microchip regularly update tools, occasionally issue(s) could be discovered while using the newer versions of the tools. If the project doesn’t seem to work and version incompatibility is suspected, It is recommended to double-check and use the same versions that the project was tested with. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#softwaretools-used",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#softwaretools-used"
  },"423": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"424": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Hardware Setup",
    "content": ". | Connect the SAM D21 Curiosity Nano Development Board to the Host PC as a USB Device through a Type-A male to micro-B USB cable connected to Micro-B USB (Debug USB) port | Connect a wire from PA16 to PA19 on SAM D21 Curiosity Nano Development Kit for SPI Self Loopback testing. | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-setup",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#hardware-setup"
  },"425": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"426": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Description",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#description",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#description"
  },"427": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": "Overview . This migration guide uses the AVR ATMega4809 application which helps in “Getting Started with UART on AVR”. | Click Here to download the application. | . The AVR ATMega4809 application shows how to implement a command line interface. This way, the microcontroller can receive control commands via the USART. In this use case, an LED is controlled using commands sent from the MPLAB Data Visualizer. The application flow is as follows: . | Configures the system clock The clock is configured to 1 MHz using 16 MHz Internal Oscillator | Configures USART3 USART3 is configured for 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | Configures pins The USART TX, RX pins and LED pin are configured | Implements STDIO receive and send functions STDIO library is implemented to receive and send commands from serial terminal | Reads and execute valid commands Receives command from serial terminal and executes it | . Follow the below steps to get started migrating to SAMD21 and later extend the functionality by adding more peripherals. Install MHC . | Install the MPLAB® Harmony Configurator (MHC) Plug-in in the MPLAB X IDE if not installed. | Verify the MPLAB® Harmony Configurator (MHC) Plug-in is installed. | Launch MPLAB X IDE from the Windows® Start Menu. Close all the projects and files that are currently open. | Go to Tools &gt; Embedded. | You will see MPLAB Harmony 3 Configurator in the menu | . | . Create MPLAB Harmony v3 Project . | Create MPLAB Harmony v3 Project Using MPLAB X IDE . | Select File &gt; New Project from the main IDE menu | In the Categories pane of the New Project dialog window, select Microchip Embedded. In the Projects pane, select 32-bit MPLAB Harmony 3 Project, then click Next | In the Framework Path edit box, browse to the folder you downloaded the framework to and select Next | In the Project Settings window, apply the following settings: | . | Location: indicates the path to the root folder of the new project. All project files will be placed inside this folder. The project location can be any valid path, for example: &lt;your project path&gt;/atmega4809_to_samd21 | Folder: indicates the name of the MPLAB X .X folder. Enter “atmega4809_to_samd21_migration” to create an atmega4809_to_samd21_migration.X folder. | . | Name: enter the project’s logical name as “atmega4809_to_sam_d21_cnano”. This is the name that will be shown from within the MPLAB X IDE. | Click Next to proceed to configuration settings | Follow the steps below to set the project’s configuration settings: | . | Name: enter the configuration name as “sam_d21_cnano”. | Target Device: select ATSAMD21G17D as the target device. | After selecting the target device, click Finish to launch MHC. | Device family pack path can be modified in below window. For now, use the default values | The MHC plugin’s main window for the project will be displayed as shown in the following image | . | . Configure Clock . | Configuring Clock Settings The SAM D21 family of microcontrollers (MCUs) contains a sophisticated clock distribution system designed to give maximum flexibility to the user application. The clock system allows the tuning of the performance and power consumption of the device in a dynamic manner. The MHC provides an easy to use UI (User Interface) window, and a Clock Easy View window to configure the system and peripheral clocks. | Launch Clock Easy View by going to Tools menu of MHC window and then select Clock Configuration | In the Clock Easy View, SAM D21 can operate at maximum 48 MHz, therefore Main Clock is set to 48 MHz. | Change the Main Clock to 1MHz | The Open loop Digital Frequency Locked Loop (DFLL 48 MHz) is configured and enabled to run the main clock. The configured DFLL is fed as input to the GCLK generator ‘0’ and a suitable clock divider (48) and masker must be selected to achieve a maximum frequency of 1 MHz. Refer to the following figure to configure the main clock to run at 1MHz | . | . MHC clock easy view provides all the clock options available in the SAMD21 in a UI, which makes easier to configure the clock whenever necessary. Add SERCOM (USART) Peripheral . | Adding SERCOM (USART) Peripheral MHC Graphical User Interface helps in selecting and configuring the peripherals needed by the project. It lists all the peripherals available in SAMD21 in an Active Component tab. | . | Click on the Available Components tab in the left pane in the MPLAB® Harmony Configurator (MHC) window. Expand Peripherals &gt; SERCOM | Double click or drag and drop SERCOM5 to add the USART Peripheral Library (PLIB) to the project graph. | . Note: SAM D21 Curiosity Nano On-Board Nano Debugger also includes a Virtual Com port which is routed to SERCOM5, therefore in this application, SERCOM5 is chosen. | Select the SERCOM5 Peripheral Library in the project graph. Verify that the default “SERCOM Operation Mode” configuration is set as USART and configure 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | . | Configuring USART pins using MHC PIN Configurator The Pin Manager consists of Pin Settings, the Pin Diagram, and the Pin Table tabs, which enables users to configure (assign peripheral function, set pin direction, configure pull-up or pull-down and so on) and map the I/O pins. | . The following color combinations are associated with the pins in the graphical or table View:  Gray: This pin is not usable in the selected configuration, and there is no enabled module which has any functionality on that pin. The grayed-out locks on a white background indicates the pins that are locked out by selected system functions.  Blue: This pin is available and can be allocated to a module.  Green (with a lock): This pin is allocated and selected for a module. The name displayed against the pin is either the name of the pin in the module’s context or a custom name entered. | Open the Pin Configuration tabs by clicking on MHC &gt; Tools &gt; Pin Configuration. | Launching Pin configuration opens Pin Settings, the Pin Diagram, and the Pin Table tabs. | select the MHC Pin Table tab and then scroll down to the SERCOM5 module as shown below.  Enable USART_TX on PA22 (Pin #31)  Enable USART_TX on PB22 (Pin #37) | . Generate Code . | Generate Code . | When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC) as shown below. | Save the configuration in its default location when prompted. | Click on the Code Generate button as shown below to start generating code. | . | . | Click on the Generate button in the Generate Project window, keeping the default settings as shown below. If prompted for saving the configuration, click Save. | As the code is generated, MHC displays the progress as shown below. | Navigate to the Projects tab in MPLAB X IDE to view the project tree structure. | Examine the generated code as shown below. | . MHC will include all the MPLAB Harmony library files and generate the code based on the MHC selections. The generated code would add files and folders to your Harmony project as shown. Among the generated code, notice the Peripheral Library (PLIB) files generated for SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), Clock and PORT peripherals. Add Code . | Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet in main function to print “Hello World” string on the serial terminal. uint8_t welcomeData[] = “Hello World\\r\\n”; . while ( true ) { SERCOM5_USART_Write(&amp;welcomeData[0],sizeof(welcomeData)); } &lt;img src = \\\"images/code_snippet1.png\\\" width=\\\"400\\\" height=\\\"300\\\" align=\\\"middle\\\"&gt; . | . Build and Program . | Before proceeding to Build and program, set up the compiler toolchain. Click on the Projects tab on the top left pane in MPLAB X IDE. Right click on the project name pic18f_to_sam_d21_cnano and go to Properties. | Make sure that XC32 (v2.41) is selected as the Compiler Toolchain for XC32. Click on Apply and then click on OK. | Clean and build your application by clicking on the Clean and Build button as shown below. | Program your application to the device by clicking on the Make and Program button as shown below. The lab should build and program successfully. | . Verify “Hello World” output . | Now, open the Tera Term terminal application on your PC (from the Windows® Start menu by pressing the Start button). Select the Serial Port as shown below. | Change the baud rate to 9600. | You should see the “Hello World” message displayed on the terminal as shown below. | . You successfully completed printing the “Hello World” message on serial terminal. Let us continue and extend the functionality of the application as below. Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality . | Configure STDIO Library to use printf and scanf function to write and read data from the serial terminal respectively | Receive the command from serial terminal and control the LED0 on the SAM D21 Curiosity evaluation kit | Use Switch SW0 on the SAM D21 Curiosity Evaluation Kit to toggle the LED twice when it is pressed. External Interrupt controller (EIC) and Systick peripherals are used to achieve this | . | If you closed MHC accidently and would like to open it again, go to Tools &gt; Embedded &gt; MPLAB Harmony 3 Configurator in MPLAB X IDE. | In the Project Graph, Select SERCOM5. Right click on yellow diamond and select consumer as STDIO as shown below | Select the MHC Pin Settings tab and then scroll down to the PORT pin PB10 (Pin Number 19) in the Pin ID column and configure PB10 as an output pin for LED functionality as shown below. | Select the Pin Settings tab and then scroll down to the PORT pin PB11 (Pin Number 20) in the Pin ID column and configure PB11 as an external interrupt pin for switch functionality as shown below. Internal pull-up is enabled to avoid false edge detection as there is no external pull-up on the SAM D21 Curiosity Nano Evaluation Kit. | Select the Project Graph tab. | Under the Available Components tab, expand Peripheral &gt; EIC. Select and double click on EIC to add the EIC module to the project. | . | . | Configure the EIC block to generate an interrupt every time the user presses the switch SW0 as shown below and enable filter functionality to avoid electrical noise on the switch pin. | Enable Systick to create a delay for toggling LED0, click on System in Project Graph and Configure as below. | When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. | Click on the Code Generate button to start generating code. | Click on the Generate button in the Generate Project window, keeping the default settings. If prompted for saving the configuration, click Save. | Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet to receive the command from serial terminal and a function to control the LED0 on the SAM D21 Curiosity Nano Evaluation Kit. | . | In main.c, add the below function above “main” function #include . void executeCommand(char *command) { if(strcmp(command, \\\"ON\\\") == 0) { LED_Clear(); printf(\\\"OK, LED ON.\\r\\n\\\"); } else if (strcmp(command, \\\"OFF\\\") == 0) { LED_Set(); printf(\\\"OK, LED OFF.\\r\\n\\\"); } else { printf(\\\"Incorrect command.\\r\\n\\\"); } } &lt;img src = \\\"images/code_snippet2.png\\\" align=\\\"middle\\\"&gt; . | Move “SERCOM5_USART_Write” function above while loop and add scanf inside the while loop as shown below. | Now, open the Tera Term terminal application on your PC. Enable Local echo in Setup &gt; Terminal as shown below. | Clean and build your application by clicking on the Clean and Build button. | . | . Verify Formatted STDIO, USART Receive and SWITCH/LED functionality . | Program your application to the device by clicking on the Make and Program button. The lab should build and program successfully. | In Tera Term you should see “Hello World” message displayed. | Type ON in serial terminal and press Enter to turn on LED0 on SAMD21 Curiosity Nano kit and Type OFF in serial terminal and press Enter to turn off LED0 on SAMD21 Curiosity Nano Evaluation Kit. | Switch SW0 is configured as interrupt using EIC peripheral, therefore register a call back in main function. Whenever user presses the switch, a callback will be notified and inside the call back, toggle the LED0 twice. | In main.c file, inside main function, add the below code. EIC_CallbackRegister(EIC_PIN_11,EIC_User_Handler, 0); SYSTICK_TimerStart(); | In main.c, add the below code above main function static void EIC_User_Handler(uintptr_t context) { uint8_t i = 0; . while(i&lt;4){ LED_Toggle(); SYSTICK_DelayMs(500); i++; } } &lt;img src = \\\"images/code_snippet4.png\\\" align=\\\"middle\\\"&gt; . | . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | Press the Switch SW0 on SAM D21 Curiosity Nano Evaluation Kit and observe LED0 Toggling twice at 500ms rate. You successfully completed controlling the LED0 on the SAMD21 Curiosity Nano Evaluation Kit by receiving the commands from the serial terminal through USART and also toggled the LED0 on Switch SW0 press using EIC and Systick peripheral. | . Extend application to configure SPI loopback using DMA based Transfers . Let us extend the functionality and add Serial Peripheral Interface (SPI) to perform a Self-Loopback test and add Direct memory address (DMA) to send the status of the SPI Transfer to the terminal without using CPU. | Select the Project Graph tab. Under the Available Components tab, expand Peripheral &gt; SERCOM. Select and double click on SERCOM1 to add the SPI module to the project. | In Project Graph select SERCOM1 and configure as below . | Open Pin Table, Select SERCOM1 and configure the pins as shown below . | Launch DMA Configurator from MHC &gt; Tools &gt; DMA Configuration | Click on ADD Channel and Select SERCOM5_Transmit to configure the DMA | When done, before generating code, click the *Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. | Click on the Code Generate button to start generating code. | Click on the Generate button in the Generate Project window, keeping the default settings. | If prompted for saving the configuration, click Save. | In main.c, Add below code snippet SERCOM1_SPI_WriteRead(&amp;txData[0], sizeof(txData), &amp;rxData[0], sizeof(rxData)); . /* Compare received data with the transmitted data */ if ((memcmp(txData, rxData, sizeof(txData)) == 0)) { /* Pass: Received data is same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \\\"Received SPI Valid Data\\r\\n\\\", \\\\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\\\ 25); } else { /* Fail: Received data is not same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \\\"Received Invalid SPI Data\\r\\n\\\", \\\\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\\\ 27); } - Add below code snippet above main function uint8_t txData[] = \\\"SELF LOOPBACK DEMO FOR SPI!\\\"; uint8_t rxData[sizeof(txData)]; &lt;img src = \\\"images/code_snippet5.png\\\" align=\\\"middle\\\"&gt; . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | . Verify extended functionality - SPI loopback . | Connect PA16 and PA19 on SAM D21 Curiosity Nano Evaluation Kit using a connecting wire. | Open Tera Term and observe the data as shown below. | . You can still control the LED0 by sending the commands through serial terminal. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"428": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"429": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Results",
    "content": "You observed the migration of application from ATmega4809 to SAMD21. You successfully used USART and STDIO to print the messages and receive the commands. Ports and EIC were used to control the LED and also configured SPI and DMA to perform self-loop back test. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#results",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#results"
  },"430": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"431": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Analysis",
    "content": "You have successfully created your first application using MPLAB Harmony v3 on a SAM D21 microcontroller. Your application used all the fundamental elements that go into building a real-time application. Your successfully migrated application from ATmega4809 to SAMD21. In this application, you used MPLAB Harmony Configurator (MHC) to configure the SAM D21 and also used the MPLAB Harmony v3 Framework. You used the clock configurator to set up the CPU clock and also configured Systick. You configured SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), SERCOM 1 (SPI), and External Interrupt Controller (EIC) Peripheral Libraries (PLIBs). You also configured the Direct Memory Access (DMA) using the DMA configurator. You used the pin configurator to set up the pins for LED and switch functions. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#analysis",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#analysis"
  },"432": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"433": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Conclusions",
    "content": "This guide provided you overview of migrating an application from ATmega4809 to SAMD21. This guide also provided steps to configure and using all the fundamental components needed to build an application on a SAM D21 microcontroller with MPLAB Harmony v3 framework. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#conclusions",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#conclusions"
  },"434": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html#reference-links",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html#reference-links"
  },"435": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmega4809_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/atmega4809_to_samd21_migration/readme.html"
  },"436": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Atmel START to MPLAB Harmony 3 Migration Guide",
    "content": "This page guides to the different steps to consider when porting an embedded application from Atmel® START to the MPLAB® Harmony 3 framework. It covers the following migration aspects: . | How to create a MPLAB Harmony 3 project under MPLAB X IDE and navigate through the MPLAB Harmony Configurator (MHC). | How to identify different elements that compose a project under Atmel START. | How to port the system/driver/middleware configuration using MPLAB Harmony Configurator. | Important aspects to consider when porting the project application layer. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html#atmel-start-to-mplab-harmony-3-migration-guide",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html#atmel-start-to-mplab-harmony-3-migration-guide"
  },"437": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html"
  },"438": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | Atmel START to MPLAB Harmony 3 Migration Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html#web-links"
  },"439": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html#reference-links"
  },"440": {
    "doc": "Atmel START to MPLAB Harmony 3 Guide",
    "title": "Atmel START to MPLAB Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/atmel_start_to_harmony_3/readme.html",
    "relUrl": "/source/migration/atmel_start_to_harmony_3/readme.html"
  },"441": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "content": "This page describes steps to build an MPLAB Harmony v3 project with ARM GNU Toolchain in MPLABX IDE. The page demonstrates configuring, building, and running an MPLAB Harmony v3 peripheral library (PLIB) application with the ARM GCC toolchain developed on the SAM D21 Xplained Pro Evaluation Kit. The application demonstrates how to use the AC (Analog Comparators) Peripheral library to perform a single-shot conversion when the peripheral is triggered by the RTC (Real-Time Counter) compare event. The generation of a trigger and compare operation is done while the CPU is in the standby sleep mode. The AC generates the interrupt at the end of the comparison which wakes the CPU. The SAM D21 Xplained Pro Evaluation Kit is ideal for evaluating and prototyping with the SAM D21 ARM® Cortex®-M0+ based microcontrollers. Xplained Pro Extension kits compatible with SAM D21 Xplained Pro can be purchased individually. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#build-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#build-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide"
  },"442": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"443": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Prerequisite:",
    "content": ". | Make sure MPLAB X IDE is installed and Harmony v3 repositories are cloned. For detailed information, refer MPLAB Harmony v3 | Download and install ARM GNU Toolchain v6.3.1 | Note: If Atmel Studio is already installed in PC, then installing ARM GCC toolchain is not required as Atmel Studio is already bundled with ARM GNU Toolchain. | . There are two ways to use this guide: . | Use the solution project as an example: . | Build the solution project and program it to the SAM D21 Xplained Pro Evaluation Kit to observe the expected behavior. | . | Create the project from scratch: . | Follow step-by-step instructions below. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#prerequisite",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#prerequisite"
  },"444": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Instructions to configure, build and run MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "content": "The following bullet points provides links to the topics: . | Hardware Used | Software/Tools Used | Description . | Overview | Open Project and Compile using XC32 Toolchain | Configure the project to use ARM GCC Toolchain | Compile the project using ARM GCC Toolchain | Running the Demo | . | Results | Conclusions | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#instructions-to-configure-build-and-run-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#instructions-to-configure-build-and-run-mplab-harmony-v3-project-with-arm-gcc-toolchain-in-mplab-x-ide"
  },"445": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"446": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Hardware Used:",
    "content": ". | SAM D21 Xplained Pro Evaluation Kit | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#hardware-used",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#hardware-used"
  },"447": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"448": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Software/Tools Used:",
    "content": "This project has been verified to work with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “csp_apps_sam_d21_da1” repo v3.2.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | ARM GNU Toolchain v6.3.1 | MPLAB XC32 Compiler v4.00 | Any Serial Terminal application like Tera Term terminal application. | . Because Microchip regularly update tools, occasionally issue(s) could be discovered while using the newer versions of the tools. If the project doesn’t seem to work and version incompatibility is suspected, It is recommended to double-check and use the same versions that the project was tested with. ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#softwaretools-used",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#softwaretools-used"
  },"449": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Setting up SAM D21 Xplained Pro Evaluation Kit:",
    "content": ". | Connect a voltage below VDD to pin 17 of the EXT1 connector | Connect the Debug USB port on the board to the computer using a micro USB cable | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#setting-up-sam-d21-xplained-pro-evaluation-kit",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#setting-up-sam-d21-xplained-pro-evaluation-kit"
  },"450": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"451": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Description",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#description",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#description"
  },"452": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": "Overview: . The AC Sleepwalking Harmony v3 Application on SAM D21 Xplained Pro Evaluation Kit is used to show the steps to compile the project with ARM GCC Toolchain in MPLAB X IDE. Note: The AC Sleepwalking demo application is chosen as an example. The user could chose to use any MPLAB Harmony v3 application developed on MPLAB X IDE to be built with the ARM GCC toolchain. Open project and compile using XC32 Toolchain: . Note: This is an optional step. This could be followed to verify whether the existing Harmony v3 example used in this guide builds and works on the XC32 compiler toolchain. | Open MPLAB X IDE and close if any projects are opened. | Download the Harmony 3 peripheral library application examples for SAM D21/DA1 family csp_apps_sam_d21_da1 then goto /apps/ac/ac_sleepwalk_singleshot/firmware and select the “sam_d21_xpro.X” configuration. | Before changing the toolchain to ARM GCC, ensure the example application demo is compiling and working fine with existing the XC32 toolchain. This is to avoid any errors because of missing library or source files. | Select the Project -&gt; Right Click -&gt; Properties -&gt; ensure correct hardware and XC32 compiler version is selected. | Compile the project. | Run on hardware to ensure the project is working as expected. | . Configure the project to use ARM GCC Toolchain: . This can be done with two methods, either automatically or manually. | Automatic Detection: If Atmel Studio is installed in PC, By default, MPLAB X IDE detects the ARM GCC toolchain (installed as a part of Atmel Studio) and shows it in the MPLAB X IDE’s Project properties. Refer the figure which shows ARM GCC Toolchain selection. Since the ARM GCC toolchain is already available, switch to the ARM GCC toolchain from the project properties. | Manual: If Atmel Studio is not installed, install the ARM GCC toolchain manually. Go to MPLAB X IDE -&gt; Tools -&gt; Options -&gt; Embedded -&gt; Build Tools -&gt; Add -&gt; give the base directory -&gt; **/toolchain/arm/arm-gnu-toolchain/bin\\\"**. Save it. | | Now, select the ARM GCC toolchain in the example application demo project properties. Select the Project -&gt; Right Click -&gt; Properties -&gt; select the ARM GCC toolchain in compiler options and save. | | . | . Compile the project using ARM GCC Toolchain: . If the project is compiled at this point, the compiler may throw some errors. To avoid compiler errors, follow the below steps. | Add include directories as shown in the following image to avoid missing file errors for device.h and device_cache.h. | The include directory paths are shown below: . | csp_apps_sam_d21_da1/apps/ac/ac_sleepwalk_singleshot/firmware/src/config/sam_d21_xpro | csp_apps_sam_d21_da1/apps/ac/ac_sleepwalk_singleshot/firmware/src/packs/ATSAMD21J18A_DFP | . | | . | Comment the user row configuration bits #pragmas from the “initialization.c” file. This is because #pragmas are not recognized by the ARM GCC compiler. | . | Add or Edit the below files to make the project work with ARM GCC toolchain. | Add custom Linker file to the project. | Replace XC32 startup code with ARM GCC startup code. This can be done by adding “startup_gcc.c” file and excluding (or removing) “startup_xc32.c” file from project. Edit “libc_syscalls.c” file to compile with ARM GCC toolchain. | Add STDIO -&gt; “gcc_monitor.c” file to make printf/scanf work properly. Exclude (or remove) the “xc32_monitor.c” file from the MPLAB Harmony v3 project. | | This can be done as follows: | Go to config folder of Harmony v3 project config folder | Download the SAM D21 AC Sleepwalking solution project -&gt; samd21_ac_sleepwalk_singleshot_gcc.zip | After downloading the solution project, copy the files from /apps/sam_d21_xpro/samd21_ac_sleepwalk_singleshot_gcc/src_gcc_toolchain and paste in the example application (downloaded from csp_apps_sam_d21_da1) folder apps/ac/ac_sleepwalk_singleshot/firmware/src/config/sam_d21_xpro | Paste the files “ATSAMD21J18A.ld”, “startup_gcc.c” in “sam_d21_xpro” folder and “gcc_monitor.c” file in “stdio” folder. | Right click Linker Files in MPLABX project -&gt; Click Add Existing Item -&gt; select corresponding recently added linker file and add to project. Below image is for reference. | . | Similarly, add “startup_gcc.c” file and “gcc_monitor.c” file to the project. | To Exclude a file from Project -&gt; select the file -&gt; Right Click -&gt; select “Exclude file(s) from current configuration” or Remove file from the Project. The former option just exclude from the project and latter option will remove the file from project. | Replace the contents of “libc_syscalls.c” file in the project with the contents of “libc_syscalls.c” file in the zip. This file has definition of_sbrk() needed for ARM GCC compiler in addition to content what already present in it. | . | After completing the above steps, compile the project. | The project should compile successfully. | . | . Running the Demo: . | Perform Prerequisite, Configure the project to use ARM GCC toolchain, Compile the project using ARM GCC Toolchain and Setting up SAM D21 Xplained Pro Evaluation Kit steps mentioned above, if not done already. | Open the Tera Term terminal application on your PC (from the Windows® Start menu by pressing the Start button) | Connect to the EDBG Virtual COM port and configure the baud rate to 115200 | Build and Program the application using the MPLAB X IDE. | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"453": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"454": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Results:",
    "content": ". | The console displays the message stating whether voltage at PA04 is lower or greater than the internal bandgap voltage (1.1 V) | LED0 toggles when comparison is done. | . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#results",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#results"
  },"455": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"456": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Conclusions:",
    "content": "This guide demonstrated building an MPLAB Harmony v3 peripheral Libraries (PLIBs) example with ARM GCC Toolchain. The same approach can be followed for any other Harmony v3 project. ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#conclusions",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#conclusions"
  },"457": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html#reference-links",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html#reference-links"
  },"458": {
    "doc": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "title": "Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/build_harmony_3_project_with_gcc/readme.html",
    "relUrl": "/source/migration/build_harmony_3_project_with_gcc/readme.html"
  },"459": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Code generation and API considerations for migration from MCC",
    "content": "Using a configuration tool enables the user to provide a proof of concept to evaluate the device and reduce the need to understand every setting in a peripheral’s operation for proper function. The APIs generated by a configuration tool are largely determined by the requirements of the peripherals’ configured, the architecture of the device, and design decisions for API continuity, especially when associated with a framework. Therefore, an API for one device can be significantly different in size and system content from another. For more information refer section 7 “Migration from MCC” in the the link below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/code_generation_api_migration_from_mcc/readme.html#code-generation-and-api-considerations-for-migration-from-mcc",
    "relUrl": "/source/migration/code_generation_api_migration_from_mcc/readme.html#code-generation-and-api-considerations-for-migration-from-mcc"
  },"460": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/code_generation_api_migration_from_mcc/readme.html",
    "relUrl": "/source/migration/code_generation_api_migration_from_mcc/readme.html"
  },"461": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Web Links",
    "content": ". | SAM D21 Curiosity Nano: MPLAB Harmony v3 PLIBs Setup and Evaluation | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/code_generation_api_migration_from_mcc/readme.html#web-links",
    "relUrl": "/source/migration/code_generation_api_migration_from_mcc/readme.html#web-links"
  },"462": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/code_generation_api_migration_from_mcc/readme.html#reference-links",
    "relUrl": "/source/migration/code_generation_api_migration_from_mcc/readme.html#reference-links"
  },"463": {
    "doc": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "title": "Application migration from 8 bit AVR to 32 bit SAM D21",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/code_generation_api_migration_from_mcc/readme.html",
    "relUrl": "/source/migration/code_generation_api_migration_from_mcc/readme.html"
  },"464": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Differences between MPLAB® Harmony 2 and MPLAB® Harmony 3",
    "content": "This page overviews key differences between MPLAB® Harmony 2 and MPLAB® Harmony 3. | Supports SAM Devices | Differences in Peripheral libraries | Differences in Drivers and Services | No Differences in Middleware! | Differences in the MHC GUI | Online Help | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html#differences-between-mplab-harmony-2-and-mplab-harmony-3",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html#differences-between-mplab-harmony-2-and-mplab-harmony-3"
  },"465": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html"
  },"466": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Web Links",
    "content": ". | Differences between MPLAB Harmony 2 and MPLAB Harmony 3 | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html#web-links"
  },"467": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html#reference-links"
  },"468": {
    "doc": "Differences between Harmony 2 to Harmony 3",
    "title": "Differences between Harmony 2 to Harmony 3",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/differences_harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/differences_harmony_2_to_harmony_3/readme.html"
  },"469": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "MPLAB Harmony 3 Application Development Guide for MPLAB Harmony 2 Users",
    "content": "This page is intended to guide MPLAB® Harmony 2 users on how to develop applications using MPLAB Harmony 3. MPLAB Harmony is a software framework consisting of compatible and interoperable modules, such as peripheral libraries (PLIBs), drivers, system services, middleware, and third-party libraries. MPLAB Harmony 3 has the same basic principles as MPLAB Harmony 2; however, new features and improvements were made for this release. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html#mplab-harmony-3-application-development-guide-for-mplab-harmony-2-users",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html#mplab-harmony-3-application-development-guide-for-mplab-harmony-2-users"
  },"470": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html"
  },"471": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony v3 Application Development Guide for MPLAB Harmony v2 Users | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html#web-links"
  },"472": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html#reference-links"
  },"473": {
    "doc": "Harmony 2 to Harmony 3 Guide",
    "title": "Harmony 2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/harmony_2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/harmony_2_to_harmony_3/readme.html"
  },"474": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Introduction to MPLAB and Harmony 3 for Atmel Studio and ASF users",
    "content": "This page overviews introduction to MPLAB® X IDE and MPLAB Harmony v3 framework for the users to get started with new tools and solutions for 32-bit Arm microcontrollers. This page guides Atmel Studio, Atmel START and ASF users to familiarize with MPLAB X IDE and MPLAB Harmony 3. The page also guides to the description of MPLAB X IDE features, MPLAB Harmony v3 architecture, and cite references to equivalent features in Atmel Studio or ASF to enable better understanding. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#introduction-to-mplab-and-harmony-3-for-atmel-studio-and-asf-users",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#introduction-to-mplab-and-harmony-3-for-atmel-studio-and-asf-users"
  },"475": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html"
  },"476": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Web Links",
    "content": ". | Introduction to MPLAB and Harmony v3 for Atmel Studio and ASF users | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#web-links",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#web-links"
  },"477": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#reference-links",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html#reference-links"
  },"478": {
    "doc": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "title": "Introduction to MPLABX and Harmony 3 to Atmel Studio and ASF Users",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html",
    "relUrl": "/source/migration/introduction_mplabx_harmony_3_to_studio_asf_users/readme.html"
  },"479": {
    "doc": "MPLAB Harmony v3 Project Migration",
    "title": "MPLAB Harmony v3 Project Migration",
    "content": "MPLAB® Harmony v3 is a modular framework that provides interoperable firmware libraries for application development on 32-bit microcontrollers and microprocessors. It includes an easy-to-use graphical user interface (GUI), MPLAB Code Configurator (MCC), or MPLAB Harmony Configurator (MHC) for selection, configuration, code generation, peripheral libraries, drivers, and extensive middlewares such as, USB, TCP/IP, Graphics. This document discusses the migration of an existing MPLAB Harmony v3 based project developed on a particular hardware (microcontroller or development board) platform to another one of Microchip’s 32-bit hardware platforms of the user’s choice. Note:  In this document, the phrase code generation tool refers to any one of the Microchip code generation tools: MPLAB Code Configurator (MCC) and MPLAB Harmony Configurator (MHC). At the time of publication of this document, the MPLAB Harmony v3 library code can be generated using either of these tools. However, in the future, only MCC will support MPLAB Harmony v3 code generation. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/mplab_harmony_v3_project_migration/readme.html#mplab-harmony-v3-project-migration",
    "relUrl": "/source/migration/mplab_harmony_v3_project_migration/readme.html#mplab-harmony-v3-project-migration"
  },"480": {
    "doc": "MPLAB Harmony v3 Project Migration",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/mplab_harmony_v3_project_migration/readme.html",
    "relUrl": "/source/migration/mplab_harmony_v3_project_migration/readme.html"
  },"481": {
    "doc": "MPLAB Harmony v3 Project Migration",
    "title": "Web Links",
    "content": ". | MPLAB Harmony v3 Project Migration | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/mplab_harmony_v3_project_migration/readme.html#web-links",
    "relUrl": "/source/migration/mplab_harmony_v3_project_migration/readme.html#web-links"
  },"482": {
    "doc": "MPLAB Harmony v3 Project Migration",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/mplab_harmony_v3_project_migration/readme.html#reference-links",
    "relUrl": "/source/migration/mplab_harmony_v3_project_migration/readme.html#reference-links"
  },"483": {
    "doc": "MPLAB Harmony v3 Project Migration",
    "title": "MPLAB Harmony v3 Project Migration",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/mplab_harmony_v3_project_migration/readme.html",
    "relUrl": "/source/migration/mplab_harmony_v3_project_migration/readme.html"
  },"484": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Application migration from 8-bit PIC18F to 32-bit SAM D21 MCU",
    "content": "This page acts as a reference for migrating applications from 8-bit PIC Microcontroller (MCU) to 32-bit SAM MCU. This page shows how to migrate an application from PIC18F47Q10 MCU to SAMD21G17D MCU with the help of an example. For the migration to a 32-bit MCU, the application uses SAM D21 Curiosity Nano Evaluation Kit and is developed on MPLAB® Harmony v3 software framework. The SAM D21 Curiosity Nano Evaluation Kit is a hardware platform to evaluate the SAMD21G17D microcontroller (MCU). It is supported by the MPLAB® X Integrated Development Environment (IDE) and MPLAB Harmony v3 software development framework. The evaluation kit provides easy access to the features of the SAM D21 MCU to integrate the device into a custom design. Because the evaluation kit contains an On-Board Nano Debugger for programming and debugging, no external tools are necessary to program the SAMD21G17D device. The evaluation kit is compatible with Curiosity Nano Base board (Part Number - AC164162) which allows you to quickly scale and prototype your next innovative design using the SAMD21G17D MCU. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. This migration guide refers an existing application Getting Started with UART Using EUSART on PIC18 developed on PIC18F47Q10 Curiosity Nano evaluation kit using MPLAB® Code Configurator (MCC) and discuss steps to migrate the existing application to SAM D21 Curiosity Nano Evaluation Kit using MPLAB® Harmony Configurator (MHC). The application is further extended by adding more peripheral specific functionality. The application developed on SAM D21 MCU will utilize: . | PORT PLIB to control the LED. | External Interrupt Controller (EIC) PLIB and Systick PLIB to toggle the LED on SWITCH press event | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), STDIO Library and Direct Memory Access (DMA) PLIBs to print the Info messages on a COM (serial) port terminal application running on a PC and to receive command from serial terminal. | SERCOM (as SPI) to run a self-loopback test. | . Two ways to use this guide: . | Create the project from scratch: . | Follow step-by-step instructions below. | . | Use the solution project as an example: . | Build the solution project and program it to the SAM D21 Curiosity Nano Evaluation Kit to observe the expected behavior. | . | . This following bullet points provides links to the topics: . | Hardware Used | Software/Tools Used | Hardware Setup | Description . | Overview | Install MHC | Create MPLAB Harmony v3 Project | Configure Clock | Add SERCOM (USART) Peripheral | Generate Code | Add Code | Build and Program | Verify “Hello World” output | Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality | Verify Formatted STDIO, USART Receive and SWITCH/LED functionality | Extend application to configure SPI loopback using DMA based Transfers | Verify extended functionality - SPI loopback | . | Results | Analysis | Conclusions | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#application-migration-from-8-bit-pic18f-to-32-bit-sam-d21-mcu",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#application-migration-from-8-bit-pic18f-to-32-bit-sam-d21-mcu"
  },"485": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"486": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Hardware Used:",
    "content": ". | SAM D21 Curiosity Nano Evaluation Kit | Connection wires | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#hardware-used",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#hardware-used"
  },"487": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"488": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Software/Tools Used:",
    "content": "This project has been verified to work with the following versions of software tools: . | MPLAB Harmony v3 “csp” repo v3.12.0 | MPLAB Harmony v3 “dev_packs” repo v3.12.0 | MPLAB Harmony v3 “mhc” repo v3.8.5 | MPLAB Harmony 3 Launcher Plugin v3.6.4 | MPLAB X IDE v6.00 | MPLAB XC32 Compiler v4.00 | Any Serial Terminal application like Tera Term terminal application. | . Because Microchip regularly update tools, occasionally issue(s) could be discovered while using the newer versions of the tools. If the project doesn’t seem to work and version incompatibility is suspected, It is recommended to double-check and use the same versions that the project was tested with. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#softwaretools-used",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#softwaretools-used"
  },"489": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"490": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Hardware Setup",
    "content": ". | Connect the SAM D21 Curiosity Nano Development Board to the Host PC as a USB Device through a Type-A male to micro-B USB cable connected to Micro-B USB (Debug USB) port | Connect a wire from PA16 to PA19 on SAM D21 Curiosity Nano Development Kit for SPI Self Loopback testing. | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#hardware-setup",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#hardware-setup"
  },"491": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"492": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Description",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#description",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#description"
  },"493": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": "Overview . This migration guide uses the PIC18 application which helps in “Getting Started with UART Using EUSART on PIC18”. | Click Here to view/download the application. | For details on the application, refer “Section 4” in the user guide. | . The PIC18 application shows how to implement a command line interface. This way, the microcontroller can receive control commands via the EUSART. In this use case, an LED is controlled using commands sent from the MPLAB Data Visualizer. The application flow is as follows: . | Configures the system clock The clock is configured to 1 MHz using High Frequency Internal Oscillator (HFINTOSC). | Configures USART3 USART3 is configured for 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | Configures pins The USART TX, RX pins and LED pin are configured | Implements STDIO receive and send functions STDIO library is implemented to receive and send commands from serial terminal | Reads and execute valid commands Receives command from serial terminal and executes it | . Follow the below steps to get started migrating to SAMD21 and later extend the functionality by adding more peripherals. Install MHC . | Install the MPLAB® Harmony Configurator (MHC) Plug-in in the MPLAB X IDE if not installed. | Verify the MPLAB® Harmony Configurator (MHC) Plug-in is installed. | Launch MPLAB X IDE from the Windows® Start Menu. Close all the projects and files that are currently open. | Go to Tools &gt; Embedded. | You will see MPLAB Harmony 3 Configurator in the menu | . | . Create MPLAB Harmony v3 Project . | Create MPLAB Harmony v3 Project Using MPLAB X IDE . | Select File &gt; New Project from the main IDE menu | In the Categories pane of the New Project dialog window, select Microchip Embedded. In the Projects pane, select 32-bit MPLAB Harmony 3 Project, then click Next | In the Framework Path edit box, browse to the folder you downloaded the framework to and select Next | In the Project Settings window, apply the following settings: | . | Location: indicates the path to the root folder of the new project. All project files will be placed inside this folder. The project location can be any valid path, for example: &lt;your project path&gt;\\\\pic18f_to_samd21 | Folder: indicates the name of the MPLAB X .X folder. Enter “pic18f_to_samd21_migration” to create a pic18f_to_samd21_migration.X folder. | Name: enter the project’s logical name as “pic18f_to_sam_d21_cnano”. This is the name that will be shown from within the MPLAB X IDE. | Click Next to proceed to configuration settings | Follow the steps below to set the project’s configuration settings: | . | Name: enter the configuration name as “sam_d21_cnano”. | Target Device: select ATSAMD21G17D as the target device. | After selecting the target device, click Finish to launch MHC. | Device family pack path can be modified in below window. For now, use the default values | The MHC plugin’s main window for the project will be displayed as shown in the following image | . | . Configure Clock . | Configuring Clock Settings The SAM D21 family of microcontrollers (MCUs) contains a sophisticated clock distribution system designed to give maximum flexibility to the user application. The clock system allows the tuning of the performance and power consumption of the device in a dynamic manner. The MHC provides an easy to use UI (User Interface) window, and a Clock Easy View window to configure the system and peripheral clocks. | Launch Clock Easy View by going to Tools menu of MHC window and then select Clock Configuration | In the Clock Easy View, SAM D21 can operate at maximum 48 MHz, therefore Main Clock is set to 48 MHz. | Change the Main Clock to 1MHz | The Open loop Digital Frequency Locked Loop (DFLL 48 MHz) is configured and enabled to run the main clock. The configured DFLL is fed as input to the GCLK generator ‘0’ and a suitable clock divider (48) and masker must be selected to achieve a maximum frequency of 1 MHz. Refer to the following figure to configure the main clock to run at 1MHz | . | . MHC clock easy view provides all the clock options available in the SAMD21 in a UI, which makes easier to configure the clock whenever necessary. Add SERCOM (USART) Peripheral . | Adding SERCOM (USART) Peripheral MHC Graphical User Interface helps in selecting and configuring the peripherals needed by the project. It lists all the peripherals available in SAMD21 in an Active Component tab. | . | Click on the Available Components tab in the left pane in the MPLAB® Harmony Configurator (MHC) window. Expand Peripherals &gt; SERCOM | Double click or drag and drop SERCOM5 to add the USART Peripheral Library (PLIB) to the project graph. | . Note: SAM D21 Curiosity Nano On-Board Nano Debugger also includes a Virtual Com port which is routed to SERCOM5, therefore in this application, SERCOM5 is chosen. | Select the SERCOM5 Peripheral Library in the project graph. Verify that the default “SERCOM Operation Mode” configuration is set as USART and configure 9600 baud rate and the standard 8-N-1 (eight data bits, no parity bit and one Stop bit) frame format. | . | Configuring USART pins using MHC PIN Configurator The Pin Manager consists of Pin Settings, the Pin Diagram, and the Pin Table tabs, which enables users to configure (assign peripheral function, set pin direction, configure pull-up or pull-down and so on) and map the I/O pins. | . The following color combinations are associated with the pins in the graphical or table View:  Gray: This pin is not usable in the selected configuration, and there is no enabled module which has any functionality on that pin. The grayed-out locks on a white background indicates the pins that are locked out by selected system functions.  Blue: This pin is available and can be allocated to a module.  Green (with a lock): This pin is allocated and selected for a module. The name displayed against the pin is either the name of the pin in the module’s context or a custom name entered. | Open the Pin Configuration tabs by clicking on MHC &gt; Tools &gt; Pin Configuration. | Launching Pin configuration opens Pin Settings, the Pin Diagram, and the Pin Table tabs. | select the MHC Pin Table tab and then scroll down to the SERCOM5 module as shown below.  Enable USART_TX on PA22 (Pin #31)  Enable USART_TX on PB22 (Pin #37) | . Generate Code . | Generate Code . | When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC) as shown below. | Save the configuration in its default location when prompted. | Click on the Code Generate button as shown below to start generating code. | . | . | Click on the Generate button in the Generate Project window, keeping the default settings as shown below. If prompted for saving the configuration, click Save. | As the code is generated, MHC displays the progress as shown below. | Navigate to the Projects tab in MPLAB X IDE to view the project tree structure. | Examine the generated code as shown below. | . MHC will include all the MPLAB Harmony library files and generate the code based on the MHC selections. The generated code would add files and folders to your Harmony project as shown. Among the generated code, notice the Peripheral Library (PLIB) files generated for SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), Clock and PORT peripherals. Add Code . | Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet in main function to print “Hello World” string on the serial terminal. uint8_t welcomeData[] = “Hello World\\r\\n”; . while ( true ) { SERCOM5_USART_Write(&amp;welcomeData[0],sizeof(welcomeData)); } &lt;img src = \\\"images/code_snippet1.png\\\" width=\\\"400\\\" height=\\\"300\\\" align=\\\"middle\\\"&gt; . | . Build and Program . | Before proceeding to Build and program, set up the compiler toolchain. Click on the Projects tab on the top left pane in MPLAB X IDE. Right click on the project name pic18f_to_sam_d21_cnano and go to Properties. | Make sure that XC32 (v2.41) is selected as the Compiler Toolchain for XC32. Click on Apply and then click on OK. | Clean and build your application by clicking on the Clean and Build button as shown below. | Program your application to the device by clicking on the Make and Program button as shown below. The lab should build and program successfully. | . Verify “Hello World” output . | Now, open the Tera Term terminal application on your PC (from the Windows® Start menu by pressing the Start button). Select the Serial Port as shown below. | Change the baud rate to 9600. | You should see the “Hello World” message displayed on the terminal as shown below. | . You successfully completed printing the “Hello World” message on serial terminal. Let us continue and extend the functionality of the application as below. Configure/Enable Formatted STDIO, USART Receive and SWITCH/LED functionality . | Configure STDIO Library to use printf and scanf function to write and read data from the serial terminal respectively | Receive the command from serial terminal and control the LED0 on the SAM D21 Curiosity evaluation kit | Use Switch SW0 on the SAM D21 Curiosity Evaluation Kit to toggle the LED twice when it is pressed. External Interrupt controller (EIC) and Systick peripherals are used to achieve this . | If you closed MHC accidently and would like to open it again, go to Tools &gt; Embedded &gt; MPLAB Harmony 3 Configurator in MPLAB X IDE. | In the Project Graph, Select SERCOM5. Right click on yellow diamond and select consumer as STDIO as shown below | Select the MHC Pin Settings tab and then scroll down to the PORT pin PB10 (Pin Number 19) in the Pin ID column and configure PB10 as an output pin for LED functionality as shown below. | Select the Pin Settings tab and then scroll down to the PORT pin PB11 (Pin Number 20) in the Pin ID column and configure PB11 as an external interrupt pin for switch functionality as shown below. Internal pull-up is enabled to avoid false edge detection as there is no external pull-up on the SAM D21 Curiosity Nano Evaluation Kit. | Select the Project Graph tab. | . | Under the Available Components tab, expand Peripheral &gt; EIC. Select and double click on EIC to add the EIC module to the project. | . | Configure the EIC block to generate an interrupt every time the user presses the switch SW0 as shown below and enable filter functionality to avoid electrical noise on the switch pin. 21. Enable Systick to create a delay for toggling LED0, click on System in Project Graph and Configure as below. 22. When done, before generating code, click the Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. 23. Click on the Code Generate button to start generating code. 24. Click on the Generate button in the Generate Project window, keeping the default settings. If prompted for saving the configuration, click Save. 25. Navigate to the Projects tab in MPLAB X IDE and select main.c, add below code snippet to receive the command from serial terminal and a function to control the LED0 on the SAM D21 Curiosity Nano Evaluation Kit. | . | In main.c, add the below function above “main” function #include . void executeCommand(char *command) { if(strcmp(command, \\\"ON\\\") == 0) { LED_Clear(); printf(\\\"OK, LED ON.\\r\\n\\\"); } else if (strcmp(command, \\\"OFF\\\") == 0) { LED_Set(); printf(\\\"OK, LED OFF.\\r\\n\\\"); } else { printf(\\\"Incorrect command.\\r\\n\\\"); } } &lt;img src = \\\"images/code_snippet2.png\\\" align=\\\"middle\\\"&gt; . | Move “SERCOM5_USART_Write” function above while loop and add scanf inside the while loop as shown below. | Now, open the Tera Term terminal application on your PC. Enable Local echo in Setup &gt; Terminal as shown below. | Clean and build your application by clicking on the Clean and Build button. | . | . Verify Formatted STDIO, USART Receive and SWITCH/LED functionality . | Program your application to the device by clicking on the Make and Program button. The lab should build and program successfully. | In Tera Term you should see “Hello World” message displayed. | Type ON in serial terminal and press Enter to turn on LED0 on SAMD21 Curiosity Nano kit and Type OFF in serial terminal and press Enter to turn off LED0 on SAMD21 Curiosity Nano Evaluation Kit. | Switch SW0 is configured as interrupt using EIC peripheral, therefore register a call back in main function. Whenever user presses the switch, a callback will be notified and inside the call back, toggle the LED0 twice. | In main.c file, inside main function, add the below code. EIC_CallbackRegister(EIC_PIN_11,EIC_User_Handler, 0); SYSTICK_TimerStart(); | In main.c, add the below code above main function static void EIC_User_Handler(uintptr_t context) { uint8_t i = 0; . while(i&lt;4){ LED_Toggle(); SYSTICK_DelayMs(500); i++; } } &lt;img src = \\\"images/code_snippet4.png\\\" align=\\\"middle\\\"&gt; . | . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | Press the Switch SW0 on SAM D21 Curiosity Nano Evaluation Kit and observe LED0 Toggling twice at 500ms rate. You successfully completed controlling the LED0 on the SAMD21 Curiosity Nano Evaluation Kit by receiving the commands from the serial terminal through USART and also toggled the LED0 on Switch SW0 press using EIC and Systick peripheral. | . Extend application to configure SPI loopback using DMA based Transfers . Let us extend the functionality and add Serial Peripheral Interface (SPI) to perform a Self-Loopback test and add Direct memory address (DMA) to send the status of the SPI Transfer to the terminal without using CPU. | Select the Project Graph tab. Under the Available Components tab, expand Peripheral &gt; SERCOM. Select and double click on SERCOM1 to add the SPI module to the project. | In Project Graph select SERCOM1 and configure as below . | Open Pin Table, Select SERCOM1 and configure the pins as shown below . | Launch DMA Configurator from MHC &gt; Tools &gt; DMA Configuration | Click on ADD Channel and Select SERCOM5_Transmit to configure the DMA | When done, before generating code, click the *Save icon in MPLAB® Harmony Configurator (MHC). Save the configuration in its default location when prompted. | Click on the Code Generate button to start generating code. | Click on the Generate button in the Generate Project window, keeping the default settings. | If prompted for saving the configuration, click Save. | In main.c, Add below code snippet SERCOM1_SPI_WriteRead(&amp;txData[0], sizeof(txData), &amp;rxData[0], sizeof(rxData)); . /* Compare received data with the transmitted data */ if ((memcmp(txData, rxData, sizeof(txData)) == 0)) { /* Pass: Received data is same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \\\"Received SPI Valid Data\\r\\n\\\", \\\\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\\\ 25); } else { /* Fail: Received data is not same as transmitted data */ DMAC_ChannelTransfer(DMAC_CHANNEL_0, \\\"Received Invalid SPI Data\\r\\n\\\", \\\\ (const void *)&amp;(SERCOM5_REGS-&gt;USART_INT.SERCOM_DATA), \\\\ 27); } - Add below code snippet above main function uint8_t txData[] = \\\"SELF LOOPBACK DEMO FOR SPI!\\\"; uint8_t rxData[sizeof(txData)]; &lt;img src = \\\"images/code_snippet5.png\\\" align=\\\"middle\\\"&gt; . | Clean and build your application by clicking on the Clean and Build button. | Program your application to the device by clicking on the Make and Program button. | . Verify extended functionality - SPI loopback . | Connect PA16 and PA19 on SAM D21 Curiosity Nano Evaluation Kit using a connecting wire. | Open Tera Term and observe the data as shown below. | . You can still control the LED0 by sending the commands through serial terminal. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"494": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"495": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Results",
    "content": "You observed the migration of application from PIC18F to SAMD21. You successfully used USART and STDIO to print the messages and receive the commands. Ports and EIC were used to control the LED and also configured SPI and DMA to perform self-loop back test. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#results",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#results"
  },"496": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"497": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Analysis",
    "content": "You have successfully created your first application using MPLAB Harmony v3 on a SAM D21 microcontroller. Your application used all the fundamental elements that go into building a real-time application. Your successfully migrated application from PIC18F to SAMD21. In this application, you used MPLAB Harmony Configurator (MHC) to configure the SAM D21 and also used the MPLAB Harmony v3 Framework. You used the clock configurator to set up the CPU clock and also configured Systick. You configured SERCOM 5 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)), SERCOM 1 (SPI), and External Interrupt Controller (EIC) Peripheral Libraries (PLIBs). You also configured the Direct Memory Access (DMA) using the DMA configurator. You used the pin configurator to set up the pins for LED and switch functions. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#analysis",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#analysis"
  },"498": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"499": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Conclusions",
    "content": "This guide provided you overview of migrating an application from PIC18F to SAMD21. This guide also provided steps to configure and using all the fundamental components needed to build an application on a SAM D21 microcontroller with MPLAB Harmony v3 framework. ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#conclusions",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#conclusions"
  },"500": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html#reference-links",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html#reference-links"
  },"501": {
    "doc": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "title": "Application migration from 8 bit PIC18F to 32 bit SAM D21",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/pic18f_to_samd21_migration/readme.html",
    "relUrl": "/source/migration/pic18f_to_samd21_migration/readme.html"
  },"502": {
    "doc": "Migrating a MPLAB Harmony 3 Application from the SAM9X60 EK to SAM9X60 Curiosity",
    "title": "Migrating a MPLAB® Harmony 3 Application from the SAM9X60-EK to SAM9X60-Curiosity",
    "content": "This guide provides a step by step procedure to migrate an MPLAB® Harmony 3 application developed for the SAM9X60-EK Evaluation Kit to the SAM9X60-Curiosity Development Board. We will use a CSP Application, RTT Periodic Timeout, as an example. When an RTT timer interrupt occurs, the project blinks the RGB LED once per second. The functions of MPLAB Harmony 3 Content Manager (MHCM) and Configurator (MHC) are being migrated to MPLAB Code Configurator (MCC), you will use MCC for configuring and building the project. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html#migrating-a-mplab-harmony-3-application-from-the-sam9x60-ek-to-sam9x60-curiosity",
    "relUrl": "/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html#migrating-a-mplab-harmony-3-application-from-the-sam9x60-ek-to-sam9x60-curiosity"
  },"503": {
    "doc": "Migrating a MPLAB Harmony 3 Application from the SAM9X60 EK to SAM9X60 Curiosity",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html",
    "relUrl": "/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html"
  },"504": {
    "doc": "Migrating a MPLAB Harmony 3 Application from the SAM9X60 EK to SAM9X60 Curiosity",
    "title": "Web Links",
    "content": ". | MPLAB Harmony 3 Application Migration Guide from the SAM9X60-EK to SAM9X60-Curiosity Development Board. | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html#web-links",
    "relUrl": "/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html#web-links"
  },"505": {
    "doc": "Migrating a MPLAB Harmony 3 Application from the SAM9X60 EK to SAM9X60 Curiosity",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html#reference-links",
    "relUrl": "/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html#reference-links"
  },"506": {
    "doc": "Migrating a MPLAB Harmony 3 Application from the SAM9X60 EK to SAM9X60 Curiosity",
    "title": "Migrating a MPLAB Harmony 3 Application from the SAM9X60 EK to SAM9X60 Curiosity",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html",
    "relUrl": "/source/migration/sam9x60_ek_to_sam9x60_curiosity_harmony/readme.html"
  },"507": {
    "doc": "Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC",
    "title": "Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC",
    "content": "This tutorial shows you how to migrate an application from Advanced Software Framework (ASF) to MPLAB® Harmony v3 software framework using 32-bit Arm® Cortex®-based M0+ PIC32CM MC microcontroller. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help you quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. The application makes use of the PIC32CM MC Curiosity Development Board and the I/O1 Xplained Pro Extension Kit (sold separately). This tutorial will migrate a pre-developed ASF SAMC21 IO1 xplained demo application available in Atmel START. The application reads current room temperature from the temperature sensor and light level from light sensor on the I/O1 Xplained Pro Extension and sends it to the console. This training module will implement the same application and will also demonstrate the callback feature. The application you create will utilize: . | SERCOM (as I²C) PLIB to read the temperature from a temperature sensor. | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) PLIBs and STDIO library to print the temperature values on a COM (serial) port terminal application running on a PC. | The ADC peripheral library is used to read data from the light sensor. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html#migrating-asf-sam-c21-application-to-mplab-harmony-v3-pic32cm-mc",
    "relUrl": "/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html#migrating-asf-sam-c21-application-to-mplab-harmony-v3-pic32cm-mc"
  },"508": {
    "doc": "Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html",
    "relUrl": "/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html"
  },"509": {
    "doc": "Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC",
    "title": "Web Links",
    "content": ". | Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html#web-links",
    "relUrl": "/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html#web-links"
  },"510": {
    "doc": "Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html#reference-links",
    "relUrl": "/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html#reference-links"
  },"511": {
    "doc": "Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC",
    "title": "Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html",
    "relUrl": "/source/migration/samc21_asf_to_pic32cmmc_harmony/readme.html"
  },"512": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "MPLAB Harmony 2 to Harmony 3 TCP/IP Application Migration Guide",
    "content": "This guide provides the step by step procedure to migrate a TCPIP application from Harmony 2 to Harmony 3 environment. This will configure the MPLAB Harmony 3 TCPIP/IP Stack, System components and other middleware components. In this migration you will learn how to implement and test a network application which will utilise a Web net server in a real world application. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-tcpip-application-migration-guide",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-tcpip-application-migration-guide"
  },"513": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html"
  },"514": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony 2 to Harmony 3 TCP/IP Application Migration Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#web-links"
  },"515": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html#reference-links"
  },"516": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/tcpiip_harmoy2_to_harmony_3/readme.html"
  },"517": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "MPLAB Harmony 2 to Harmony 3 USB Application Migration Guide",
    "content": "This guide provides a step by step procedure to migrate USB applications from MPLAB® Harmony v2.xx to a v3.x.x framework. There are no API level differences between the MPLAB® Harmony v2.xx and v3.x.x USB Stacks. However, there may be API level changes in other components such as Clock, Timer, Ports etc. There are also differences in the MHC GUI. In order to migrate a USB application from MPLAB® Harmony v2.xx to v3.x.x, the user must recreate the application using MPLAB® Harmony v3.x.x MHC. In this guide an existing MPLAB® Harmony v2.xx USB Device CDC single com port demonstration is used to show the step by step procedure to migrate to the MPLAB® Harmony v3.x.x framework. This guide demonstrates how to use the MHC to configure various modules such as Clock, Ports, USB Device Layer, USB Controller Driver, and CDC Function driver etc. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-usb-application-migration-guide",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html#mplab-harmony-2-to-harmony-3-usb-application-migration-guide"
  },"518": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html"
  },"519": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Web Links",
    "content": ". | MPLAB Harmony 2 to Harmony 3 USB Application Migration Guide | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html#web-links",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html#web-links"
  },"520": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html#reference-links",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html#reference-links"
  },"521": {
    "doc": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "title": "TCP/IP Application Harmony2 to Harmony 3 Guide",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/migration/usb_harmoy2_to_harmony_3/readme.html",
    "relUrl": "/source/migration/usb_harmoy2_to_harmony_3/readme.html"
  },"522": {
    "doc": "Migration Guides",
    "title": "MPLAB Harmony Migration Guides Documentation",
    "content": "This page contains quick documentation to migrate to MPLAB® Harmony 3. ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#mplab-harmony-migration-guides-documentation",
    "relUrl": "/source/migration/readme.html#mplab-harmony-migration-guides-documentation"
  },"523": {
    "doc": "Migration Guides",
    "title": "Harmony 2 to Harmony 3",
    "content": ". | Differences between MPLAB Harmony 2 and Harmony 3 . | MPLAB Harmony 3 Application Development Guide for MPLAB Harmony 2 Users . | Graphics Applications . | TCP/IP Applications . | USB Applications . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#harmony-2-to-harmony-3",
    "relUrl": "/source/migration/readme.html#harmony-2-to-harmony-3"
  },"524": {
    "doc": "Migration Guides",
    "title": "Atmel Studio, ASF, START to Harmony 3",
    "content": ". | Introduction to MPLAB and Harmony 3 for Atmel Studio and ASF users . | Porting Application from ASF3 to MPLAB Harmony 3 Framework . | Atmel START to MPLAB Harmony 3 Migration Guide . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#atmel-studio-asf-start-to-harmony-3",
    "relUrl": "/source/migration/readme.html#atmel-studio-asf-start-to-harmony-3"
  },"525": {
    "doc": "Migration Guides",
    "title": "8 bit MPLAB Code Configurator (MCC) to 32 bit MPLAB Harmony Configurator (MHC)",
    "content": ". | Application migration from 8-bit PIC18F to 32-bit SAM D21 . | Application migration from 8-bit AVR to 32-bit SAM D21 . | Code generation and API considerations for migration from MCC . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#8-bit-mplab-code-configurator-mcc-to-32-bit-mplab-harmony-configurator-mhc",
    "relUrl": "/source/migration/readme.html#8-bit-mplab-code-configurator-mcc-to-32-bit-mplab-harmony-configurator-mhc"
  },"526": {
    "doc": "Migration Guides",
    "title": "Build MPLAB Harmony v3 project with ARM GCC",
    "content": ". | Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#build-mplab-harmony-v3-project-with-arm-gcc",
    "relUrl": "/source/migration/readme.html#build-mplab-harmony-v3-project-with-arm-gcc"
  },"527": {
    "doc": "Migration Guides",
    "title": "Migrating SAM C21 Application to PIC32CM MC Application",
    "content": ". | Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#migrating-sam-c21-application-to-pic32cm-mc-application",
    "relUrl": "/source/migration/readme.html#migrating-sam-c21-application-to-pic32cm-mc-application"
  },"528": {
    "doc": "Migration Guides",
    "title": "MPLAB Harmony v3 Project Migration",
    "content": ". | Migration of an existing MPLAB Harmony v3 based project developed on a particular hardware platform to another one of Microchip’s 32-bit hardware platforms of the user’s choice . | . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#mplab-harmony-v3-project-migration",
    "relUrl": "/source/migration/readme.html#mplab-harmony-v3-project-migration"
  },"529": {
    "doc": "Migration Guides",
    "title": "Migrating SAM9X60-EK Harmony Application to SAM9X60 Curiosity Development Board",
    "content": ". | Migrating SAM9X60-EK Harmony Application to SAM9X60 Curiosity Development Board . | . Note: . This page provides a quick reference covering the Migration to MPLAB Harmony 3. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#migrating-sam9x60-ek-harmony-application-to-sam9x60-curiosity-development-board",
    "relUrl": "/source/migration/readme.html#migrating-sam9x60-ek-harmony-application-to-sam9x60-curiosity-development-board"
  },"530": {
    "doc": "Migration Guides",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html#reference-links",
    "relUrl": "/source/migration/readme.html#reference-links"
  },"531": {
    "doc": "Migration Guides",
    "title": "Migration Guides",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/migration/readme.html",
    "relUrl": "/source/migration/readme.html"
  },"532": {
    "doc": "Arm TrustZone Getting Started Application on SAM L11 MCUs",
    "title": "Arm TrustZone Getting Started Application on SAM L11 MCUs",
    "content": "This tutorial shows you how to create an Arm® TrustZone® feature application on SAM L11 microcontroller (MCU) using MPLAB Harmony v3 software framework. The SAM L11 MCU is the implementation of the Arm TrustZone 45r for an ARMv8-M device. TrustZone for an ARMv8-M device is based on a specific hardware that is implemented in the Arm Cortex®-M23 core, which is combined with a dedicated Secure instructions set. It allows the creation of multiple software security domains that restricts access to selected memory, peripherals, and I/O to trusted software without compromising the system performances. The TrustZone technology enables secure and non-secure code to run on a single MCU. For the detailed explanation of security features available on the Microchip SAM L11 MCU, go through the SAM L11 Security Reference Guide. MPLAB® Harmony v3 is a flexible, fully integrated embedded software development framework for 32-bit microcontrollers (MCUs) and microprocessors (MPUs). MPLAB Harmony v3 includes the MPLAB Harmony Configurator (MHC) tool, a set of modular Peripheral Libraries (PLIBs), drivers, system services, middleware, and numerous example applications, all of which are designed to help you quickly and easily develop powerful and efficient embedded software for Microchip’s 32-bit PIC® and SAM devices. Also, the MPLAB Harmony v3 provides a TrustZone enviroment to develop security applications on different secured MCUs and MPUs like SAM L11, SAM A5D2 and SAM A5D4. The application makes use of the SAM L11 Xplained Pro Evaluation Kit and the I/O1 Xplained Pro Extension Kit (sold separately). The application has two projects pertaining to Secure and Non-secure modes of SAM L11, that work together on the same MCU and offers security isolation between the trusted and the non-trusted resources of the device. The Secure mode application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit every 500 milliseconds. Additionally, the secure application writes the temperature readings to EEPROM and reads when a request received from the Non-secure mode application. Also, an LED (LED0) is toggled every time the temperature is displayed on the serial console. The periodicity of the temperature values reading can be changed to 1 second, 2 seconds, 4 seconds, and back to 500 milliseconds every time the user presses the switch SW0 on the SAM L11 Xplained Pro Evaluation Kit. The temperature readings are transferred to Non-secure mode application when it requests to secure application through Non Secure Callables (NSC). The Non-secure mode application requests the Secure mode application to get the current temperature values and the Non-secure mode application print them on a serial console. Further, when it receives a request from the user (in the form of a key press on the serial console), it requests Secure mode application to retrieve the last five stored temperature values in the EEPROM. The Non-secure application prints the last five stored temperature values on the console. The application you create will utilize the following peripherals: . | Secure PORT Pin to toggle the LED (By default, all PORT pins are secure) | Secure SERCOM (configured as I²C) PLIB to read the temperature from a temperature sensor | Secure Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data | Secure External Interrupt Controller (EIC) PLIB to change the periodicity of temperature sensor data read using switch SW0 press event | Non-secure SERCOM (configured as Universal Synchronous Asynchronous Receiver Transmitter (USART)) and Non-secure Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC | Non-secure PORT Pins (USART Pins only) to communicate with the serial terminal | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/arm_trustzone_saml11_getting_started/readme.html#arm-trustzone-getting-started-application-on-sam-l11-mcus",
    "relUrl": "/source/peripheral/arm_trustzone_saml11_getting_started/readme.html#arm-trustzone-getting-started-application-on-sam-l11-mcus"
  },"533": {
    "doc": "Arm TrustZone Getting Started Application on SAM L11 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/arm_trustzone_saml11_getting_started/readme.html",
    "relUrl": "/source/peripheral/arm_trustzone_saml11_getting_started/readme.html"
  },"534": {
    "doc": "Arm TrustZone Getting Started Application on SAM L11 MCUs",
    "title": "Web Links",
    "content": ". | Arm TrustZone Getting Started Application on SAM L11 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/arm_trustzone_saml11_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/arm_trustzone_saml11_getting_started/readme.html#web-links"
  },"535": {
    "doc": "Arm TrustZone Getting Started Application on SAM L11 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/arm_trustzone_saml11_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/arm_trustzone_saml11_getting_started/readme.html#reference-links"
  },"536": {
    "doc": "Arm TrustZone Getting Started Application on SAM L11 MCUs",
    "title": "Arm TrustZone Getting Started Application on SAM L11 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/arm_trustzone_saml11_getting_started/readme.html",
    "relUrl": "/source/peripheral/arm_trustzone_saml11_getting_started/readme.html"
  },"537": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on PIC32MK GP MCUs",
    "content": "This tutorial shows you how to use the MHC to create an application that will help you get started in developing applications on PIC32MK GP MCUs using MPLAB Harmony v3 Software Framework. The application makes use of a PIC32MK General Purpose (GP) Development board and a MikroElectronika Weather click board (sold separately). The application reads the current room temperature from the temperature sensor on the MikroElectronika Weather click board. The temperature reading is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch S1 on the PIC32MK GP Development Board. Also, an LED (LED1) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | The Serial Peripheral Interface (SPI) Peripheral Library (PLIB) to read the temperature from a temperature sensor. | The TMR2 PLIB to periodically sample temperature sensor data. | The CORE TIMER PLIB to use a blocking timer delay for initializing the temperature sensor. | The Universal Asynchronous Receiver Transmitter (UART) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC. | The General Purpose Input/Output (GPIO) PLIB to change the periodicity of temperature sensor data readings using the SWITCH press event and to toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mk-gp-mcus",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mk-gp-mcus"
  },"538": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html"
  },"539": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on PIC32MK GP MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html#web-links"
  },"540": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html#reference-links"
  },"541": {
    "doc": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "title": "Getting Started with PLIBs on PIC32MK GP MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mk_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mk_getting_started/readme.html"
  },"542": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Getting Started With Harmony v3 Peripheral Libraries on PIC32MX 470 MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on PIC32MX470 MCUs using MPLAB Harmony v3 software framework. The application makes use of PIC32MX470 Curiosity Development Board , MikroElectronika Weather click board, and MikroElectronika USB UART click board (sold separately). The application reads the current room temperature from the temperature sensor on the MikroElectronika Weather click board. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch S1 on the PIC32MX470 Curiosity Development Board. Also, LED1 is toggled every time the temperature is displayed on the serial console. The application you create utilizes: . | I²C Peripheral Library (PLIB) to read the temperature from a temperature sensor. | TMR2 PLIB to periodically sample temperature sensor data. | CORETIMER PLIB to use blocking timer delay for initializing temperature sensor. | UART and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC. | GPIO Peripheral Library to change the periodicity of temperature sensor data read using SWITCH press event and toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mx-470-mcus",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mx-470-mcus"
  },"543": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html"
  },"544": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started With Harmony v3 Peripheral Libraries on PIC32MX 470 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html#web-links"
  },"545": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html#reference-links"
  },"546": {
    "doc": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "title": "Getting Started with PLIBs on PIC32MX 470 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mx_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mx_getting_started/readme.html"
  },"547": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on PIC32MZ EF MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on PIC32MZ EF MCUs using MPLAB Harmony v3 software framework. The application makes use of Curiosity PIC32MZ EF 2.0 Development Board and I/O1 Xplained Pro Extension Kit. The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch SW1 on the Curiosity PIC32MZ EF 2.0 Development Board. Also, LED1 is toggled every time the temperature is displayed on the serial console. The application you create utilizes: . | I²C Peripheral Library (PLIB) to read the temperature from a temperature sensor. | TMR1 PLIB to periodically sample temperature sensor data. | Universal Asynchronous Receiver Transmitter (UART) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC. | GPIO PLIB to change the periodicity of temperature sensor data read using the SWITCH press event and toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mz-ef-mcus",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-pic32mz-ef-mcus"
  },"548": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html"
  },"549": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on PIC32MZ EF MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html#web-links"
  },"550": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html#reference-links"
  },"551": {
    "doc": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "title": "Getting Started with PLIBs on PIC32MZ EF MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/pic32mz_getting_started/readme.html",
    "relUrl": "/source/peripheral/pic32mz_getting_started/readme.html"
  },"552": {
    "doc": "Getting Started with PLIBs on SAM9X60 MPUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM9X60 MPUs",
    "content": "In this tutorial, you will download, configure, and build an MPLAB® Harmony 3 Software Framework application to run on the SAM9X60-EK Evaluation Kit using the MPLAB X Integrated Development Environment (IDE) in Debug mode. Once the application has been fully developed, the application is cleaned and built for production. The resulting binary image (harmony.bin) is written to Non-Volatile Memory (NVM), such as SD memory card, eMMC, NAND, or NOR Flash memories. The harmony.bin binary image is read from NVM by the second-stage bootloader, at91bootstrap, which is also written to NVM. However, at91boostrap must be configured and built for a given NVM. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/sam9x60_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam9x60-mpus",
    "relUrl": "/source/peripheral/sam9x60_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam9x60-mpus"
  },"553": {
    "doc": "Getting Started with PLIBs on SAM9X60 MPUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/sam9x60_getting_started/readme.html",
    "relUrl": "/source/peripheral/sam9x60_getting_started/readme.html"
  },"554": {
    "doc": "Getting Started with PLIBs on SAM9X60 MPUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM9X60 MPUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/sam9x60_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/sam9x60_getting_started/readme.html#web-links"
  },"555": {
    "doc": "Getting Started with PLIBs on SAM9X60 MPUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/sam9x60_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/sam9x60_getting_started/readme.html#reference-links"
  },"556": {
    "doc": "Getting Started with PLIBs on SAM9X60 MPUs",
    "title": "Getting Started with PLIBs on SAM9X60 MPUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/sam9x60_getting_started/readme.html",
    "relUrl": "/source/peripheral/sam9x60_getting_started/readme.html"
  },"557": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAMC2x MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on SAM C21x MCUs using MPLAB Harmony v3 software framework. The application makes use of SAMC21N Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds and back to 500 milliseconds every time you press the switch SW0 on the SAMC21N Xplained Pro Evaluation Kit. Also, an LED LED0 is toggled every time temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I2C) Peripheral Library (PLIB) to read the temperature from a temperature sensor. | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data. | SERCOM (as USART), Direct Memory Access (DMA) PLIB to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS PLIB to toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-samc2x-mcus",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-samc2x-mcus"
  },"558": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html"
  },"559": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAMC2x MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html#web-links"
  },"560": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html#reference-links"
  },"561": {
    "doc": "Getting Started with PLIBs on SAMC2x MCUs",
    "title": "Getting Started with PLIBs on SAMC2x MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samc2x_getting_started/readme.html"
  },"562": {
    "doc": "Getting Started with Drivers on SAM C2x MCUs Using FreeRTOS",
    "title": "Getting Started with Harmony v3 Drivers on SAM C2x MCUs Using FreeRTOS",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM C21 MCUs using MPLAB Harmony v3 software framework with FreeRTOS™. Harmony v3 drivers support Asynchronous and Synchronous modes of operation. | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs) | Works seamlessly in bare-metal and RTOS environment | Interrupt and thread-safe | . | Synchronous Mode . | Blocking APIs | Suitable for use in RTOS environment | Interrupt and thread-safe | . | . In this tutorial, you will use Harmony drivers in the Synchronous mode of operation. The application makes use of the SAM C21 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM. When a character is entered on the console, the last five written temperature values are read from the EEPROM and displayed on the console. Also, an LED (LED0) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | I²C Synchronous Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | Universal Synchronous Asynchronous Receiver Transmitter (USART) Synchronous Driver to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS Peripheral Library to toggle an LED. | FreeRTOS library to create application threads and intercommunicate between application threads. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-c2x-mcus-using-freertos",
    "relUrl": "/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-c2x-mcus-using-freertos"
  },"563": {
    "doc": "Getting Started with Drivers on SAM C2x MCUs Using FreeRTOS",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html"
  },"564": {
    "doc": "Getting Started with Drivers on SAM C2x MCUs Using FreeRTOS",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers on SAM C21 MCUs Using FreeRTOS | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html#web-links",
    "relUrl": "/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html#web-links"
  },"565": {
    "doc": "Getting Started with Drivers on SAM C2x MCUs Using FreeRTOS",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html#reference-links",
    "relUrl": "/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html#reference-links"
  },"566": {
    "doc": "Getting Started with Drivers on SAM C2x MCUs Using FreeRTOS",
    "title": "Getting Started with Drivers on SAM C2x MCUs Using FreeRTOS",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/samc2x_getting_started_drivers_freertos/readme.html"
  },"567": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Low Power Application on SAMC2x (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "SAMC2x is part of Microchip’s 32-bit Arm® Cortex® M0+ microcontroller (MCU) family that can be used to meet the needs of power-constrained applications. SAMC2x MCUs provide various sleep modes to meet the power consumption requirements of the application. The Power Manager (PM) module is responsible for controlling the low power modes. SAMC2x supports two low power modes; IDLE and STANDBY. Idle sleep mode: In Idle mode, CPU and Synchronous clocks are stopped except when requested. Idle mode allows power optimization with fast wakeup time. Standby sleep mode: In standby mode, the CPU is stopped as well as the peripherals, except those that are running using the RUN IN STANDBY option. Standby mode allows the device to consume the lowest power with little overhead on wakeup time. The application makes use of the SAM C21 Xplained Pro evaluation kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the application is in sleep (standby) mode. The application wakes up from the sleep mode and enters active mode when you cover the light sensor (by placing a hand over it) on the I/O1 Xplained Pro extension kit. The application periodically prints room temperature on a serial terminal while the light sensor is covered. The application goes back to sleep (standby) mode when you uncover the light sensor. LED0 in the SAM C21 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch SW0, the application switches sleep mode from standby mode to idle mode. The application you create will utilize: . | SERCOM (as I²C) Peripheral Library to read the temperature from the temperature sensor. | RTC Peripheral Library to periodically generate an event for the ADC to sample the light sensor. | SERCOM (as USART) and DMA Peripheral Libraries to print the temperature values on a COM (serial) port terminal application running on a PC. | PORT Peripheral Library to toggle the LED. | ADC Peripheral Library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM (Power Manager) and Supply Controller (SUPC) Peripheral Libraries to configure low power modes. | EIC (External Interrupt controller) Peripheral Library to control switch SW0. Event System Peripheral Library to trigger the start of the ADC conversion on every RTC compare match event. The event system allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html#low-power-application-on-samc2x-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html#low-power-application-on-samc2x-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"568": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html"
  },"569": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Web Links",
    "content": ". | Low Power Application on SAMC2x (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html#web-links"
  },"570": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html#reference-links"
  },"571": {
    "doc": "Low Power with PLIBs on SAMC2x MCUs",
    "title": "Low Power with PLIBs on SAMC2x MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samc2x_low_power/readme.html",
    "relUrl": "/source/peripheral/samc2x_low_power/readme.html"
  },"572": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM D21 MCUs",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM D21 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM D21 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds and back to 500 milliseconds every time you press the switch SW0 on the SAM D21 Xplained Pro Evaluation Kit. Also, an LED0 is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I²C) PLIB to read the temperature from a temperature sensor | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC | PORT PLIB to toggle the LED | External Interrupt Controller (EIC) PLIB to change the periodicity of temperature sensor data read using SWITCH press event | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d21-mcus",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d21-mcus"
  },"573": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html"
  },"574": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM D21 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html#web-links"
  },"575": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html#reference-links"
  },"576": {
    "doc": "Getting Started with PLIBs on SAM D21 MCUs",
    "title": "Getting Started with PLIBs on SAM D21 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd21_getting_started/readme.html"
  },"577": {
    "doc": "Getting Started with Drivers on SAM D21 MCUs Using FreeRTOS",
    "title": "Getting Started with Harmony v3 Drivers on SAM D21 MCUs Using FreeRTOS",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM D21 MCUs using MPLAB Harmony v3 software framework with FreeRTOS. Harmony v3 drivers support Asynchronous and Synchronous modes of operation. | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs) | Works seamlessly in bare-metal and RTOS environment | Interrupt and thread-safe | . | Synchronous Mode . | Blocking APIs | Suitable for use in RTOS environment | Interrupt and thread-safe | . | . In this tutorial, you will use Harmony drivers in Synchronous mode of operation. The application makes use of the SAM D21 Xplained pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM. When a character is entered on the console, the last five written temperature values are read from the EEPROM and displayed on the console. Also, an LED (LED0) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | I²C Synchronous Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | Universal Synchronous Asynchronous Receiver Transmitter (USART) Synchronous Driver to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS Peripheral Library to toggle an LED. | FreeRTOS library to create application threads and intercommunicate between application threads. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-d21-mcus-using-freertos",
    "relUrl": "/source/peripheral/samd21_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-d21-mcus-using-freertos"
  },"578": {
    "doc": "Getting Started with Drivers on SAM D21 MCUs Using FreeRTOS",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/samd21_getting_started_drivers_freertos/readme.html"
  },"579": {
    "doc": "Getting Started with Drivers on SAM D21 MCUs Using FreeRTOS",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers on SAM D21 MCUs Using FreeRTOS | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started_drivers_freertos/readme.html#web-links",
    "relUrl": "/source/peripheral/samd21_getting_started_drivers_freertos/readme.html#web-links"
  },"580": {
    "doc": "Getting Started with Drivers on SAM D21 MCUs Using FreeRTOS",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started_drivers_freertos/readme.html#reference-links",
    "relUrl": "/source/peripheral/samd21_getting_started_drivers_freertos/readme.html#reference-links"
  },"581": {
    "doc": "Getting Started with Drivers on SAM D21 MCUs Using FreeRTOS",
    "title": "Getting Started with Drivers on SAM D21 MCUs Using FreeRTOS",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/samd21_getting_started_drivers_freertos/readme.html"
  },"582": {
    "doc": "Low Power with PLIBs on SAMD21 MCUs",
    "title": "Low Power Application on SAM D21 (Arm® Cortex® M0+) MCUs Using MPLAB® Harmony v3 Peripheral Libraries",
    "content": "The SAM D21 is a 32-bit Arm® Cortex® - M0+ based microcontroller that provides features to reduce power consumption through different Sleep modes, such as Idle and Standby. | In Idle mode, the CPU is stopped and optionally, some synchronous clock domains are stopped, depending on the IDLE argument. The regulator operates in Normal mode. This mode allows power optimization with a fast wake-up time. | In Standby mode, all clock sources are stopped, except those which are kept running if requested by a running module or have the ONDEMAND bit set to zero. The regulator operates in Low Power mode. Before entering Standby mode the user must make sure that a significant amount of clocks and peripherals are disabled so that the voltage regulator is not overloaded. This mode allows the device to consume the lowest power with little overhead on wake-up time. | . The Power Manager (PM) module is responsible for controlling the Low Power modes. Additionally, the SAM D21 provides SleepWalking. SleepWalking is the capability for a device to temporarily wake up clocks for the peripheral to perform a task without waking up the CPU in STANDBY sleep mode. The application makes use of the SAM D21 Xplained Pro evaluation kit, Power Debugger and the I/O1 Xplained Pro Extension Kit (sold separately). The application is developed on the MPLAB Harmony v3 software framework. MPLAB Harmony v3 is a modular framework that provides interoperable firmware libraries for application development on 32-bit MCUs and MPUs. It includes an easy-to-use Graphical User Interface (GUI) (MPLAB Harmony Configurator (MHC)) for selecting, configuring, and generating starter codes, peripheral libraries, and middleware (USB, TCP/IP, Graphics and so on). On power-up, the application prints a menu on a PC serial terminal. The menu provides options to measure the device power consumption in Sleep modes or to measure wake-up time when the device is wake-up from one of the Sleep modes. Once the option is selected, the application sets up EIC peripheral clock source and goes to Standby Sleep mode to enable measurement modes. In this training module, . | The power consumption of the SAM D21 Xplained Pro board is measured using two tools . | External Power Debugger - A hardware tool | Data Visualizer - A software tool The steps to connect and measure the power consumption using these tools are provided in the following sections. | . | Device wake-up time is measured using the Logic Analyzer. The steps to connect and measure the wake-up time are provided in the following sections. | . Power Measurement Mode: By default, the application is running with the device in Standby Sleep mode. While the device is in Standby Sleep mode, the user can measure the device’s power consumption by following the instructions provided in the following sections. The device wakes up from Standby mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro Extension kit. Here, you can observe the transition of the device’s power consumption from Standby Sleep mode to Active mode on the Data Visualizer tool. The application prints the room temperature on a serial terminal, and the device goes back to Standby Sleep mode. The LED0 on the SAM D21 Xplained Pro Evaluation Kit is toggled every time the serial console displays the temperature. When you press the switch button SW0, the application switches from Standby Sleep mode to Idle Sleep mode. Here, you can observe the transition of the device’s power consumption from Standby Sleep mode to Active mode and from Active mode to Idle Sleep mode. At this point, you can measure the device’s power consumption in Idle Sleep mode by following the instructions provided in the following sections. The device wakes up from Idle mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro extension kit. Here, you can observe the transition of the device’s power consumption from Idle Sleep mode to Active mode on the Data Visualizer tool. The application prints the room temperature on a serial terminal, and the device goes back to Standby Sleep mode. The LED0 on the SAM D21 Xplained Pro Evaluation Kit is toggled every time the serial console displays the temperature. Wake-up Time Measurement Mode: By default, the application is running with the device in Standby Sleep mode, and the device wakes up from Standby Sleep mode when you press a switch on the development board. The application toggles the Wake-up GPIO pin on the device wake-up and then goes to the Idle Sleep mode. You can measure the wake-up time by monitoring the switch SW0 pin and Wake-up GPIO pin on the Logic Analyzer tool. In the next switch press, you can measure the wake-up time from Idle Sleep mode by monitoring the same switch SW0 pin and Wake-up GPIO pin on the Logic Analyzer tool. The application switches the device Sleep mode between Standby Sleep mode and Idle Sleep mode whenever you press the SW0 switch. Therefore, you can measure the wake-up time from these Sleep modes by monitoring the switch SW0 on the Logic Analyzer tool. Also, the device wakes up from Standby mode or Idle mode when you cover the light sensor by placing your hand over it, prints the wake-up reason message, and goes back to Sleep mode. The application you create will utilize the following peripherals: . | SERCOM2 (as I²C) peripheral library to read the temperature from the temperature sensor. | Real-Time Clock (RTC) peripheral library to periodically generate an event for the AC to sample the light sensor. | SERCOM3 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to print messages on a serial console running on a computer. | PORT peripheral library to toggle the LED0. | Analog Comparator (AC) peripheral library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM peripheral library to configure Low Power modes. | External Interrupt Controller (EIC) peripheral library to control the user button SW0. | EVSYS peripheral library to trigger the start of the AC conversion on every RTC compare match event. The EVSYS allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_low_power/readme.html#low-power-application-on-sam-d21-arm-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/samd21_low_power/readme.html#low-power-application-on-sam-d21-arm-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"583": {
    "doc": "Low Power with PLIBs on SAMD21 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_low_power/readme.html",
    "relUrl": "/source/peripheral/samd21_low_power/readme.html"
  },"584": {
    "doc": "Low Power with PLIBs on SAMD21 MCUs",
    "title": "Web Links",
    "content": ". | Low Power Application on SAM D21 (Arm® Cortex® M0+) MCUs Using MPLAB® Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/samd21_low_power/readme.html#web-links"
  },"585": {
    "doc": "Low Power with PLIBs on SAMD21 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/samd21_low_power/readme.html#reference-links"
  },"586": {
    "doc": "Low Power with PLIBs on SAMD21 MCUs",
    "title": "Low Power with PLIBs on SAMD21 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd21_low_power/readme.html",
    "relUrl": "/source/peripheral/samd21_low_power/readme.html"
  },"587": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs",
    "content": "This tutorial shows you how to use the MPLAB Harmony Configurator (MHC) to create an application that gets you started in developing applications on SAM D5x/E5x MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM E54 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds and back to 500 milliseconds every time you press the switch SW0 on the SAM E54 Xplained Pro Evaluation Kit. Also, LED0 is toggled every time temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I²C) Peripheral Library (PLIB) to read the temperature from a temperature sensor. | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data. | SERCOM (as USART), Direct Memory Access (DMA) PLIBS to print the temperature values on a COM (serial) port terminal application running on a PC. PORTS PLIB to toggle the LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d5xe5x-mcus",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-d5xe5x-mcus"
  },"588": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html"
  },"589": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html#web-links"
  },"590": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html#reference-links"
  },"591": {
    "doc": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "title": "Getting Started with PLIBs on SAM D5x/E5x MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/samd5x_getting_started/readme.html",
    "relUrl": "/source/peripheral/samd5x_getting_started/readme.html"
  },"592": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Low Power Application on SAM E54 (Cortex M4) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "This tutorial shows you how to create a low power application on a SAM E54 using MPLAB® Harmony v3 software framework. The SAM E54 is a 32-bit Arm® Cortex®-M4 based microcontroller that provides features to reduce power consumption through different Sleep modes, such as Idle, Standby, Backup, Hibernate and Off. | In Idle mode, the CPU and the synchronous clocks are stopped, except when requested. This mode allows power optimization with a fast wake-up time. | In Standby mode, the CPU and the peripherals are stopped, except those that are running using the Run in Standby mode feature. This mode allows the device to consume the lowest power with little overhead on wake-up time. | In Backup mode, the device is entirely powered off, except for the peripherals in the backup domain. This mode allows you to achieve the lowest power consumption aside from Off mode but increases the wake-up time compared to Standby mode. | In Hibernate sleep mode, the device is entirely powered off, except for the peripherals in the Hibernate sleep mode. This mode allows you to achieve the lowest power consumption but little more than Backup mode and wake-up time is little faster than Backup mode. | In Off mode, the device is entirely powered off. This mode allows you to achieve the lowest power consumption. Since the device must be reset to recover from this mode, the wake-up time is longer. | . The Power Manager (PM) module is responsible for controlling the Low Power modes. Additionally, the SAM E54 provides SleepWalking, an advanced low power operation mode which is based on event propagation managed by the Event System (EVSYS). This application makes use of the SAM E54 Xplained Pro Evaluation Kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the device is set to Standby Sleep mode. The device wakes up from Standby mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro extension kit. The application periodically prints the room temperature on a serial terminal while the light sensor is covered. The device goes back to Standby mode when you uncover the light sensor. LED0 on the SAM E54 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch button SW0, the application switches Sleep mode from Standby mode to Idle mode. The application you create will utilize the following peripherals: . | SERCOM3 (as I²C) peripheral library to read the temperature from the temperature sensor. | Real-Time Clock (RTC) peripheral library to periodically generate an event for the ADC to sample the light sensor. | SERCOM2 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to print messages on a serial console running on a computer. | Direct Memory Access Controller (DMAC) peripheral library to send the converted temperature value to the SERCOM0. | PORT peripheral library to toggle the LED0. | Analog-to-Digital Converter (ADC1) peripheral library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM and Supply Controller (SUPC) peripheral libraries to configure Low Power modes. | External Interrupt Controller (EIC) peripheral library to control the user button SW0. | EVSYS peripheral library to trigger the start of the ADC conversion on every RTC compare match event. The EVSYS allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html#low-power-application-on-sam-e54-cortex-m4-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/same54_low_power/readme.html#low-power-application-on-sam-e54-cortex-m4-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"593": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html",
    "relUrl": "/source/peripheral/same54_low_power/readme.html"
  },"594": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Web Links",
    "content": ". | Low Power Application on SAM E54 (Cortex M4) MCU Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/same54_low_power/readme.html#web-links"
  },"595": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/same54_low_power/readme.html#reference-links"
  },"596": {
    "doc": "Low Power with PLIBs on SAM E54 MCU",
    "title": "Low Power with PLIBs on SAM E54 MCU",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same54_low_power/readme.html",
    "relUrl": "/source/peripheral/same54_low_power/readme.html"
  },"597": {
    "doc": "Getting Started with Drivers on SAM E5x MCUs Using FreeRTOS",
    "title": "Getting Started with Harmony v3 Drivers on SAM E5x MCUs Using FreeRTOS",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM E54 MCUs using MPLAB Harmony v3 software framework with FreeRTOS™. Harmony v3 drivers support Asynchronous and Synchronous modes of operation. | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs) | Works seamlessly in bare-metal and RTOS environment | Interrupt and thread-safe | . | Synchronous Mode . | Blocking APIs | Suitable for use in RTOS environment | Interrupt and thread-safe | . | . In this tutorial, you will use Harmony drivers in the Synchronous mode of operation. The application makes use of the SAM E54 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM. When a character is entered on the console, the last five written temperature values are read from the EEPROM and displayed on the console. Also, an LED (LED0) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | I²C Synchronous Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | Universal Synchronous Asynchronous Receiver Transmitter (USART) Synchronous Driver to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS Peripheral Library to toggle an LED. | FreeRTOS library to create application threads and intercommunicate between application threads. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same5x_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-e5x-mcus-using-freertos",
    "relUrl": "/source/peripheral/same5x_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-e5x-mcus-using-freertos"
  },"598": {
    "doc": "Getting Started with Drivers on SAM E5x MCUs Using FreeRTOS",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same5x_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/same5x_getting_started_drivers_freertos/readme.html"
  },"599": {
    "doc": "Getting Started with Drivers on SAM E5x MCUs Using FreeRTOS",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers on SAM E54 MCUs Using FreeRTOS | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same5x_getting_started_drivers_freertos/readme.html#web-links",
    "relUrl": "/source/peripheral/same5x_getting_started_drivers_freertos/readme.html#web-links"
  },"600": {
    "doc": "Getting Started with Drivers on SAM E5x MCUs Using FreeRTOS",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same5x_getting_started_drivers_freertos/readme.html#reference-links",
    "relUrl": "/source/peripheral/same5x_getting_started_drivers_freertos/readme.html#reference-links"
  },"601": {
    "doc": "Getting Started with Drivers on SAM E5x MCUs Using FreeRTOS",
    "title": "Getting Started with Drivers on SAM E5x MCUs Using FreeRTOS",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same5x_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/same5x_getting_started_drivers_freertos/readme.html"
  },"602": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM E70/S70/V70/V71 MCUs",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM E70/S70/V70/V71 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM E70 Xplained Ultra board and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to 1 second, 2 seconds, 4 seconds, and back to 500 milliseconds every time you press the switch SW0 on the SAM E70 Xplained Ultra Evaluation Kit. Also, an LED, LED3, is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | Two-Wire Interfaces (TWIHS) (I²C) Peripheral Library to read the temperature from a temperature sensor | Timer Counter (TC) Peripheral Library to periodically sample temperature sensor data | Universal Synchronous Asynchronous Receiver Transmitter (USART) and Direct Memory Access (DMA) Peripheral Libraries to print the temperature values on a COM (serial) port terminal application running on a PC | PORTS Peripheral Library to change the periodicity of temperature sensor data read using SWITCH event and toggle the LED | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-e70s70v70v71-mcus",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-e70s70v70v71-mcus"
  },"603": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html"
  },"604": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM E70/S70/V70/V71 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html#web-links"
  },"605": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html#reference-links"
  },"606": {
    "doc": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with PLIBs on SAM E70/S70/V70/V71 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started/readme.html"
  },"607": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with Harmony v3 Drivers and System Services on SAM E70/S70/V70/V71 MCUs",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM E70/S70/V70/V71 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM E70 Xplained Ultra board and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM. When a character is entered on the console, the last five written temperature values are read from the EEPROM and displayed on the console. Also, an LED (LED3) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | Two-Wire Interfaces (TWIHS) (I²C) Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | Timer System Service to periodically sample temperature sensor data. | Universal Synchronous Asynchronous Receiver Transmitter (USART) Driver (in Direct Memory Access (DMA) mode) to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS Peripheral Library to toggle an LED. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html#getting-started-with-harmony-v3-drivers-and-system-services-on-sam-e70s70v70v71-mcus",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html#getting-started-with-harmony-v3-drivers-and-system-services-on-sam-e70s70v70v71-mcus"
  },"608": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html"
  },"609": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers and System Services on SAM E70/S70/V70/V71 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html#web-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html#web-links"
  },"610": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html#reference-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html#reference-links"
  },"611": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "title": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers/readme.html"
  },"612": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Getting Started with Harmony v3 Drivers on SAM E70/S70/V70/V71 MCUs Using FreeRTOS",
    "content": "This tutorial shows you how to use MHC to create an application that gets you started in developing applications on SAM E70/S70/V70/V71 MCUs using MPLAB Harmony v3 software framework. Harmony v3 drivers support Asynchronous and Synchronous modes of operation. | Asynchronous Mode . | Non-blocking Application Program Interfaces (APIs) | Works seamlessly in bare-metal and RTOS environment | Interrupt and thread-safe | . | Synchronous Mode . | Blocking APIs | Suitable for use in RTOS environment | Interrupt and thread-safe | . | . In this tutorial, you will use Harmony drivers in Synchronous mode of operation. The application makes use of SAM E70 Xplained Ultra board and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension Kit. The temperature reading is displayed on a serial console periodically every second. Further, the application writes the temperature readings to EEPROM. When a character is entered on the console, the last five written temperature values are read from the EEPROM and displayed on the console. Also, an LED (LED3) is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | Two-Wire Interface High Speed (TWIHS) (I²C) Synchronous Driver to read the temperature from a temperature sensor and store/retrieve to/from EEPROM. | USART Synchronous Driver to print the temperature values on a COM (serial) port terminal application running on a PC. | PORTS Peripheral Library to toggle an LED. | FreeRTOS library to create application threads and intercommunicate between application threads. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-e70s70v70v71-mcus-using-freertos",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html#getting-started-with-harmony-v3-drivers-on-sam-e70s70v70v71-mcus-using-freertos"
  },"613": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html"
  },"614": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Drivers on SAM E70/S70/V70/V71 MCUs Using FreeRTOS | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html#web-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html#web-links"
  },"615": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html#reference-links",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html#reference-links"
  },"616": {
    "doc": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "title": "Getting Started with Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/same70_getting_started_drivers_freertos/readme.html",
    "relUrl": "/source/peripheral/same70_getting_started_drivers_freertos/readme.html"
  },"617": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Getting Started with Harmony v3 Peripheral Libraries on SAM L10 MCUs",
    "content": "This tutorial shows you how to use the MHC to create an application that gets you started in developing applications on SAM L10 MCUs using MPLAB Harmony v3 software framework. The application makes use of SAM L10 Xplained Pro Evaluation Kit and I/O1 Xplained Pro Extension Kit (sold separately). The application reads the current room temperature from the temperature sensor on the I/O1 Xplained Pro Extension. The temperature read is displayed on a serial console periodically every 500 milliseconds. The periodicity of the temperature values displayed on the serial console is changed to one second, two seconds, four seconds, and back to 500 milliseconds every time you press the switch SW0 on the SAM L10 Xplained Pro Evaluation Kit. Also, an LED0 is toggled every time the temperature is displayed on the serial console. The application you create will utilize: . | SERCOM (as I²C) PLIB to read the temperature from a temperature sensor | Real-Time Clock (RTC) PLIB to periodically sample temperature sensor data | SERCOM (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) and Direct Memory Access (DMA) PLIBs to print the temperature values on a COM (serial) port terminal application running on a PC | PORT PLIB to toggle the LED | External Interrupt Controller (EIC) PLIB to change the periodicity of temperature sensor data read using SWITCH press event | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-l10-mcus",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html#getting-started-with-harmony-v3-peripheral-libraries-on-sam-l10-mcus"
  },"618": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html"
  },"619": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Web Links",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAM L10 MCUs | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html#web-links",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html#web-links"
  },"620": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html#reference-links",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html#reference-links"
  },"621": {
    "doc": "Getting Started with PLIBs on SAM L10 MCUs",
    "title": "Getting Started with PLIBs on SAM L10 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_getting_started/readme.html",
    "relUrl": "/source/peripheral/saml10_getting_started/readme.html"
  },"622": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Low Power Application on SAM L10 (Cortex M23) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "This tutorial shows you how to create a low power application on a SAM L10 using MPLAB® Harmony v3 software framework. The SAM L10 is a 32-bit Arm® Cortex®-based M23 microcontroller that provides features to reduce power consumption through different Sleep modes, such as Idle, Standby, and Off. | In Idle mode, the CPU and the synchronous clocks are stopped, except when requested. This mode allows power optimization with a fast wake-up time. | In Standby mode, the CPU and the peripherals are stopped, except those that are running using the Run in Standby mode feature. This mode allows the device to consume the lowest power with little overhead on wake-up time. | In Off mode, the device is entirely powered off. This mode allows you to achieve the lowest power consumption. Since the device must be reset to recover from this mode, the wake-up time is longer. | . The Power Manager (PM) module is responsible for controlling the Low Power modes. Additionally, the SAM L10 provides SleepWalking, an advanced low power operation mode which is based on event propagation managed by the Event System (EVSYS). This application makes use of the SAM L10 Xplained Pro Evaluation Kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the device is set to Standby Sleep mode. The device wakes up from Standby mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro extension kit. The application periodically prints the room temperature on a serial terminal while the light sensor is covered. The device goes back to Standby mode when you uncover the light sensor. LED0 on the SAM L10 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch button SW0, the application switches Sleep mode from Standby mode to Idle mode. The application you create will utilize the following peripherals: . | SERCOM1 (as I²C) peripheral library to read the temperature from the temperature sensor. | Real-Time Clock (RTC) peripheral library to periodically generate an event for the ADC to sample the light sensor. | SERCOM0 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to print messages on a serial console running on a computer. | Direct Memory Access Controller (DMAC) peripheral library to send the converted temperature value to the SERCOM0. | PORT peripheral library to toggle the LED0. | Analog-to-Digital Converter (ADC) peripheral library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM and Supply Controller (SUPC) peripheral libraries to configure Low Power modes. | External Interrupt Controller (EIC) peripheral library to control the user button SW0. | EVSYS peripheral library to trigger the start of the ADC conversion on every RTC compare match event. The EVSYS allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html#low-power-application-on-sam-l10-cortex-m23-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html#low-power-application-on-sam-l10-cortex-m23-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"623": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html"
  },"624": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Web Links",
    "content": ". | Low Power Application on SAM L10 (Cortex M23) MCUs Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html#web-links"
  },"625": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html#reference-links"
  },"626": {
    "doc": "Low Power with PLIBs on SAM L10 MCUs",
    "title": "Low Power with PLIBs on SAM L10 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml10_low_power/readme.html",
    "relUrl": "/source/peripheral/saml10_low_power/readme.html"
  },"627": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Low Power Application on SAM L21 (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries",
    "content": "This tutorial shows you how to create a low power application on a SAM L21 using MPLAB® Harmony v3 software framework. The SAM L21 is a 32-bit Arm® Cortex® M0+ based microcontroller (MCU) that provides features to reduce power consumption through different Sleep modes such as Idle, Standby, Backup, and Off. | In Idle mode, the CPU and the synchronous clocks are stopped, except when requested. This mode allows power optimization with a fast wake-up time. | In Standby mode, the CPU and the peripherals are stopped, except those that are running using the Run in Standby mode feature. This mode allows the device to consume the lowest power with little overhead on wake-up time. | In Backup mode, the device is entirely powered off, except for the peripherals in the backup domain. This mode allows you to achieve the lowest power consumption aside from Off mode but increases the wake-up time compared to Standby mode. | In Off mode, the device is entirely powered off. It allows you to achieve the lowest power consumption. Since the device must be reset to recover from this mode, the wake-up time is the highest. | . The Power Manager (PM) module is responsible for controlling the Low Power modes. Additionally, the SAM L21 provides SleepWalking, an advanced low power operation mode, which is based on event propagation managed by the Event System (EVSYS). This application makes use of the SAM L21 Xplained Pro B evaluation kit and the I/O1 Xplained Pro Extension Kit (sold separately). On power-up, the device is set to Standby Sleep mode. The device wakes up from Standby mode and enters Active mode when you cover the light sensor (by placing a hand over it, for example) on the I/O1 Xplained Pro extension kit. The application periodically prints room temperature on a serial terminal while the light sensor is covered. The device goes back to Standby mode when you uncover the light sensor. LED0 in the SAM L21 evaluation kit is toggled every time the temperature is displayed on the serial console. When you press the switch button SW0, the application switches Sleep mode from Standby mode to Idle mode. The application you create will utilize the following peripherals: . | SERCOM2 (as I²C) peripheral library to read the temperature from the temperature sensor. | Real-Time Clock (RTC) peripheral library to periodically generate an event for the ADC to sample the light sensor. | SERCOM3 (as Universal Synchronous Asynchronous Receiver Transmitter (USART)) peripheral library to print messages on a serial console running on a computer. | Direct Memory Access Controller (DMAC) peripheral library to send the converted temperature value to the SERCOM3. | PORT peripheral library to toggle the LED0. | Analog-to-Digital Converter (ADC) peripheral library to sample the light sensor analog input and detect whether the light sensor is covered or not. | PM and Supply Controller (SUPC) peripheral libraries to configure Low Power modes. | External Interrupt Controller (EIC) peripheral library to control the user button SW0. | EVSYS peripheral library to trigger the start of the ADC conversion on every RTC compare match event. The EVSYS allows for peripheral-to-peripheral communication without CPU intervention. This reduces the burden on the CPU and other resources when compared to the conventional interrupt-based systems. | . For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html#low-power-application-on-sam-l21-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html#low-power-application-on-sam-l21-cortex-m0-mcus-using-mplab-harmony-v3-peripheral-libraries"
  },"628": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html"
  },"629": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Web Links",
    "content": ". | Low Power Application on SAM L21 (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html#web-links",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html#web-links"
  },"630": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html#reference-links",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html#reference-links"
  },"631": {
    "doc": "Low Power with PLIBs on SAM L21 MCUs",
    "title": "Low Power with PLIBs on SAM L21 MCUs",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/saml21_low_power/readme.html",
    "relUrl": "/source/peripheral/saml21_low_power/readme.html"
  },"632": {
    "doc": "Peripheral Libraries",
    "title": "MPLAB Harmony Peripheral Libraries Documentation",
    "content": "This page contains quick documentation for MPLAB® Harmony 3 Peripheral Libraries (PLIBs) and drivers usage. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#mplab-harmony-peripheral-libraries-documentation",
    "relUrl": "/source/peripheral/readme.html#mplab-harmony-peripheral-libraries-documentation"
  },"633": {
    "doc": "Peripheral Libraries",
    "title": "Peripheral Libraries (PLIBs)",
    "content": ". | Getting Started with Harmony v3 Peripheral Libraries on SAMC2x MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM E70/S70/V70/V71 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM L10 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on SAM D21 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on PIC32MZ EF MCUs . | Getting Started with Harmony v3 Peripheral Libraries on PIC32MX 470 MCUs . | Getting Started with Harmony v3 Peripheral Libraries on PIC32MK GP MCUs . | Low Power Application on SAMC2x (Cortex M0+) MCUs Using MPLAB Harmony v3 Peripheral Libraries . | Low Power Application on SAM L21 (Cortex M0+) MCUs using MPLAB Harmony v3 Peripheral Libraries . | Low Power Application on SAM L10 (Cortex M23) MCUs Using MPLAB Harmony v3 Peripheral Libraries . | Low Power Application on SAM E54 (Cortex M4) MCU Using MPLAB Harmony v3 Peripheral Libraries . | Arm TrustZone Getting Started Application on SAM L11 MCUs . | Low Power Application on SAM D21 (Cortex M0+) MCU Using MPLAB Harmony v3 Peripheral Libraries . | Getting Started with Harmony v3 Peripheral Libraries on SAM9X60 MPUs . | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#peripheral-libraries-plibs",
    "relUrl": "/source/peripheral/readme.html#peripheral-libraries-plibs"
  },"634": {
    "doc": "Peripheral Libraries",
    "title": "Drivers",
    "content": ". | Getting Started with Harmony v3 Drivers and System Services on SAM E70/S70/V70/V71 MCUs . | Getting Started with Harmony v3 Drivers on SAM E70/S70/V70/V71 MCUs using FreeRTOS . | Getting Started with Harmony v3 Drivers on SAM D21 MCUs Using FreeRTOS . | Getting Started with Harmony v3 Drivers on SAM E5x MCUs Using FreeRTOS . | Getting Started with Harmony v3 Drivers on SAM C2x MCUs Using FreeRTOS . | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#drivers",
    "relUrl": "/source/peripheral/readme.html#drivers"
  },"635": {
    "doc": "Peripheral Libraries",
    "title": "Web Links",
    "content": ". | Clock System Configuration and Usage on SAM E5x (Cortex M4) Devices Clock System Configuration and Usage on SAM C2x (Cortex M0+) Devices | How to Build an Application by Adding a New PLIB, Driver, or Middleware to an Existing MPLAB Harmony v3 Project | Various Timers on SAM Devices | How to Use the TCM on A Cortex-M7 Based MCU with the XC32 Compiler | How to Create Non-Cacheable Memory Region on CortexM7 (SAM S70/ E70/ V70/ V71) MCUs Using MPLAB Harmony v3 | SleepWalking with Event System Using the SAM E54 | Execute-In-Place (XIP) with QSPI on Cortex-M7 MCUs Using MPLAB Harmony v3 | Using XDMAC with QSPI on Arm Cortex-M7 MCUs Using MPLAB Harmony v3 | How to Wake-up Fast From an External Event on Cortex M0+ Based MCUs | Using Sigma-Delta Analog-to-Digital Converter (SDADC) on a SAMC MCU with MPLAB Harmony v3 | Live Update Application on PIC32MZ MCUs Using MPLAB Harmony v3 | Live Update Application on SAM E54 MCU Using MPLAB Harmony v3 | Handling Cache Coherency Issues at Runtime Using Cache Maintenance Operations on Cortex-M7 MCUs Using MPLAB Harmony v3 | Multiplexed and Remappable Functionalities on I/O pins on PIC32M Devices Using MPLAB Harmony v3 | How to Move an Application into a Desired Flash Memory Location with the Help of Linker Script on SAM E54 | AES Cipher Modes Using MPLAB Harmony v3 for the SAM E54 | Dual Developer Application Development Use Case with TrustZone on SAM L11 Using MPLAB Harmony v3 | 32-bit Microcontroller Wafer-Level Chip-Scale Package (WLCSP) | Handling Cache Coherency Issues at Runtime Using Cache Maintenance Operations on PIC32MZ MCUs Using MPLAB Harmony v3 | . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#web-links",
    "relUrl": "/source/peripheral/readme.html#web-links"
  },"636": {
    "doc": "Peripheral Libraries",
    "title": "Videos",
    "content": ". Note: . This page provides a quick reference covering the MPLAB Harmony 3 Peripheral Libraries (PLIBs) and drivers usage. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Peripheral/Technology specific documentation are available in technology repositories like csp, core, usb, net, audio, gfx_apps, etc. ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#videos",
    "relUrl": "/source/peripheral/readme.html#videos"
  },"637": {
    "doc": "Peripheral Libraries",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html#reference-links",
    "relUrl": "/source/peripheral/readme.html#reference-links"
  },"638": {
    "doc": "Peripheral Libraries",
    "title": "Peripheral Libraries",
    "content": "                                                                                   . ",
    "url": "http://localhost:4000/quick_docs/source/peripheral/readme.html",
    "relUrl": "/source/peripheral/readme.html"
  },"639": {
    "doc": "Add a New Configuration to an Existing MPLAB Harmony v3 Project",
    "title": "Add a New Configuration to an Existing MPLAB Harmony v3 Project",
    "content": "MPLAB X IDE allows multiple build configurations for the same project. This feature is useful for the code that is compiled on many hardware platforms. However, when you create a new project, a default configuration is created. Historically, MPLAB Harmony v2 projects typically used the build configuration feature of MPLAB X IDE to share application code across different development boards or kits. However, MPLAB Harmony v3 example projects do not use the build configuration option of MPLAB X IDE to enable sharing of application code across hardware platforms. MPLAB Harmony v3 contains example projects for many applications supporting different configurations. However, a custom board will require its own configuration to run an existing example project. This guide describes porting an MPLAB Harmony v3 project to another configuration when using a different development board. For example, the UART echo blocking application example, available for the PIC32MZ EF in MPLAB Harmony package csp_apps_pic32mz_ef, is available for the PIC32MZ Embedded Connectivity with FPU (EF) Starter Kit board. This document also describes how to use the source code files of the existing project on the Curiosity PIC32MZ EF 2.0 Development Board. For more information refer the links below. ",
    "url": "http://localhost:4000/quick_docs/source/basic/add_new_configuration_to_harmony_3_project/readme.html#add-a-new-configuration-to-an-existing-mplab-harmony-v3-project",
    "relUrl": "/source/basic/add_new_configuration_to_harmony_3_project/readme.html#add-a-new-configuration-to-an-existing-mplab-harmony-v3-project"
  },"640": {
    "doc": "Add a New Configuration to an Existing MPLAB Harmony v3 Project",
    "title": " ",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/source/basic/add_new_configuration_to_harmony_3_project/readme.html",
    "relUrl": "/source/basic/add_new_configuration_to_harmony_3_project/readme.html"
  },"641": {
    "doc": "Add a New Configuration to an Existing MPLAB Harmony v3 Project",
    "title": "Web Links",
    "content": ". | How to Add a New Configuration to an Existing MPLAB Harmony v3 Project | . ",
    "url": "http://localhost:4000/quick_docs/source/basic/add_new_configuration_to_harmony_3_project/readme.html#web-links",
    "relUrl": "/source/basic/add_new_configuration_to_harmony_3_project/readme.html#web-links"
  },"642": {
    "doc": "Add a New Configuration to an Existing MPLAB Harmony v3 Project",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/source/basic/add_new_configuration_to_harmony_3_project/readme.html#reference-links",
    "relUrl": "/source/basic/add_new_configuration_to_harmony_3_project/readme.html#reference-links"
  },"643": {
    "doc": "Add a New Configuration to an Existing MPLAB Harmony v3 Project",
    "title": "Add a New Configuration to an Existing MPLAB Harmony v3 Project",
    "content": "                                                                                                      . ",
    "url": "http://localhost:4000/quick_docs/source/basic/add_new_configuration_to_harmony_3_project/readme.html",
    "relUrl": "/source/basic/add_new_configuration_to_harmony_3_project/readme.html"
  },"644": {
    "doc": "Release notes",
    "title": "Microchip MPLAB® Harmony 3 Release Notes",
    "content": ". ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#microchip-mplab-harmony-3-release-notes",
    "relUrl": "/release_notes.html#microchip-mplab-harmony-3-release-notes"
  },"645": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.6.0 (June 2023)",
    "content": "New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content |   | . | Develop a harmony based application for SAM9X60 MPU using MPLAB® X IDE | Basic - Full | Updated new project steps | . | Configure first stage bootloader for SAM9X60 MPU | Basic - Full | Updated new project steps | . | Configure/built and debug second stage bootloader(at91bootstrap) for SAM9X60 MPU | Basic - Full | Updated new project steps | . | Flash the at91bootstrap and harmony application binaries using SAM-BA tool | Basic - Full | Updated new project steps | . | Configure at91bootstrap to enable QSPI-XIP on MPUs | Basic - Full | Updated new project steps | . | Develop a harmony based application executed from QSPI for SAM9X60 MPU using MPLAB® X IDE | Basic - Full | Updated new project steps | . | Configure first stage bootloader for SAMA7G5 MPU | Basic - Full | Updated new project steps | . | Configure/built and debug second stage bootloader(at91bootstrap) for SAMA7G5 MPU | Basic - Full | Updated new project steps | . | SAM-BA installation and initialization for SAMA7G5 MPU | Basic - Full | Updated new project steps | . | Flash the at91bootstrap and harmony application binaries of SAMA7G5 MPU using SAM-BA tool | Basic - Full | Updated new project steps | . | Migrating SAM9X60-EK Harmony Application to SAM9X60 Curiosity Development Board | Migration - Brief Overview and Web link |   | . | Getting Started with Harmony v3 Peripheral Libraries on SAM9X60 MPUs | Peripheral - Brief Overview and Web link |   | . | Doc Name | Doc Type - Content | Comments | . | Getting started with SAM MPUs using MPLAB® Harmony 3 | Full | Deleted this document | . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v160-june-2023",
    "relUrl": "/release_notes.html#quick-docs-release-v160-june-2023"
  },"646": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.5.0 (June 2022)",
    "content": "New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | MPLAB Harmony v3 Project Migration | Migration - Brief Overview and Web link | . | Digit Recognition AI/ML Application on SAM E51 IGAT CURIOSITY EVALUATION KIT Using MPLAB Harmony v3 | Middleware - Brief Overview and Web link | . | MPLAB Code Configurator (MCC) for Harmony 3 Projects | Basic - Brief Overview and Web link | . Updated Doc Pages . | Doc Name | Doc Type - Content | Comments | . | Getting started with SAM MPUs using MPLAB® Harmony 3 | Basic - Full | Updated reference to bootstrap and new project steps | . | New Weblink added in Peripheral page | New Weblink added in Middleware page | New video Weblinks added in Basic page | New video Weblinks added in Middleware page | . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v150-june-2022",
    "relUrl": "/release_notes.html#quick-docs-release-v150-june-2022"
  },"647": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.4.0 (December 2021)",
    "content": "New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | Create a new MPLAB Harmony v3 project using MCC | Basic - Brief Overview and Web link | . | Update and Configure an Existing MHC-based MPLAB Harmony v3 Project to MCC-based Project | Basic - Brief Overview and Web link | . | Low Power Application on SAM D21 (Cortex M0+) MCU Using MPLAB Harmony v3 Peripheral Libraries | Peripheral - Brief Overview and Web link | . | Rapid prototyping with Curiosity Nano Evaluation Kit using MPLAB Harmony v3 | Middleware - Brief Overview and Web link | . | Add a New Configuration to an Existing MPLAB Harmony v3 Project | Basic - Brief Overview and Web link | . | MPLAB Harmony v3 Project Manifest Feature | Basic - Brief Overview and Web link | . | New Weblink added in Peripheral page | New Weblink added in Middleware page | New video Weblinks added in Basic page | New video Weblinks added in Middleware page | Basic pages are added with a note on MCC support | . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v140-december-2021",
    "relUrl": "/release_notes.html#quick-docs-release-v140-december-2021"
  },"648": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.3.0 (June 2021)",
    "content": "New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | Getting Started with Harmony v3 Drivers on SAM E5x MCUs Using FreeRTOS | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Drivers on SAM C2x MCUs Using FreeRTOS | Peripheral - Brief Overview and Web link | . | New video Weblinks added in Basic page | . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v130-june-2021",
    "relUrl": "/release_notes.html#quick-docs-release-v130-june-2021"
  },"649": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.2.0 (January 2021)",
    "content": "New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | Difference Between MPLAB Harmony v3 PLIBs and Drivers | Basic - Brief Overview and Web link | . | MPLAB Harmony v3 Synchronous drivers and their usage in FreeRTOS based applications | Basic - Brief Overview and Web link | . | Arm TrustZone Getting Started Application on SAM L11 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Drivers on SAM D21 MCUs Using FreeRTOS | Peripheral - Brief Overview and Web link | . | Code generation and API considerations for migration from MCC | Migration - Brief Overview and Web link | . | Migrating ASF SAM C21 Application to MPLAB Harmony v3 PIC32CM MC | Migration - Brief Overview and Web link | . | Getting Started with USB on SAM MCUs Using MPLAB® Harmony v3 | Middleware - Brief Overview and Web link | . Updated Doc Pages . | Doc Name | Doc Type - Content | Comments | . | Application migration from 8-bit AVR to 32-bit SAM D21 MCU | Migration - Full | Updated image source with corrected extension for missing images | . | Application migration from 8-bit PIC18F to 32-bit SAM D21 MCU | Migration - Full | Updated image source with corrected extension for missing images | . | New video Weblinks added in Basic page | New video Weblinks added in Peripheral page | . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v120-january-2021",
    "relUrl": "/release_notes.html#quick-docs-release-v120-january-2021"
  },"650": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.1.0 (September 2020)",
    "content": ". | Repo restructured to move offline documentation to “docs” folder | . New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | Application migration from 8-bit PIC18F to 32-bit SAM D21 | Migration - Full | . | Application migration from 8-bit AVR to 32-bit SAM D21 | Migration - Full | . | Build MPLAB Harmony v3 project with ARM GCC toolchain in MPLAB X IDE | Migration - Full | . | Differences Between MPLAB Harmony v3 Synchronous and Asynchronous Drivers | Basic - Brief Overview and Web link | . | Low Power Application on SAM L10 MCUs using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Low Power Application on SAM E54 MCU using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Create your first Motor Control Application using MPLAB Harmony v3 | Middleware - Brief Overview and Web link | . Updated Doc Pages . | Doc Name | Doc Type - Content | Comments | . | Harmony 3 Packages | Basic - Full | Updated the Harmony 3 Package readme.md with the latest release contents. | . | MPLAB Harmony 3 Configurator (MHC) | Basic - Full | Updated the MPLAB Harmony Configurator 3 plugin installation screenshot | . | Create “Hello World” application on PIC MCUs | Basic - Full | Updated the Pin Settings UI screenshot | . | Creating a New TrustZone Project | Basic - Full | Updated screenshots of Project creation completion window and Project properties window | . | New video Weblinks added in Basic page | New video Weblinks added in Peripheral page | New doc Weblink added in Peripheral page | . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v110-september-2020",
    "relUrl": "/release_notes.html#quick-docs-release-v110-september-2020"
  },"651": {
    "doc": "Release notes",
    "title": "Quick Docs Release v1.0.0 (June 2020)",
    "content": "New Doc Pages . The following table provides the list of new doc pages: . | Doc Name | Doc Type - Content | . | MPLAB Harmony 3 Configurator (MHC) | Basic - Full | . | MHC Project Graph | Basic - Full | . | MHC Clock Configuration | Basic - Full | . | MHC Pin Configuration | Basic - Full | . | MHC NVIC Configuration | Basic - Full | . | MHC DMA Configuration | Basic - Full | . | MHC Memory Protection Unit Configuration | Basic - Full | . | MHC Code Generation | Basic - Full | . | MHC Window Manager and Log Level | Basic - Full | . | Create First MPLAB Harmony 3 Project | Basic - Full | . | Create “Hello World” application on SAM MCUs | Basic - Full | . | Create “Hello World” application on PIC MCUs | Basic - Full | . | Open an Existing Harmony 3 Project | Basic - Full | . | Harmony 3 Packages | Basic - Full | . | Create IAR or Keil project using MHC | Basic - Full | . | Create new TrustZone Project | Basic - Full | . | Getting Started with MPLAB Harmony v3 on the SAMA5D2 | Basic - Full | . | Getting started with SAM MPU Devices on MPLAB X Tools | Basic - Full | . | Differences between MPLAB Harmony 2 and Harmony 3 | Migration - Brief Overview and Web link | . | MPLAB Harmony 3 Application Development Guide for MPLAB Harmony 2 Users | Migration - Brief Overview and Web link | . | Graphics Applications | Migration - Brief Overview and Web link | . | TCP/IP Applications | Migration - Brief Overview and Web link | . | USB Applications | Migration - Brief Overview and Web link | . | Introduction to MPLAB and Harmony 3 for Atmel Studio and ASF users | Migration - Brief Overview and Web link | . | Porting Application from ASF3 to MPLAB Harmony 3 Framework | Migration - Brief Overview and Web link | . | Atmel START to MPLAB Harmony 3 Migration Guide | Migration - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAMC2x MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM D5x/E5x MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM E70/S70/V70/V71 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM L10 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on SAM D21 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on PIC32MZ EF MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on PIC32MX 470 MCUs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 PLIBs on PIC32MK GP MCUs | Peripheral - Brief Overview and Web link | . | Low Power Application on SAMC2x MCUs Using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Low Power Application on SAM L21 MCUs using Harmony v3 PLIBs | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Drivers and System Services on SAM E70 | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Drivers on SAM E70 using FreeRTOS | Peripheral - Brief Overview and Web link | . | Getting Started with Harmony v3 Middleware on PIC32MZ EF using FreeRTOS | Middleware - Brief Overview and Web link | . | MPLAB Harmony 3 Audio Overview | Middleware - Brief Overview and Web link | . | Creating your first Audio Application | Middleware - Brief Overview and Web link | . | Creating Your first Audio Decoder Application | Middleware - Brief Overview and Web link | . | SD Card Audio Player/Reader Tutorial | Middleware - Brief Overview and Web link | . | Audio-Tone Generation Using a Lookup Table | Middleware - Brief Overview and Web link | . | Audio-Tone Generation from a Text File Stored in an SD Card | Middleware - Brief Overview and Web link | . | SD Card Reader Support to Load Audio Files | Middleware - Brief Overview and Web link | . | Play a WAV Audio File from an SD Card | Middleware - Brief Overview and Web link | . | Display Graphics Support to Select and Play Audio File | Middleware - Brief Overview and Web link | . | Quickstart Prebuilt Graphics Applications | Middleware - Brief Overview and Web link | . | Creating a new Graphics Application | Middleware - Brief Overview and Web link | . | Graphics Quick Start Application Guides | Middleware - Brief Overview and Web link | . | Harmony Graphics Suite User Guide | Middleware - Brief Overview and Web link | . | Create your first USB Device Application | Middleware - Brief Overview and Web link | . | Create Your First USB Host Application | Middleware - Brief Overview and Web link | . | Harmony USB Stack User Guide | Middleware - Brief Overview and Web link | . | Create your first TCP/IP Application | Middleware - Brief Overview and Web link | . | Harmony TCP/IP User Guide | Middleware - Brief Overview and Web link | . | Create a Touch Project in Harmony | Middleware - Brief Overview and Web link | . | Create Touch Surface &amp; Gesture Project in Harmony | Middleware - Brief Overview and Web link | . | Harmony QTouch User Guide | Middleware - Brief Overview and Web link | . | Harmony Crypto Overview - Board Examples | Middleware - Brief Overview and Web link | . | Create Your First WINC Bypass Mode Example | Middleware - Brief Overview and Web link | . | Harmony WINC Driver Architecture | Middleware - Brief Overview and Web link | . | Create your First Bluetooth Application in Harmony | Middleware - Brief Overview and Web link | . Updated Doc Pages . - NA - . Known Issues . - NA - . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#quick-docs-release-v100-june-2020",
    "relUrl": "/release_notes.html#quick-docs-release-v100-june-2020"
  },"652": {
    "doc": "Release notes",
    "title": "Reference Links",
    "content": "                . ",
    "url": "http://localhost:4000/quick_docs/release_notes.html#reference-links",
    "relUrl": "/release_notes.html#reference-links"
  },"653": {
    "doc": "Release notes",
    "title": "Release notes",
    "content": " ",
    "url": "http://localhost:4000/quick_docs/release_notes.html",
    "relUrl": "/release_notes.html"
  },"654": {
    "doc": "Harmony 3 Quick Docs",
    "title": "Harmony 3 Quick Docs",
    "content": "# MPLAB Harmony 3 Quick Documentation Package MPLAB Harmony 3 is an extension of the MPLAB® ecosystem for creating embedded firmware solutions for Microchip 32-bit SAM and PIC® microcontroller and microprocessor devices. Refer to the following links for more information. This repository contains the MPLAB Harmony 3 Quick Documentation Package. Quick documents are standalone html pages that help to get started developing applications using Microchip 32-bit SAM and PIC MCUs using MPLAB Harmony 3 software framework. [](/quick_docs/source/basic/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; [](/quick_docs/source/migration/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; [](/quick_docs/source/peripheral/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; [](/quick_docs/source/middleware/readme.html) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ ]() - [**Harmony Basics**](/quick_docs/source/basic/readme.html) : Cover topics that help to get started developing applications using MPLAB Harmony 3 software framework. For Example: MPLAB Harmony 3 Configurator (MHC), Creating the first application on Harmony 3, etc. - [**Migration Guides**](/quick_docs/source/migration/readme.html) : Cover topics that help migrate from other Microchip 32-bit software solutions offering to MPLAB Harmony 3 based solution. For example: Port an existing application from Harmony 2/ASF/START to Harmony 3, etc. - [**Peripheral Libraries**](/quick_docs/source/peripheral/readme.html) : Cover topics that help use MPLAB Harmony peripheral libraries and drivers. For Example: Getting Started with Harmony v3 Peripheral Libraries on SAM D5x/E5x MCUs. - [**Middleware Examples**](/quick_docs/source/middleware/readme.html) : Cover topics that help use MPLAB Harmony middleware libraries to implement larger feature rich applications involving integration of multiple technologies. For Example: SD Card Audio Player/Reader Tutorial. The above doc types serve as a reference to evaluate solutions on 32-bit SAM and PIC MCUs by developing applications using MPLAB Harmony 3 software framework on Microchip 32-bit SAM and PIC development boards/kits. **Note**: The doc pages in this repository is a quick source covering the above types. MPLAB Harmony 3 solutions provides more peripheral or technology specific documentation. Refer the specific peripheral/technology repository to find specific documentation. **Repository and documentation support:** - The following table lists the fundamental and few technology specific repositories in MPLAB Harmony 3 Software Framework | Repository | # Documentation | --- | ---| csp | Covers documentation for the peripheral libraries (PLIBs) and related applications that directly control the SAM and PIC peripherals | core | Covers documentation for drivers, system services and the related applications using them. Applications that use the drivers and system services that have advanced capabilities and a higher level of abstraction that gives better hardware independence | usb | Covers documentation for USB library and related applications that demonstrate the capabilities of the MPLAB Harmony USB stack | net | Covers documentation for TCP/IP stack and related applications that demonstrate the capabilities of the MPLAB Harmony TCP/IP stack. These applications use well-known protocols like TCP, UDP, HTTP, SMTP, etc | gfx | Covers documentation for the quick start applications that demonstrates MPLAB Harmony Aria/Legato Graphics Libraries | gfx_apps | Covers documentation for the non quick start applications that demonstrates MPLAB Harmony Aria/Legato Graphics Libraries | audio | Covers documentation for Harmony Audio offerings and applications that demonstrates capabilities of the MPLAB Harmony audio offerings, drivers for hardware codecs that can be connected to development boards, audio decoders, etc | ### Note: The above is not an exhaustive list of all MPLAB Harmony 3 packages and corresponding documentation offerings. Refer the MPLAB Harmony 3 GitHub Launch page to view the complete list of MPLAB Harmony 3 packages. In each of these packages refer the underlying documentation. Refer to the following links for release notes and reference application information. - [Release Notes](/quick_docs/release_notes.html) - [MPLAB® Harmony License](/quick_docs/mplab_harmony_license.html) - [MPLAB® Harmony 3 Quick Docs Wiki](https://github.com/Microchip-MPLAB-Harmony/quick_docs/wiki) ____ [ ]() &nbsp; &nbsp; &nbsp; [ ]() &nbsp; &nbsp; &nbsp; [ ]() &nbsp; &nbsp; [ ]() [ ]() ____ [![License](https://img.shields.io/badge/license-Harmony%20license-orange.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/blob/master/mplab_harmony_license.md) [![Latest release](https://img.shields.io/github/release/Microchip-MPLAB-Harmony/quick_docs.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/releases/latest) [![Latest release date](https://img.shields.io/github/release-date/Microchip-MPLAB-Harmony/quick_docs.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/releases/latest) [![Commit activity](https://img.shields.io/github/commit-activity/y/Microchip-MPLAB-Harmony/quick_docs.svg)](https://github.com/Microchip-MPLAB-Harmony/quick_docs/graphs/commit-activity) [![Contributors](https://img.shields.io/github/contributors-anon/Microchip-MPLAB-Harmony/quick_docs.svg)]() ____ [![Follow us on Youtube](https://img.shields.io/badge/Youtube-Follow%20us%20on%20Youtube-red.svg)](https://www.youtube.com/user/MicrochipTechnology) [![Follow us on LinkedIn](https://img.shields.io/badge/LinkedIn-Follow%20us%20on%20LinkedIn-blue.svg)](https://www.linkedin.com/company/microchip-technology) [![Follow us on Facebook](https://img.shields.io/badge/Facebook-Follow%20us%20on%20Facebook-blue.svg)](https://www.facebook.com/microchiptechnology/) [![Follow us on Twitter](https://img.shields.io/twitter/follow/MicrochipTech.svg?style=social)](https://twitter.com/MicrochipTech) [![](https://img.shields.io/github/stars/Microchip-MPLAB-Harmony/quick_docs.svg?style=social)]() [![](https://img.shields.io/github/watchers/Microchip-MPLAB-Harmony/quick_docs.svg?style=social)]() ",
    "url": "http://localhost:4000/quick_docs/",
    "relUrl": "/"
  }
}
`;
var data_for_search
(function (jtd, undefined) {

// Event handling

jtd.addEvent = function(el, type, handler) {
  if (el.attachEvent) el.attachEvent('on'+type, handler); else el.addEventListener(type, handler);
}
jtd.removeEvent = function(el, type, handler) {
  if (el.detachEvent) el.detachEvent('on'+type, handler); else el.removeEventListener(type, handler);
}
jtd.onReady = function(ready) {
  // in case the document is already rendered
  if (document.readyState!='loading') ready();
  // modern browsers
  else if (document.addEventListener) document.addEventListener('DOMContentLoaded', ready);
  // IE <= 8
  else document.attachEvent('onreadystatechange', function(){
      if (document.readyState=='complete') ready();
  });
}

// Show/hide mobile menu

function initNav() {
  jtd.addEvent(document, 'click', function(e){
    var target = e.target;
    while (target && !(target.classList && target.classList.contains('nav-list-expander'))) {
      target = target.parentNode;
    }
    if (target) {
      e.preventDefault();
      target.parentNode.classList.toggle('active');
    }
  });

  const siteNav = document.getElementById('site-nav');
  const mainHeader = document.getElementById('main-header');
  const menuButton = document.getElementById('menu-button');

  jtd.addEvent(menuButton, 'click', function(e){
    e.preventDefault();

    if (menuButton.classList.toggle('nav-open')) {
      siteNav.classList.add('nav-open');
      mainHeader.classList.add('nav-open');
    } else {
      siteNav.classList.remove('nav-open');
      mainHeader.classList.remove('nav-open');
    }
  });
}
// Site search

function initSearch() {

	 data_for_search = JSON.parse(myVariable);
     lunr.tokenizer.separator = /[\s/]+/

      var index = lunr(function () {
        this.ref('id');
        this.field('title', { boost: 200 });
        this.field('content', { boost: 2 });
        this.field('url');
        this.metadataWhitelist = ['position']

		var location = document.location.pathname;
		var path = location.substring(0, location.lastIndexOf("/"));
		var directoryName = path.substring(path.lastIndexOf("/")+1);
		var s_before = "http://localhost:4000/quick_docs/";
		var repo_name = "quick_docs";

        var cur_path_from_repo = path.substring(path.lastIndexOf(repo_name));

        // Decrement depth by 2 as HTML files are placed in repo_name/docs
        var cur_depth_from_doc_folder = (cur_path_from_repo.split("/").length - 2);
        var rel_path_to_doc_folder = "";

        if (cur_depth_from_doc_folder == 0) {
            rel_path_to_doc_folder = "./"
        }
        else {
            for (var i = 0; i < cur_depth_from_doc_folder; i++)
            {
                rel_path_to_doc_folder = rel_path_to_doc_folder + "../"
            }
        }


        for (var i in data_for_search) {
			data_for_search[i].url = data_for_search[i].url.replace(s_before, rel_path_to_doc_folder);
			
			if (data_for_search[i].title == "Harmony 3 Quick Docs")
			{
				data_for_search[i].url = data_for_search[i].url + "index.html"
			}
			
          this.add({
            id: i,
            title: data_for_search[i].title,
            content: data_for_search[i].content,
            url: data_for_search[i].url
          });
        }
      });

      searchLoaded(index, data_for_search);
}
function searchLoaded(index, docs) {
  var index = index;
  var docs = docs;
  var searchInput = document.getElementById('search-input');
  var searchResults = document.getElementById('search-results');
  var mainHeader = document.getElementById('main-header');
  var currentInput;
  var currentSearchIndex = 0;

  function showSearch() {
    document.documentElement.classList.add('search-active');
  }

  function hideSearch() {
    document.documentElement.classList.remove('search-active');
  }

  function update() {
    currentSearchIndex++;

    var input = searchInput.value;
    if (input === '') {
      hideSearch();
    } else {
      showSearch();
      // scroll search input into view, workaround for iOS Safari
      window.scroll(0, -1);
      setTimeout(function(){ window.scroll(0, 0); }, 0);
    }
    if (input === currentInput) {
      return;
    }
    currentInput = input;
    searchResults.innerHTML = '';
    if (input === '') {
      return;
    }

    var results = index.query(function (query) {
      var tokens = lunr.tokenizer(input)
      query.term(tokens, {
        boost: 10
      });
      query.term(tokens, {
        wildcard: lunr.Query.wildcard.TRAILING
      });
    });

    if ((results.length == 0) && (input.length > 2)) {
      var tokens = lunr.tokenizer(input).filter(function(token, i) {
        return token.str.length < 20;
      })
      if (tokens.length > 0) {
        results = index.query(function (query) {
          query.term(tokens, {
            editDistance: Math.round(Math.sqrt(input.length / 2 - 1))
          });
        });
      }
    }

    if (results.length == 0) {
      var noResultsDiv = document.createElement('div');
      noResultsDiv.classList.add('search-no-result');
      noResultsDiv.innerText = 'No results found';
      searchResults.appendChild(noResultsDiv);

    } else {
      var resultsList = document.createElement('ul');
      resultsList.classList.add('search-results-list');
      searchResults.appendChild(resultsList);

      addResults(resultsList, results, 0, 10, 100, currentSearchIndex);
    }

    function addResults(resultsList, results, start, batchSize, batchMillis, searchIndex) {
      if (searchIndex != currentSearchIndex) {
        return;
      }
      for (var i = start; i < (start + batchSize); i++) {
        if (i == results.length) {
          return;
        }
        addResult(resultsList, results[i]);
      }
      setTimeout(function() {
        addResults(resultsList, results, start + batchSize, batchSize, batchMillis, searchIndex);
      }, batchMillis);
    }

    function addResult(resultsList, result) {
      var doc = docs[result.ref];

      var resultsListItem = document.createElement('li');
      resultsListItem.classList.add('search-results-list-item');
      resultsList.appendChild(resultsListItem);

      var resultLink = document.createElement('a');
      resultLink.classList.add('search-result');
      resultLink.setAttribute('href', doc.url);
      resultsListItem.appendChild(resultLink);

      var resultTitle = document.createElement('div');
      resultTitle.classList.add('search-result-title');
      resultLink.appendChild(resultTitle);

      var resultDoc = document.createElement('div');
      resultDoc.classList.add('search-result-doc');
      resultDoc.innerHTML = '<svg viewBox="0 0 24 24" class="search-result-icon"><use xlink:href="#svg-doc"></use></svg>';
      resultTitle.appendChild(resultDoc);

      var resultDocTitle = document.createElement('div');
      resultDocTitle.classList.add('search-result-doc-title');
      resultDocTitle.innerHTML = doc.doc;
      resultDoc.appendChild(resultDocTitle);
      var resultDocOrSection = resultDocTitle;

      if (doc.doc != doc.title) {
        resultDoc.classList.add('search-result-doc-parent');
        var resultSection = document.createElement('div');
        resultSection.classList.add('search-result-section');
        resultSection.innerHTML = doc.title;
        resultTitle.appendChild(resultSection);
        resultDocOrSection = resultSection;
      }

      var metadata = result.matchData.metadata;
      var titlePositions = [];
      var contentPositions = [];
      for (var j in metadata) {
        var meta = metadata[j];
        if (meta.title) {
          var positions = meta.title.position;
          for (var k in positions) {
            titlePositions.push(positions[k]);
          }
        }
        if (meta.content) {
          var positions = meta.content.position;
          for (var k in positions) {
            var position = positions[k];
            var previewStart = position[0];
            var previewEnd = position[0] + position[1];
            var ellipsesBefore = true;
            var ellipsesAfter = true;
            for (var k = 0; k < 5; k++) {
              var nextSpace = doc.content.lastIndexOf(' ', previewStart - 2);
              var nextDot = doc.content.lastIndexOf('. ', previewStart - 2);
              if ((nextDot >= 0) && (nextDot > nextSpace)) {
                previewStart = nextDot + 1;
                ellipsesBefore = false;
                break;
              }
              if (nextSpace < 0) {
                previewStart = 0;
                ellipsesBefore = false;
                break;
              }
              previewStart = nextSpace + 1;
            }
            for (var k = 0; k < 10; k++) {
              var nextSpace = doc.content.indexOf(' ', previewEnd + 1);
              var nextDot = doc.content.indexOf('. ', previewEnd + 1);
              if ((nextDot >= 0) && (nextDot < nextSpace)) {
                previewEnd = nextDot;
                ellipsesAfter = false;
                break;
              }
              if (nextSpace < 0) {
                previewEnd = doc.content.length;
                ellipsesAfter = false;
                break;
              }
              previewEnd = nextSpace;
            }
            contentPositions.push({
              highlight: position,
              previewStart: previewStart, previewEnd: previewEnd,
              ellipsesBefore: ellipsesBefore, ellipsesAfter: ellipsesAfter
            });
          }
        }
      }

      if (titlePositions.length > 0) {
        titlePositions.sort(function(p1, p2){ return p1[0] - p2[0] });
        resultDocOrSection.innerHTML = '';
        addHighlightedText(resultDocOrSection, doc.title, 0, doc.title.length, titlePositions);
      }

      if (contentPositions.length > 0) {
        contentPositions.sort(function(p1, p2){ return p1.highlight[0] - p2.highlight[0] });
        var contentPosition = contentPositions[0];
        var previewPosition = {
          highlight: [contentPosition.highlight],
          previewStart: contentPosition.previewStart, previewEnd: contentPosition.previewEnd,
          ellipsesBefore: contentPosition.ellipsesBefore, ellipsesAfter: contentPosition.ellipsesAfter
        };
        var previewPositions = [previewPosition];
        for (var j = 1; j < contentPositions.length; j++) {
          contentPosition = contentPositions[j];
          if (previewPosition.previewEnd < contentPosition.previewStart) {
            previewPosition = {
              highlight: [contentPosition.highlight],
              previewStart: contentPosition.previewStart, previewEnd: contentPosition.previewEnd,
              ellipsesBefore: contentPosition.ellipsesBefore, ellipsesAfter: contentPosition.ellipsesAfter
            }
            previewPositions.push(previewPosition);
          } else {
            previewPosition.highlight.push(contentPosition.highlight);
            previewPosition.previewEnd = contentPosition.previewEnd;
            previewPosition.ellipsesAfter = contentPosition.ellipsesAfter;
          }
        }

        var resultPreviews = document.createElement('div');
        resultPreviews.classList.add('search-result-previews');
        resultLink.appendChild(resultPreviews);

        var content = doc.content;
        for (var j = 0; j < Math.min(previewPositions.length, 3); j++) {
          var position = previewPositions[j];

          var resultPreview = document.createElement('div');
          resultPreview.classList.add('search-result-preview');
          resultPreviews.appendChild(resultPreview);

          if (position.ellipsesBefore) {
            resultPreview.appendChild(document.createTextNode('... '));
          }
          addHighlightedText(resultPreview, content, position.previewStart, position.previewEnd, position.highlight);
          if (position.ellipsesAfter) {
            resultPreview.appendChild(document.createTextNode(' ...'));
          }
        }
      }
      var resultRelUrl = document.createElement('span');
      resultRelUrl.classList.add('search-result-rel-url');
      resultRelUrl.innerText = doc.relUrl;
      resultTitle.appendChild(resultRelUrl);
    }

    function addHighlightedText(parent, text, start, end, positions) {
      var index = start;
      for (var i in positions) {
        var position = positions[i];
        var span = document.createElement('span');
        span.innerHTML = text.substring(index, position[0]);
        parent.appendChild(span);
        index = position[0] + position[1];
        var highlight = document.createElement('span');
        highlight.classList.add('search-result-highlight');
        highlight.innerHTML = text.substring(position[0], index);
        parent.appendChild(highlight);
      }
      var span = document.createElement('span');
      span.innerHTML = text.substring(index, end);
      parent.appendChild(span);
    }
  }

  jtd.addEvent(searchInput, 'focus', function(){
    setTimeout(update, 0);
  });

  jtd.addEvent(searchInput, 'keyup', function(e){
    switch (e.keyCode) {
      case 27: // When esc key is pressed, hide the results and clear the field
        searchInput.value = '';
        break;
      case 38: // arrow up
      case 40: // arrow down
      case 13: // enter
        e.preventDefault();
        return;
    }
    update();
  });

  jtd.addEvent(searchInput, 'keydown', function(e){
    switch (e.keyCode) {
      case 38: // arrow up
        e.preventDefault();
        var active = document.querySelector('.search-result.active');
        if (active) {
          active.classList.remove('active');
          if (active.parentElement.previousSibling) {
            var previous = active.parentElement.previousSibling.querySelector('.search-result');
            previous.classList.add('active');
          }
        }
        return;
      case 40: // arrow down
        e.preventDefault();
        var active = document.querySelector('.search-result.active');
        if (active) {
          if (active.parentElement.nextSibling) {
            var next = active.parentElement.nextSibling.querySelector('.search-result');
            active.classList.remove('active');
            next.classList.add('active');
          }
        } else {
          var next = document.querySelector('.search-result');
          if (next) {
            next.classList.add('active');
          }
        }
        return;
      case 13: // enter
        e.preventDefault();
        var active = document.querySelector('.search-result.active');
        if (active) {
          active.click();
        } else {
          var first = document.querySelector('.search-result');
          if (first) {
            first.click();
          }
        }
        return;
    }
  });

  jtd.addEvent(document, 'click', function(e){
    if (e.target != searchInput) {
      hideSearch();
    }
  });
}

// Switch theme

jtd.getTheme = function() {
  var cssFileHref = document.querySelector('[rel="stylesheet"]').getAttribute('href');
  return cssFileHref.substring(cssFileHref.lastIndexOf('-') + 1, cssFileHref.length - 4);
}

jtd.setTheme = function(theme) {
  var cssFile = document.querySelector('[rel="stylesheet"]');
  cssFile.setAttribute('href', 'http://localhost:4000/quick_docs/assets/css/just-the-docs-' + theme + '.css');
}

// Document ready

jtd.onReady(function(){
  initNav();
  initSearch();
});

})(window.jtd = window.jtd || {});


